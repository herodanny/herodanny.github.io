<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[python全栈-magedu-2018-笔记5]]></title>
    <url>%2Fpython-magedu-2018-notes5.html</url>
    <content type="text"><![CDATA[字符串 一个个字符组成的有序的序列，是字符的集合。 python中一个字符也是str类型。 使用单引号、双引号、三引号引住的字符序列 字符串是不可变对象 Python3起，字符串就是Unicode类型 字符串定义 初始化 举例 &emsp;&emsp; s1 = ‘string’&emsp;&emsp; s2 = “string2”&emsp;&emsp; s3 = ‘’’this’s a “String” ‘’’&emsp;&emsp; s4 = ‘hello \n herodanny.github.io’&emsp;&emsp; s5 = r”hello \n herodanny.github.io”&emsp;&emsp; s6 = ‘c:\windows\nt’&emsp;&emsp; s7 = R”c:\windows\nt”&emsp;&emsp; s8 = ‘c:\windows\\nt’&emsp;&emsp; sql = “””select * from user where name=’tom’ “”” 字符串元素访问——下标 字符串支持使用索引访问 &emsp;&emsp; sql = “select * from user where name=’tom’”&emsp;&emsp; sql[4] # 字符串’c’&emsp;&emsp; sql[4] = ‘o’ 有序的字符集合，字符序列&emsp;&emsp; for c in sql:&emsp;&emsp;&emsp; print(c)&emsp;&emsp;&emsp; print(type(c)) # 什么类型？ 可迭代 &emsp;&emsp; lst = list(sql) 字符串join连接* “string”.join(iterable) -&gt; str 将可迭代对象连接起来，使用string作为分隔符 可迭代对象本身元素都是字符串 返回一个新字符串 &emsp;&emsp; lst = [‘1’,’2’,’3’]&emsp;&emsp; print(“\””.join(lst)) # 分隔符是双引号&emsp;&emsp; print(“ “.join(lst))&emsp;&emsp; print(“\n”.join(lst))&emsp;&emsp; lst = [‘1’,[‘a’,’b’],’3’] # 复杂结构列表&emsp;&emsp; print(“ “.join(lst)) # TypeError: sequence item 1: expected str instance, list found 字符串+连接 + -&gt; str 将2个字符串连接在一起 返回一个新字符串 字符串分割 分割字符串的方法分为2类 split系 将字符串按照分隔符分割成若干字符串，并返回列表 partition系 将字符串按照分隔符分割成2段，返回这2段和分隔符的元组 字符串分割* split(sep=None, maxsplit=-1) -&gt; list of strings 从左至右 sep 指定分割字符串，缺省的情况下空白字符串作为分隔符 maxsplit 指定分割的次数，-1 表示遍历整个字符串 &emsp;&emsp; s1 = “I’m \ta super student.”&emsp;&emsp; s1.split()&emsp;&emsp; s1.split(‘s’)&emsp;&emsp; s1.split(‘super’)&emsp;&emsp; s1.split(‘super ‘)&emsp;&emsp; s1.split(‘ ‘)&emsp;&emsp; s1.split(‘ ‘,maxsplit=2)&emsp;&emsp; s1.split(‘\t’,maxsplit=2) 字符串分割 rsplit(sep=None, maxsplit=-1) -&gt; list of strings 从右向左 sep 指定分割字符串，缺省的情况下空白字符串作为分隔符 maxsplit 指定分割的次数，-1 表示遍历整个字符串 &emsp;&emsp; s1 = “I’m \ta super student.”&emsp;&emsp; s1.rsplit()&emsp;&emsp; s1.rsplit(‘s’)&emsp;&emsp; s1.rsplit(‘super’)&emsp;&emsp; s1.rsplit(‘super ‘)&emsp;&emsp; s1.rsplit(‘ ‘)&emsp;&emsp; s1.rsplit(‘ ‘,maxsplit=2)&emsp;&emsp; s1.rsplit(‘\t’,maxsplit=2) 字符串分割 splitlines([keepends]) -&gt; list of strings 按照行来切分字符串 keepends 指的是是否保留行分隔符 行分隔符包括\n、\r\n、\r等 &emsp;&emsp; ‘ab c\n\nde fg\rkl\r\n’.splitlines()&emsp;&emsp; ‘ab c\n\nde fg\rkl\r\n’.splitlines(True)&emsp;&emsp; s1 = ‘’’I’m a super student.&emsp;&emsp; You’re a super teacher.’’’&emsp;&emsp; print(s1)&emsp;&emsp; print(s1.splitlines())&emsp;&emsp; print(s1.splitlines(True)) 字符串分割* partition(sep) -&gt; (head, sep, tail) 从左至右，遇到分隔符就把字符串分割成两部分，返回头、分隔符、尾三部分的三元组；如果没有找到分隔符，就返回头、2个空元素的三元组 sep 分割字符串，必须指定 &emsp;&emsp; s1 = “I’m a super student.”&emsp;&emsp; s1.partition(‘s’)&emsp;&emsp; s1.partition(‘stu’)&emsp;&emsp; s1.partition(‘’) # ValueError: empty separator&emsp;&emsp; s1.partition(‘abc’) rpartition(sep) -&gt; (head, sep, tail) 从右至左，遇到分隔符就把字符串分割成两部分，返回头、分隔符、尾三部分的三元组；如果没有找到分隔符，就返回2个空元素和尾的三元组 字符串大小写 upper() 全大写 lower() 全小写 大小写，做判断的时候用 swapcase() 交互大小写 字符串排版 title() -&gt; str 标题的每个单词都大写 capitalize() -&gt; str 首个单词大写 center(width[, fillchar]) -&gt; str width 打印宽度 fillchar 填充的字符 zfill(width) -&gt; str width 打印宽度，居右，左边用0填充 ljust(width[, fillchar]) -&gt; str 左对齐 rjust(width[, fillchar]) -&gt; str 右对齐 中文用的少，了解一下 字符串修改* replace(old, new[, count]) -&gt; str 字符串中找到匹配替换为新子串，返回新字符串 count表示替换几次，不指定就是全部替换 &emsp;&emsp; ‘https://www.cnblogs.com&#39;.replace(&#39;w&#39;,&#39;p&#39;)&emsp;&emsp; ‘https://www.cnblogs.com&#39;.replace(&#39;w&#39;,&#39;p&#39;,2)&emsp;&emsp; ‘https://www.cnblogs.com&#39;.replace(&#39;w&#39;,&#39;p&#39;,3)&emsp;&emsp; ‘https://www.cnblogs.com&#39;.replace(&#39;ww&#39;,&#39;p&#39;,2)&emsp;&emsp; ‘https://www.cnblogs.com&#39;.replace(&#39;www&#39;,&#39;python&#39;,2) 字符串修改* strip([chars]) -&gt; str 从字符串两端去除指定的字符集chars中的所有字符 如果chars没有指定，去除两端的空白字符 &emsp;&emsp; s = “\r \n \t Hello Python \n \t”&emsp;&emsp; s.strip()&emsp;&emsp; s = “ I am very very very sorry “&emsp;&emsp; s.strip(‘Iy’)&emsp;&emsp; s.strip(‘Iy ‘) lstrip([chars]) -&gt; str 从左开始 rstrip([chars]) -&gt; str 从右开始 字符串查找* find(sub[, start[, end]]) -&gt; int 在指定的区间[start, end)，从左至右，查找子串sub。找到返回索引，没找到返回-1 rfind(sub[, start[, end]]) -&gt; int 在指定的区间[start, end)，从右至左，查找子串sub。找到返回索引，没找到返回-1 &emsp;&emsp; s = “I am very very very sorry”&emsp;&emsp; s.find(‘very’)&emsp;&emsp; s.find(‘very’, 5)&emsp;&emsp; s.find(‘very’, 6, 13)&emsp;&emsp; s.rfind(‘very’, 10)&emsp;&emsp; s.rfind(‘very’, 10, 15)&emsp;&emsp; s.rfind(‘very’,-10,-1) 字符串查找*与 find 的区别就是抛出异常 index(sub[, start[, end]]) -&gt; int 在指定的区间[start, end)，从左至右，查找子串sub。找到返回索引，没找到抛出异常ValueError rindex(sub[, start[, end]]) -&gt; int 在指定的区间[start, end)，从左至右，查找子串sub。找到返回索引，没找到抛出异常ValueError &emsp;&emsp; s = “I am very very very sorry”&emsp;&emsp; s.index(‘very’)&emsp;&emsp; s.index(‘very’, 5)&emsp;&emsp; s.index(‘very’, 6, 13)&emsp;&emsp; s.rindex(‘very’, 10)&emsp;&emsp; s.rindex(‘very’, 10, 15)&emsp;&emsp; s.rindex(‘very’,-10,-1) 字符串查找 时间复杂度 index和count方法都是O(n) 随着列表数据规模的增大，而效率下降 len(string) 返回字符串的长度，即字符的个数，O(1) 字符串查找 count(sub[, start[, end]]) -&gt; int 在指定的区间[start, end)，从左至右，统计子串sub出现的次数 &emsp;&emsp; s = “I am very very very sorry”&emsp;&emsp; s.count(‘very’)&emsp;&emsp; s.count(‘very’, 5)&emsp;&emsp; s.count(‘very’, 10, 14) 字符串判断* endswith(suffix[, start[, end]]) -&gt; bool 在指定的区间[start, end)，字符串是否是suffix结尾 startswith(prefix[, start[, end]]) -&gt; bool 在指定的区间[start, end)，字符串是否是prefix开头 &emsp;&emsp; s = “I am very very very sorry”&emsp;&emsp; s.startswith(‘very’)&emsp;&emsp; s.startswith(‘very’, 5)&emsp;&emsp; s.startswith(‘very’, 5, 9)&emsp;&emsp; s.endswith(‘very’, 5, 9)&emsp;&emsp; s.endswith(‘sorry’, 5)&emsp;&emsp; s.endswith(‘sorry’, 5, -1)&emsp;&emsp; s.endswith(‘sorry’, 5, 100) 字符串判断 is系列 isalnum() -&gt; bool 是否是字母和数字组成 isalpha() 是否是字母 isdecimal() 是否只包含十进制数字 isdigit() 是否全部数字(0~9) isidentifier() 是不是字母和下划线开头，其他都是字母、数字、下划线 islower() 是否都是小写 isupper() 是否全部大写 isspace() 是否只包含空白字符 字符串格式化 字符串的格式化是一种拼接字符串输出样式的手段，更灵活方便 join 拼接只能使用分隔符，且要求被拼接的是可迭代对象 + 拼接字符串还算方便，但是非字符串需要先转换为字符串才能拼接 在2.5版本之前，只能使用printf style风格的print输出 printf-style formatting，来自于C语言的printf函数 格式要求 占位符：使用%和格式字符组成，例如%s、%d等 s调用str()，r会调用repr()。所有对象都可以被这两个转换。 占位符中还可以插入修饰字符，例如%03d表示打印3个位置，不够前面补零 format % values，格式字符串和被格式的值之间使用%分隔 values只能是一个对象，或是一个和格式字符串占位符数目相等的元组 字符串格式化 printf-style formatting 举例 &emsp;&emsp; “I am %03d” % (20,)&emsp;&emsp; ‘I like %s.’ % ‘Python’&emsp;&emsp; ‘%3.2f%% , 0x%x, 0X%02X’ % (89.7654, 10, 15)&emsp;&emsp; “I am %-5d” % (20,)&emsp;&emsp; 3 是显示的最小总宽度，2 是小数点后的位数(如果可用的话)&emsp;&emsp; - 号表示左对齐，默认是有对齐. 字符串格式化*** format函数格式字符串语法——Python鼓励使用 “{} {xxx}”.format(*args, **kwargs) -&gt; str args是位置参数，是一个元组 kwargs是关键字参数，是一个字典 花括号表示占位符 {}表示按照顺序匹配位置参数，{n}表示取位置参数索引为n的值 {xxx}表示在关键字参数中搜索名称一致的 * {{}} 表示打印花括号 字符串格式化*** 位置参数“{}:{}”.format(‘192.168.1.100’,8888)，这就是按照位置顺序用位置参数替换前面的格式字符串的占位符中 关键字参数或命名参数“{server} {1}:{0}”.format(8888, ‘192.168.1.100’, server=’Web Server Info : ‘) ，位置参数按照序号匹配，关键字参数按照名词匹配 访问元素“{0[0]}.{0[1]}”.format((‘github’,’com’)) 对象属性访问from collections import namedtuplePoint = namedtuple(‘Point’,’x y’)p = Point(4,5) "{{{0.x},{0.y}}}".format(p) 有了这些字符串格式化方法，字符串拼接可以丢弃了。 字符串格式化*** 对齐‘{0}*{1}={2:&lt;2}’.format(3,2,2*3)‘{0}*{1}={2:&lt;02}’.format(3,2,2*3)‘{0}*{1}={2:&gt;02}’.format(3,2,2*3)‘{:^30}’.format(‘centered’)‘{:*^30}’.format(‘centered’) 进制“int: {0:d}; hex: {0:x}; oct: {0:o}; bin: {0:b}”.format(42)“int: {0:d}; hex: {0:#x}; oct: {0:#o}; bin: {0:#b}”.format(42)octets = [192, 168, 0, 1]‘{:02X}{:02X}{:02X}{:02X}’.format(octets)\ 是参数解构，分解为4个元素 字符串格式化***请使用format函数格式化字符串 字符串练习 用户输入一个数字 判断是几位数 打印每一位数字及其重复的次数 依次打印每一位数字，顺序个、十、百、千、万…位 1234567891011121314151617181920num = "" # 这里不写，下面的num也不会出错，在python作用域是能访问到的，但是不写不好while True: num = input("Please input a interger: ").strip() if num.isdigit(): num = int(num) # 把前导0也删除，或 lstrip('0') break else: print("Bad number.")count [0] * 10for i in range(10): count[i] = num.count(str(i)) # 这是可以优化的点for i in range(10): if count[i]: print(i, count[i])lst = list(num)lst.reverse()print(lst) 输入5个数字，打印每个数字的位数，将这些数字排序打印，要求升序打印123456789lst = []for i in range(5): m = input("&gt;&gt;&gt;").strip().lstrip("0") print("这是&#123;&#125;位数".format(len(m))) lst.append(int(m))# print(sorted(lst))lst.sort()print(lst)]]></content>
      <categories>
        <category>python-magedu</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python全栈-magedu-2018-笔记4]]></title>
    <url>%2Fpython-magedu-2018-notes4.html</url>
    <content type="text"><![CDATA[元组tuple 一个有序的元素组成的集合 使用小括号 ( ) 表示 元组是不可变对象 元组的定义 初始化 定义 tuple() -&gt; empty tuple tuple(iterable) -&gt; tuple initialized from iterable’s item &emsp;&emsp; t = tuple() # 工厂方法，空元组是不能插入的&emsp;&emsp; t = ()&emsp;&emsp; t = tuple(range(1,7,2)) # iteratable&emsp;&emsp; t = (2,4,6,3,4,2)&emsp;&emsp; t = (1,) # 一个元素元组的定义，注意有个逗号&emsp;&emsp; t = (1,)5&emsp;&emsp; t = (1,2,3) 6&emsp;&emsp; 元组就像个只读列表，好处就是比列表占用空间少。&emsp;&emsp; t1 = (1, [2, 3], 4)&emsp;&emsp; t1[1][0] = 10 元组元素的访问 支持索引（下标） 正索引：从左至右，从0开始，为列表中每一个元素编号 负索引：从右至左，从-1开始 正负索引不可以超界，否则引发异常IndexError 元组通过索引访问 tuple[index] ，index就是索引，使用中括号访问 &emsp;&emsp; t[1]&emsp;&emsp; t[-2]&emsp;&emsp; t[1] = 5 元组查询 index(value,[start,[stop]]) 通过值value，从指定区间查找列表内的元素是否匹配 匹配第一个就立即返回索引 匹配不到，抛出异常ValueError count(value) 返回列表中匹配value的次数 时间复杂度 index和count方法都是O(n) 随着列表数据规模的增大，而效率下降 len(tuple) 返回元素的个数 元组其它操作 元组是只读的，所以增、改、删方法都没有 命名元组namedtuple 帮助文档中，查阅namedtuple，有使用例程 namedtuple(typename, field_names, verbose=False, rename=False) 命名元组，返回一个元组的子类，并定义了字段 field_names可以是空白符或逗号分割的字段的字符串，可以是字段的列表 &emsp;&emsp; from collections import namedtuple&emsp;&emsp; Point = namedtuple(‘_Point’,[‘x’,’y’]) # Point为返回的类&emsp;&emsp; p = Point(11, 22) &emsp;&emsp; Student = namedtuple(‘Student’, ‘name age’)&emsp;&emsp; tom = Student(‘tom’, 20)&emsp;&emsp; jerry = Student(‘jerry’, 18)&emsp;&emsp; tom.name 练习 依次接收用户输入的3个数，排序后打印 转换int后，判断大小排序。使用分支结构完成 使用max函数 使用列表的sort方法 冒泡法 冒泡法 冒泡法 属于交换排序 两两比较大小，交换位置。如同水泡咕嘟咕嘟往上冒 结果分为升序和降序排列 升序 n个数从左至右，编号从0开始到n-1，索引0和1的值比较，如果索引0大，则交换两者位置，如果索引1大，则不交换。继续比较索引1和2的值，将大值放在右侧。直至n-2和n-1比较完，第一轮比较完成。第二轮从索引0比较到n-2，因为最右侧n-1位置上已经是最大值了。依次类推，每一轮都会减少最右侧的不参与比较，直至剩下最后2个数比较。 降序 和升序相反 1234567891011121314151617181920212223num_list = [[1, 9, 8, 5, 6, 7, 4, 3 ,2], [1, 2, 3, 4, 5, 6, 7, 8, 9], [1, 2, 3, 4, 5, 6, 7, 9, 8]]nums = num_list[2]print(nums)length = len(nums)count_swap = 0count = 0# bubble_sortfor i in range(length): # 有n个数要排序 flag = False for j in range(length-i-1): # 比较的次数 count += 1 if nums[j] &gt; nums[j+1]: tmp = nums[j] nums[j] = nums[j+1] nums[j+1] = tmp flag = True # swapped count_swap += 1 if not flag: breakprint(nums, count_swap, count) 冒泡法总结 冒泡法需要数据一轮轮比较 可以设定一个标记判断此轮是否有数据交换发生，如果没有发生交换，可以结束排序，如果发生交换，继续下一轮排序 最差的排序情况是，初始顺序与目标顺序完全相反，遍历次数1,…,n-1之和n(n-1)/2 最好的排序情况是，初始顺序与目标顺序完全相同，遍历次数n-1 时间复杂度O(n2)]]></content>
      <categories>
        <category>python-magedu</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python全栈-magedu-2018-笔记3]]></title>
    <url>%2Fpython-magedu-2018-notes3.html</url>
    <content type="text"><![CDATA[第三章 - Python 内置数据结构分类 数值型 int、float、complex、bool 序列对象 字符串 str 列表 list tuple 键值对 集合set 字典dict 数值型 数值型 int、float、complex、bool都是class，1、5.0、2+3j都是对象即实例 int：python3的int就是长整型，且没有大小限制，受限于内存区域的大小 float：有整数部分和小数部分组成。支持十进制和科学计数法表示。只有双精度型。 complex：有实数和虚数部分组成，实数和虚数部分都是浮点数，3+4.2J bool：int的子类，仅有2个实例True、False对应1和0，可以和整数直接运算 类型转换（built-in） int(x) 返回一个整数 ，int是与类型名相同的内置转换函数，如果字符串不合法抛出异常 float(x) 返回一个浮点数 complex(x)、complex(x,y) 返回一个复数 bool(x) 返回布尔值，前面讲过False等价的对象 数字的处理函数 round()，四舍五入？六入四舍五取偶 math模块、floor()地板、天花板ceil() int() 、// 举例：&emsp; import math&emsp; print(math.floor(2.5), math.floor(-2.5))&emsp; print(math.ceil(2.5), math.ceil(-2.5)) &emsp; 以下打印什么结果？说明什么&emsp; print(int(-3.6), int(-2.5), int(-1.4))&emsp; print(int(3.6), int(2.5), int(1.4))&emsp; print(7//2, 7//-2, -7//2, -(7//2))&emsp; print(2//3, -2//3, -1//3)&emsp; print(round(2.5), round(2.5001), round(2.6))&emsp; print(round(3.5), round(3.5001), round(3.6), round(3.3))&emsp; print(round(-2.5), round(-2.5001), round(-2.6))&emsp; print(round(-3.5), round(-3.5001), round(-3.6), round(-3.3)) round()，四舍六入五取偶 floor()向下取整、ceil()向上取整 int() 取整数部分 // 整除且向下取整 min() max() pow(x,y) 等于 x**y math.sqrt() 进制函数，返回值是字符串 bin() oct() hex() math.pi π math.e 自如常数 类型判断 type(obj) ，返回类型，而不是字符串 isinstance(obj, class_or_tuple)，返回布尔值 举例： type(a) type(‘abc’) type(123) isinstance(6, str)、type(6) == str isinstance(6, (str, bool, int)) type(1+True) # bool型是int的子类 type(1+True+2.0) # 是什么？隐式转换 # 都是数值类型，往高精度转 列表 一个队列，一个排列整齐的队伍 列表内的个体称作元素，由若干元素组成列表 元素可以是任意对象（数字、字符串、对象、列表等） 列表内元素有顺序，可以使用索引 线性的数据结构 使用 [ ] 表示 列表是可变的 列表list、链表、queue、stack的差异 列表list定义 初始化赋值即定义，这也是静态语言和动态语言的区别。 list() -&gt; new empty list list(iterable) -&gt; new list initialized from iterable’s items 列表不能一开始就定义大小 &emsp;&emsp; lst = list()&emsp;&emsp; lst = []&emsp;&emsp; lst = [2, 6, 9, ‘ab’]&emsp;&emsp; lst = list(range(5)) 列表索引访问 索引，也叫下标 正索引：从左至右，从0开始，为列表中每一个元素编号 负索引：从右至左，从-1开始 正负索引不可以超界，否则引发异常IndexError 为了理解方便，可以认为列表是从左至右排列的，左边是头部，右边是尾部，左边是下界，右边是上界 列表通过索引访问 list[index] ，index就是索引，使用中括号访问 列表查询 index(value,[start,[stop]]) 通过值value，从指定区间查找列表内的元素是否匹配 匹配第一个就立即返回索引 匹配不到，抛出异常ValueError count(value) 返回列表中匹配value的次数 时间复杂度 index和count方法都是O(n) 随着列表数据规模的增大，而效率下降 如何返回列表元素的个数？如何遍历？如何设计高效？ len() 如何查帮助 官方帮助文档 搜索关键字 IPython中 help(keyword) keyword可以是变量、对象、类名、函数名、方法名 列表元素修改 索引访问修改 list[index] = value 索引不要超界 列表增加、插入元素 append(object) -&gt; None 列表尾部追加元素，返回None 返回None就意味着没有新的列表产生，就地修改 时间复杂度是O(1)，因为直接可以索引到结尾添加 insert(index, object) -&gt; None 在指定的索引index处插入元素object 返回None就意味着没有新的列表产生，就地修改 时间复杂度是O(n)，因为会调整内存布局 索引能超上下界吗？ 超越上界，尾部追加 超越下界，头部追加 列表增加、插入元素 extend(iteratable) -&gt; None 将可迭代对象的元素追加进来，返回None 就地修改 + -&gt; list 连接操作，将两个列表连接起来 产生新的列表，原列表不变 本质上调用的是add()方法 * -&gt; list 重复操作，将本列表元素重复n次，返回新的列表 列表 *重复的坑 * -&gt; list 重复操作，将本列表元素重复n次，返回新的列表 &emsp;&emsp; x = [[1,2,3]]*3&emsp;&emsp; print(x)&emsp;&emsp; x[0][1] = 20&emsp;&emsp; print(x) &emsp;&emsp; y = [1]*5&emsp;&emsp; y[0] = 6&emsp;&emsp; y[1] = 7&emsp;&emsp; print(y)&emsp;&emsp; 上面代码运行结果是什么？为什么？ 列表删除元素 remove(value) -&gt; None 从左至右查找第一个匹配value的值，移除该元素，返回None 就地修改 效率？ pop([index]) -&gt; item 不指定索引index，就从列表尾部弹出一个元素 指定索引index，就从索引处弹出一个元素，索引超界抛出IndexError错误 效率？指定索引的的时间复杂度？不指定索引呢？ clear() -&gt; None 清除列表所有元素，剩下一个空列表（一批元素不要，可能会引起垃圾回收gc） 列表其它操作 reverse() -&gt; None 将列表元素反转，返回None 就地修改 sort(key=None, reverse=False) -&gt; None 只写一个参数，匹配的是第一个参数，要匹配第二个参数，要指明参数名字，这么写 lst.sort(reverse=True) 对列表元素进行排序，就地修改，默认升序 reverse为True，反转，降序 key一个函数，指定key如何排序 lst.sort(key=functionname) in [3,4] in [1, 2, [3,4]] for x in [1,2,3,4] not in 列表复制 先看一段代码 &emsp;&emsp; lst0 = list(range(4))&emsp;&emsp; lst2 = list(range(4))&emsp;&emsp; print(lst0 == lst2)&emsp;&emsp; lst1 = lst0&emsp;&emsp; lst1[2] = 10&emsp;&emsp; print(lst0) &emsp;&emsp; lst0 == lst2相等吗？为什么？lst0里面存的是什么？&emsp;&emsp; == 比较的是对象的内容 (True)&emsp;&emsp; is 比较的是对象的地址 (False) 即 id(lst0) == id(lst2)&emsp;&emsp; 这里虽然都是创建 list(range(4)) 这个对象，解释器并没有优化为只创建一个 &emsp;&emsp; 请问lst0的索引为2的元素的值是什么？&emsp;&emsp; 请问lst1 = lst0这个过程中有没有复制过程？ 列表复制 copy() -&gt; List shadow copy返回一个新的列表 &emsp;&emsp; lst0 = list(range(4))&emsp;&emsp; lst5 = lst0.copy()&emsp;&emsp; id(lst0) 和 id(lst5) 是不同的 ，与 lst5=lst0 还是不一样的&emsp;&emsp; copy是把原列表的item复制到一个片新内存，创建一个新列表&emsp;&emsp; print(lst5 == lst0)&emsp;&emsp; lst5[2] = 10&emsp;&emsp; print(lst5 == lst0)&emsp;&emsp; lst0和lst5一样吗？ 对比前面程序的差别 &emsp;&emsp; lst0 = [1, [2, 3, 4], 5]&emsp;&emsp; lst5 = lst0.copy()&emsp;&emsp; lst5 == lst0&emsp;&emsp; lst5[2] = 10&emsp;&emsp; lst5 == lst0&emsp;&emsp; lst5[2] = 5&emsp;&emsp; lst5[1][1] = 20&emsp;&emsp; lst5 == lst0&emsp;&emsp; list中间元素是个复杂元素，所以copy时只拷贝了它的引用，即它的地址。所以在一边修改之后，另一边也一同修改了。 列表复制 shadow copy 影子拷贝，也叫浅拷贝，遇到引用类型，只是复制了一个引用而已 深拷贝 copy模块提供了deepcopy &emsp;&emsp;&emsp;&emsp; import copy&emsp;&emsp;&emsp;&emsp; lst0 = [1, [2, 3, 4], 5]&emsp;&emsp;&emsp;&emsp; lst5 = copy.deepcopy(lst0)&emsp;&emsp;&emsp;&emsp; lst5[1][1] = 20&emsp;&emsp;&emsp;&emsp; lst5 == lst0 随机数 random模块 randint(a, b) 返回[a, b]之间的整数 choice(seq) 从非空序列的元素中随机挑选一个元素，比如random.choice(range(10))，从0到9中随机挑选一个整数。random.choice([1,3,5,7]) randrange ([start,] stop [,step]) 从指定范围内，按指定基数递增的集合中获取一个随机数，基数缺省值为1。 random.randrange(1,7,2) random.shuffle(list) -&gt;None 就地打乱列表元素 sample(population, k) 从样本空间或总体（序列或者集合类型）中随机取出k个不同的元素，返回一个新的列表 random.sample([‘a’, ‘b’, ‘c’, ‘d’], 2) random.sample([‘a’, ‘a’], 2) 会返回什么结果]]></content>
      <categories>
        <category>python-magedu</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python全栈-magedu-2018-笔记2]]></title>
    <url>%2Fpython-magedu-2018-notes2.html</url>
    <content type="text"><![CDATA[第二章 - Python 基础语法基本语法 注释 —— # 标注的文本 数字 整数，不区分long和int 进制0xa、0o10、0b10 bool，2个值True、False 浮点数 1.2、3.1415、-0.12，1.46e9等价于1.46*109 复数，1+2j 字符串 使用 ‘ “ 单双引号引用的字符的序列 ‘’’和””” 单双三引号，可以跨行、可以在其中自由的使用单双引号 在字符串前面加上r或者R前缀，表示该字符串不做特殊的处理 转义序列 \\ \t \r \n \&#39; \&quot; 前缀r，把里面的所有字符当普通字符对待 缩进 未使用C等语言的花括号，而是采用缩进的方式表示层次关系 约定使用4个空格缩进 续行 在行尾使用 \ 如果使用各种括号，认为括号内是一个整体，内部跨行不用 \ 标识符 一个名字，用来指代一个值 只能字母、下划线和数字 只能以字母或下划线开头 不能是python的关键字，例如def、class就不能作为标识符 Python是大小写敏感的 约定： 不允许使用中文 不允许使用歧义单词，例如class_ 在python中不要随便使用下划线开头的表示符 常量 一旦赋值就不能改变值的标识符 python中无法定义常量 字面常量 一个单独的量，例如 12、”abc” 、’2341356514.03e-9’ 变量 赋值后，可以改变值的标识符 Python的语言类型 Python是动态语言、强类型语言 静态编译语言 实现声明变量类型，类型不能再改变 编译时检查 动态编译语言 不用事先声明类型，随时可以赋值为其他类型 编程时不知道是什么类型，很难推断 强类型语言 不同类型之间操作，必须先强制类型转换为同一类型。print(‘a’+1) 弱类型语言 不同类型间可以操作，自动隐式转换，JavaScript中console.log(1+’a’) 运算符 Operator 算数运算符 + - * / % ** 自然除/结果是浮点数，整除//。注：2.x中/和//都是整除 位运算符 &amp; | ~ ^ &lt;&lt; &gt;&gt; 常用方式：乘除2的倍数，32 // 4相当于 32 &gt;&gt; 2 12，0xc，0o14，0b1100 ~12等于多少，为什么 原码、反码、补码，负数表示法 原码 5 =&gt; 0b101，1 =&gt; 0b1 ，-1 =&gt; -0b1， bin(-1) 反码 正数的反码与原码相同；负数的反码符号位不变其余按位取反 补码 正数的补码与原码相同；负数的补码符号位不变其余按位取反后+1有符号数才用补码表示 负数表示法 数字电路的CPU中的运算器实现了加法器，但是没有减法器，减法是转换成加法 负数在计算机中使用补码存储，-1的补码为1111 1111 5-1 =&gt; 5+(-1)直觉上是0b101-0b1，其实计算机中是0b101+0b11111111，溢出位舍弃 ~12为什么是-13？ 10^9 等于？ 10^-9等于？为什么 &#160;&#160;&#160;&#160; 5 的补码 0000 0101&#160;&#160;&#160;&#160; -1 的原码 1000 0001&#160;&#160;&#160;&#160; -1 的补码 1111 1111 (0xff)&#160;&#160;&#160;&#160; 5-1得 0000 0100 &#160;&#160;&#160;&#160; 12 的补码 0000 1100&#160;&#160;&#160;&#160; ~12 是 1111 0011&#160;&#160;&#160;&#160; 怎么从补码得到原码？&#160;&#160;&#160;&#160; 与得到补码是一样的，最高位不变，其他位取反加一，即补码的补码就是原码&#160;&#160;&#160;&#160; 1000 1101 (即-13) 比较运算符 == != &gt; &lt; &gt;= &lt;= 返回一个bool值 1 &lt; ‘1’ &#160; 报错 &#160;&#160;&#160;&#160;&#160; 1 == ‘1’ &#160; False == 是可以不同类型比较的，除非 大于、小于等做类型重载，不然是不能比较的 链式比较操作符 4&gt;3&gt;2 &#160;&#160;&#160;&#160;&#160; 4&gt;mynumber&gt;=1 逻辑运算符 与或非 and or not 短路运算符 and 如果第一个表达式为False，后面就没有必要计算了，这个逻辑表达式一定是False or 如果第一个表达式True，后面没有必要计算了，这个逻辑表达式一定是True 赋值运算符 a = min(3,5) += -= *= /= %= 等 x = y = z = 10 尽量少用连等，因为如果右边是个引用就麻烦了 成员运算符 in、not in 身份运算符 is 、is not 运算符优先级（由高到低） 运算符 描述 ‘expr’ 字符串转换 {key:expr} 字典 [expr1, expr2, …] 列表 (expr1, expr2, …) 元组 function(expr, …) 函数调用 x[index:index] 切片 x[index] 下标索引值 x.attribute 属性引用 ~x 按位取反 +x, -x 正，负 x ** y 幂 x * y, x / y, x % y 乘法,除,取模 x + y, x - y 加，减 x &lt;&lt; y, x &gt;&gt; y 移位 x &amp; y 按位与 x ^ y 按位异或 x \ y 按位或 x &lt; y, x &lt;= y , x == y, x != y, x &gt;= y, x &gt; y 比较 x is y , x is not y 等同测试 x in y, x not in y 成员测试 not x 逻辑否 x and y 逻辑与 x or y 逻辑或 lambda arg, … : expr Lambda 匿名函数 算数运算符 &gt; 位运算符 &gt; 身份运算符 &gt; 成员运算符 &gt; 逻辑运算符 &gt; 赋值运算符 位运算符也可以看成算术运算 记不住，用括号 长表达式，多用括号，易懂、易读 表达式 Expression 由数字、符号、括号、变量等的组合 算数表达式 逻辑表达式 赋值表达式 Python中，赋值即定义，如果一个变量已经定义，赋值相当于重新定义 内存管理 变量无须事先声明，也不需要指定类型 动态语言的特性 编程中一般无须关心变量的存亡，也不用关心内存的管理 python使用引用计数记录所有对象的引用数 当对象引用数变为0，它就可以被 垃圾回收GC 计数增加： 赋值给其它变量就增加引用计数，例如x=3;y=x 计数减少： 函数运行结束时，局部变量就会被自动销毁，对象引用计数减少 变量被赋值给其它对象。例如x=3;y=x;x=4 有关性能的时候，就需要考虑变量的引用问题，但是该释放内存，还是尽量不释放内存，看需求 程序控制 顺序 按照先后顺序一条条执行 例如，先洗手，再吃饭，再洗碗 分支 根据不同的情况判断，条件满足执行某条件下的语句 例如，先洗手，如果饭没有做好，玩游戏，如果饭做好了，就吃饭，如果饭都没有做，叫外卖 循环 条件满足就反复执行，不满足就不执行或不再执行 例如，先洗手，看饭好了没有，没有好，一会来看一次是否好了，一会儿来看一次，直到饭好了，才可是吃饭。这里循环的条件是饭没有好，饭没有好，就循环的来看饭好了没有 单分支结构 if语句 if condition: 代码块 condition必须是一个bool类型，这个地方有一个隐式转换bool(condition) if 1&lt;2: &#160;&#160;&#160;&#160;print(‘1 less than 2’) 代码块 类似于if语句的冒号后面的就是一个语句块 在if、for、def、class等 真值表 对象/常量 值 “” 假 “string” 真 0 假 &gt;=1 真 &lt;=-1 真 ()空元组 假 []空列表 假 {}空字典 假 None 假 False等价布尔值，相当于bool(value) 空集合 空字符串 空字典 空列表 空元祖 None对象 0 多分支结构 if…elif…else语句&#160;&#160;&#160;&#160;if condition1:&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;代码块1&#160;&#160;&#160;&#160;elif condition2:&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;代码块2&#160;&#160;&#160;&#160;elif condition3:&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;代码块3&#160;&#160;&#160;&#160;……&#160;&#160;&#160;&#160;else:&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;代码块 举例&#160;&#160;&#160;&#160;a = 5&#160;&#160;&#160;&#160;if a&lt;0:&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;print(‘negative’)&#160;&#160;&#160;&#160;elif a==0:&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;print(‘zero’)&#160;&#160;&#160;&#160;else:&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;print(‘positive’) 分支嵌套 举例&#160;&#160;&#160;&#160;score = 80&#160;&#160;&#160;&#160;&#160;if score&lt;0:&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;print(‘wrong’)&#160;&#160;&#160;&#160;else:&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if score==0:&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;print(‘egg’)&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;elif score &lt;= 100:&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;print(‘right’)&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;else:&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;print(‘too big’) 嵌套结构，可以是分支、循环的嵌套 可以互相嵌套多层 练习：给定一个不超过5位的正整数，判断其有几位 使用 input 函数，input返回的是字符串 如果位数多的话可以用折半 num = 8if (num /= 10) == 0: &#160;&#160;&#160;&#160; 为什么这里报错&#160;&#160;&#160;&#160;print(‘1位数’) 循环——while语句 语法&#160;&#160;&#160;&#160;while condition:&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;block 当条件满足即condition为True，进入循环体，执行block 举例&#160;&#160;&#160;&#160;flag=10&#160;&#160;&#160;&#160;while flag:&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;print(flag)&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;flag -= 1 执行结果是什么？为什么？ 如果flag=-10可以吗？如何改造？ 循环——for语句* 语法 for element in iteratable:&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;block 当可迭代对象中有元素可以迭代，进入循环体，执行block range函数 举例：打印1~10&#160;&#160;&#160;&#160;for i in range(10):&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;print(i+1) 执行结果是什么？为什么？ 如果想倒序打印呢 循环 continue语句 中断当前循环的当次执行，继续下一次循环 举例：计算10以内的偶数（for循环）&#160;&#160;&#160;&#160;for i in range(10):&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if not i%2: &#160;&#160;&#160;&#160; # i%2==0这么写也行&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;print(i) 还有其它的实现吗？ &#160;&#160;&#160;&#160;for i in range(0,10,2):&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;print(i) &#160;&#160;&#160;&#160;for i in range(0,10):&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if i &amp; 1: &#160;&#160;&#160;&#160;# 或用 i%2 表示奇数就continue&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;continue&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;print(i) 循环 break语句 终止当前循环 举例：计算1000以内的被7整除的前20个数（for循环）&#160;&#160;&#160;&#160;count = 0&#160;&#160;&#160;&#160;for i in range(0,1000,7):&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;print(i)&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;count += 1&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if count &gt;= 20:&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;break 循环 continue、break语句 总结 continue和break是循环的控制语句，只影响当前循环，包括while、for循环 如果循环嵌套， continue和break也只影响语句所在的那一层循环 continue和break 不是跳出语句块，所以 if cond: break 不是跳出if，而是终止if外的break所在的循环 练习：给定一个不超过5位的正整数，判断该数的位数，依次打印出个位、十位、百位、千位、万位的数字 循环 else子句 语法&#160;&#160;&#160;&#160;while condition:&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;block&#160;&#160;&#160;&#160;else:&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;block&#160;&#160;&#160;&#160;for element in iteratable:&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;block&#160;&#160;&#160;&#160;else:&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;block 如果循环正常的执行结束，就执行else子句；如果使用break终止，else子句不会执行]]></content>
      <categories>
        <category>python-magedu</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python全栈-magedu-2018-笔记1]]></title>
    <url>%2Fpython-magedu-2018-notes1.html</url>
    <content type="text"><![CDATA[第一章 - Python 环境搭建操作系统准备准备Linux最小系统即可。 如果在虚拟机中克隆，MAC地址会变。 这里使用CentOS 6.5+ Pyenv 安装 安装git 1yum install git -y 安装Python编译依赖 1yum -y install gcc make patch gdbm-devel openssl-devel sqlite-devel readline-devel zlib-devel bzip2-devel 创建用户python 12useradd python passwd python 使用python用户登录后安装Pyenv 1curl -L https://github.com/pyenv/pyenv-installer/raw/master/bin/pyenv-installer | bash 下载的 pyenv-installer 是一个shell脚本。注意： 在 https://github.com/pyenv/pyenv-installer 有安装文档 如果curl出现 curl: (35) SSL connect error ，是nss版本低的问题，更新它。 可能需要配置一个有较新包的yum源 [updates] name=CentOS-Updates baseurl=https://mirrors.aliyun.com/centos/6.9/os/x86_64 gpgcheck=0 然后更新nss1yum update nss 在python用户的~/.bash_profile中追加 1234export PATH="/home/python/.pyenv/bin:$PATH" eval "$(pyenv init -)" eval "$(pyenv virtualenv-init -)" source ~/.bash_profile 这样当用户启动的时候，会执行用户的 .bash_profile 中的脚本，就会启动pyenv。 安装好的pyenv 就在~/.pyenv中 Pyenv 使用python 版本及path路径123python --version python -V echo $PATH 可以看到当前系统Python路径 pyenv 命令12pyenvpyenv help install 列出所有可用版本1pyenv install --list 安装指定版本12pyenv install 3.5.3 -v # 加 -v 可以看详细过程 verbosepyenv versions 会从python官网下载安装压缩包到 /tmp 目录，很慢，为了提速，可选用cache方法。 使用缓存方式安装在~/.pyenv目录下，新建cache目录，放入下载好的待安装版本的文件。 不确定要哪一个文件，把下载的3个文件都放进去。一般放 ‘tar.xz’ 包。1$ scp ~/Downloads/Python-3.5.3.tar.xz root@10.211.55.6:~/.pyenv/cache 1pyenv install 3.5.3 -v 安装后的python文件夹在 .pyenv/versions 下。cache文件夹里有下载的压缩包。 pyenv 的 python版本控制version 显示当前的python版本 versions 显示所有可用的python版本，和当前版本。12pyenv versionpyenv versions global 全局设置pyenv global 3.5.3 可以看到所有受pyenv控制的窗口中都是3.5.3的python版本了。 这里用global是作用于非root用户python用户上，如果是root用户安装，请不要使用global，否则影响太大。比如，这里使用的CentOS6.5就是Python2.6，使用了global就成了3.x，会带来很不好的影响。 pyenv global system 回到原来系统版本。 shell 会话设置影响只作用于当前会话 pyenv shell 3.5.3是会话级的，一旦断开sessionid也变了，也不好用。 local 本地设置使用pyenv local设置从当前工作目录开始向下递归都继承这个设置。123pyenv local 3.5.3python -V# 可能还是显示原来的版本，用pyenv version，要在虚拟环境中python -V 才会显示新的版本 也可以使用 anaconda，pyenv 是自己下源码编，某些情况下可能不如 anaconda 直接编好的二进制分发。 Virtualenv 虚拟环境设置为什么要使用虚拟环境？ 因为刚才使用的Python环境都是一个公共的空间，如果多个项目使用不同Python版本开发，或者使用不同的Python版本部署运行，或者使用同样的版本开发的但不同项目使用了不同版本的库，等等这些问题都会带来冲突。最好的解决办法就是每一个项目独立运行自己的“独立小环境”中。 使用插件，在plugins/pyenv-virtualenv中pyenv virtualenv 3.5.3 mag353使用python3.5.3版本创建出一个独立的虚拟空间 mag353。 12345$ pyenv versions* system (set by /home/python/.pyenv/version)3.5.33.5.3/envs/mag353mag353 可以在版本列表中存在，就和3.5.3是一样的，就是一个版本了。以后只要使用这个虚拟版本，包就会按照到这些对应的目录下去，而不是使用3.5.3。可以看到真实的虚拟环境是下 envs/ 目录下。.pyenv/versions/ 下是软链接。 在需要设置python版本的文件夹路径下12pyenv local mag353pyenv versions 怎么会起作用的，是利用了一堆隐藏文件和在 .bash_profile 中添加的那几指令。 现在可以对python进行版本的管理，包的管理。 pip 通用配置pip 是Python的包管理工具，3.x的版本直接带了，可以直接使用。 和yun一样为了使用国内镜像，如下配置。mkdir ~/.pip配置文件在 ~/.pip/pip.conf 123[global]index-url=https://mirrors.aliyun.com/pypi/simple/trusted-host=mirrors.aliyun.com 安装 ipythonipython 是增强的交互式 Python 命令行工具12pip install ipython ipython 安装 JupyterJupyter 是基于WEB的交互式笔记本，其中可以非常方便的使用Python。安装Jupyter，也会安装ipython的。 12345pip install jupyterjupyter notebook helpjupyter notebook password # 设置下浏览器访问时的密码jupyter notebook --ip=0.0.0.0 --no-browserss -tanl 浏览器不能访问是服务器端防火墙问题。 快捷键：shift + enter(运行)、ctrl + enter(运行)、dd(删除一行)、m(用mardkown) 导出包虚拟环境的好处就在于和其他项目运行环境隔离。每一个独立的环境都可以使用pip命令导出已经安装的包，在另一个环境中安装这些包。 123456789(mag353) [python@node web]$ pip freeze &gt; requirement(mag353) [python@node web]$ mkdir ~/magedu/projects/pro1(mag353) [python@node web]$ cd ~/magedu/projects/pro1[python@node pro1]$ pyenv install --list[python@node pro1]$ pyenv install 3.6.4[python@node pro1]$ pyenv virtualenv 3.6.4 mag364[python@node pro1]$ pyenv local mag364(mag364) [python@node pro1]$ mv ../web/requirement ./(mag364) [python@node pro1]$ pip install -r requirement]]></content>
      <categories>
        <category>python-magedu</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[用VsCode写Markdown]]></title>
    <url>%2Fvscode-write-markdown.html</url>
    <content type="text"><![CDATA[Markdown 基本语法段落非常自然，一行文字就是一个段落。 比如： 这是一个段落 会被解释成： 1&lt;p&gt;这是一个段落。&lt;/p&gt; 如果你需要另起一段，请在两个段落之间隔一个空行。 这是一个段落。 这是另一个段落。 会被解释成 123&lt;p&gt;这是一个段落&lt;/p&gt;&lt;p&gt;这是另一个段落&lt;/p&gt; 不隔一个空行的换行行为，在一些编辑器中被解释为换行，即插入一个标签。对与另外一些编辑器，会被解释为插入一个空格。对于后者，若要插入换行标签，请在当前一行的结尾打两个空格。(vscode 就是后者，typora 普通模式是前者，源码模式和 vscode 一样是后者) 没用空一行，在结尾打两个空格的换行，还在一个段落中。 粗体、斜体可以使用星号*或下划线_指定粗体或者斜体。 *这是斜体* _这也是斜体_ **这是粗体** ***这是粗体+斜体*** 会被解释成 1234&lt;em&gt;这是斜体&lt;/em&gt;&lt;em&gt;这也是斜体&lt;/em&gt;&lt;strong&gt;这是粗体&lt;/strong&gt;&lt;strong&gt;&lt;em&gt;这是粗体+斜体&lt;/strong&gt;&lt;/em&gt; 删除线一部分编辑器支持删除线，它不是经典 markdown 中的要素。用波浪线~定义删除线。 ~~就像这样~~ 会被解释成 1&lt;strike&gt;就像这样&lt;/strike&gt; 标题markdown 总支持 1~6 六级标题，通过在一行之前加上不同数量的井号来表示。 # 这是 H1 # ## 这是 H2 ## ### 这是 H3 ### ... ###### 这是 H6 ###### 行尾可以加上任意数量的井号字符，这些字符不会算作标题内容。通常会加上相等数量的字符以保持对称。 此外，H1 和 H2 也可以采用在文本下方添加底线来实现，比如： 这是 H1 ======= 这是 H2 ------- 引用通过在行首加上大于号&gt;来添加引用格式。 &gt; This is a blockquote with two paragraphs. Lorem ipsum dolor sit amet, consectetuer adipiscing elit. Aliquam hendrerit mi posuere lectus. Vestibulum enim wisi, viverra nec, fringilla in, laoreet vitae, risus. &gt; Donec sit amet nisl. Aliquam semper ipsum sit amet velit. Suspendisse id sem consectetuer libero luctus adipiscing. This is a blockquote with two paragraphs. Lorem ipsum dolor sit amet,consectetuer adipiscing elit. Aliquam hendrerit mi posuere lectus.Vestibulum enim wisi, viverra nec, fringilla in, laoreet vitae, risus. Donec sit amet nisl. Aliquam semper ipsum sit amet velit. Suspendisseid sem consectetuer libero luctus adipiscing. 引用可以嵌套： &gt; This is the first level of quoting. &gt; &gt; &gt; This is nested blockquote. &gt; &gt; Back to the first level. This is the first level of quoting. This is nested blockquote. Back to the first level. 也可以嵌套其他格式： &gt; ## 这是一个标题。 &gt; &gt; 1. 这是第一行列表项。 &gt; 2. 这是第二行列表项。 &gt; &gt; 给出一些例子代码： &gt; &gt; return shell_exec(&quot;echo $input | $markdown_script&quot;); 这是一个标题。 这是第一行列表项。 这是第二行列表项。 给出一些例子代码： return shell_exec(&quot;echo $input | $markdown_script&quot;); 列表无序列表使用星号、加号或是减号作为列表标记： * Red * Green * Blue Red Green Blue 等同于 + Red + Green + Blue 和 - Red - Green - Blue 有序列表则使用数字接着一个英文句点： 1. Bird 2. McHale 3. Parish Bird McHale Parish 内敛代码用反引号 ` 来标记内联代码，它们会解释成 &lt;code&gt; 标签。如果代码的内容中有反引号，请用两个反引号包裹。 代码区域有两种方式标记代码区域，原生风格是行首缩进四个空格。 这是一个普通段落： 这是一个代码区块。 会被解释成 &lt;p&gt;这是一个普通段落：&lt;/p&gt; &lt;pre&gt;&lt;code&gt;这是一个代码区块。 &lt;/code&gt;&lt;/pre&gt; 分隔线你可以在一行中用三个以上的星号、减号、底线来建立一个分隔线，行内不能有其他东西。你也可以在星号或是减号中间插入空格。下面每种写法都可以建立分隔线： 12345* * *********- - ---------------------------------------- 链接[an example](http://example.com/) [an example](http://example.com/ &quot;Optional Title&quot;) 会被解释为 &lt;a href=&apos;http://example.com/&apos;&gt;an example&lt;/a&gt; &lt;a href=&apos;http://example.com/&apos; title=&quot;Optional Title&quot;&gt;an example&lt;/a&gt; 除了上面的行内式，也可以使用参考式： [an example][id] 然后在任意空白位置定义： [id]: http://example.com/ &quot;Optional Title&quot; 图像![Alt text](/path/to/img.jpg) ![Alt text](/path/to/img.jpg &quot;Optional Title&quot;) 会被解释为 &lt;img src=&apos;/path/to/img.jpg&apos; alt=&apos;Alt text&apos; /&gt; &lt;img src=&apos;/path/to/img.jpg&apos; alt=&apos;Alt text&apos; title=&apos;Optional Title&apos; /&gt; 同样，图像也有类似的参考式语法。 自动链接如果链接的地址和名字重复，可以用尖括号语法将其简化。 &lt;http://example.com/&gt; 就相当于 [http://example.com/](http://example.com/) 切记，大多数编辑器都会自动将符合url规则的东西视为链接，并且解释成链接。很多时候作者由于疏忽等缘故，链接和后面的中文之间缺少空格，导致链接不正常。所以我建议，链接要么加上尖括号，要么两端加上空格。 转义markdown支持在以下字符前面插入反斜杠 \ 反斜线 ` 反引号 * 星号 _ 底线 {} 花括号 [] 方括号 () 括弧 # 井字号 + 加号 - 减号 . 英文句点 ! 惊叹号 表格| Item | Value | Qty | | :------- | ----: | :---: | | Computer | $1600 | 5 | | Phone | $12 | 12 | | Pipe | $1 | 234 | 会被解释成 123456789101112131415161718192021222324&lt;table&gt;&lt;thead&gt;&lt;tr&gt; &lt;th align="left"&gt;Item&lt;/th&gt; &lt;th align="right"&gt;Value&lt;/th&gt; &lt;th align="center"&gt;Qty&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt; &lt;td align="left"&gt;Computer&lt;/td&gt; &lt;td align="right"&gt;$1600&lt;/td&gt; &lt;td align="center"&gt;5&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt; &lt;td align="left"&gt;Phone&lt;/td&gt; &lt;td align="right"&gt;$12&lt;/td&gt; &lt;td align="center"&gt;12&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt; &lt;td align="left"&gt;Pipe&lt;/td&gt; &lt;td align="right"&gt;$1&lt;/td&gt; &lt;td align="center"&gt;234&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt; 要注意第二行的冒号决定了居左居右还是居中，如果你不加冒号，默认是居左的。 另外可以把第一行去掉，做成没有表头的表格，但第二行始终是要有的。 内联 HTMLmarkdown 的语法简洁，但有其局限性，所以特意保留了内联html这种方式。任何html标签及其内容，都会原样输出到结果中。也就是说，标签中的星号等作为markdown结构的符号，以及构成html标签和实体的符号，都不会做任何转义。 vscode markdown 扩展Markdown All in OneMarkdown Shortcuts]]></content>
      <categories>
        <category>before-development</category>
      </categories>
      <tags>
        <tag>markdown</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[my blog test]]></title>
    <url>%2Fmy-blog-test.html</url>
    <content type="text"><![CDATA[Anima Anima allows you to query database like SQL and Stream.a simple DSL syntax, supports multiple databases, integrates well with Java8,supports multiple relational mappings, and is a database manipulation tool. Document Feature Simple DSL H2、MySQL、SQLite、PostgreSQL、Oracle、SqlServer Paging support Flexible configuration Connection pool support Support LocalDate、LocalDateTime Support lambda expression Relationship (hasOne、hasMany、belongsTo) SQL performance statistics Based Java8 UsageLatest snapshot version If you want to prioritize new features or some BUG fixes you can use it, you need to specify the snapshot repository in pom.xml 12345678910111213141516&lt;repository&gt; &lt;id&gt;snapshots-repo&lt;/id&gt; &lt;url&gt;https://oss.sonatype.org/content/repositories/snapshots&lt;/url&gt; &lt;releases&gt; &lt;enabled&gt;false&lt;/enabled&gt; &lt;/releases&gt; &lt;snapshots&gt; &lt;enabled&gt;true&lt;/enabled&gt; &lt;/snapshots&gt;&lt;/repository&gt;&lt;dependency&gt; &lt;groupId&gt;io.github.biezhi&lt;/groupId&gt; &lt;artifactId&gt;anima&lt;/artifactId&gt; &lt;version&gt;0.2.4-SNAPSHOT&lt;/version&gt;&lt;/dependency&gt; Here’s the RELEASE version. As Gradle 1compile 'io.github.biezhi:anima:0.2.3' As Maven 12345&lt;dependency&gt; &lt;groupId&gt;io.github.biezhi&lt;/groupId&gt; &lt;artifactId&gt;anima&lt;/artifactId&gt; &lt;version&gt;0.2.2&lt;/version&gt;&lt;/dependency&gt; 📒 Although Anima can also be used by adding a jar package, we do not recommend doing this. ExamplesOpen Connection 12345678910111213141516// MySQLAnima.open("jdbc:mysql://127.0.0.1:3306/demo", "root", "123456");// SQLiteAnima.open("jdbc:sqlite:./demo.db");// H2Anima.open("jdbc:h2:file:~/demo;FILE_LOCK=FS;PAGE_SIZE=1024;CACHE_SIZE=8192", "sa", "");// DataSourceDruidDataSource dataSource = new DruidDataSource();dataSource.setDriverClassName("com.mysql.jdbc.Driver");dataSource.setUrl(blade.environment().getOrNull("jdbc.url"));dataSource.setUsername(blade.environment().getOrNull("jdbc.username"));dataSource.setPassword(blade.environment().getOrNull("jdbc.password"));Anima.open(dataSource); 📕 This operation only needs one time 123456789101112131415public class User extends Model &#123; private Integer id; private String userName; private Integer age; public User() &#123; &#125; public User(String userName, Integer age) &#123; this.userName = userName; this.age = age; &#125; &#125; Table Structure 12345CREATE TABLE `users` ( `id` IDENTITY PRIMARY KEY, `user_name` varchar(50) NOT NULL, `age` int(11)) Query123456789101112131415161718192021long count = select().from(User.class).count();// SELECT COUNT(*) FROM userslong count = select().from(User.class).where("age &gt; ?", 15).isNotNull("user_name").count();// SELECT COUNT(*) FROM users WHERE age &gt; ? AND user_name IS NOT NULLUser user = select().from(User.class).byId(2);// SELECT * FROM users WHERE id = ?List&lt;User&gt; users = select().from(User.class).byIds(1, 2, 3);// SELECT * FROM users WHERE id IN (?, ?, ?)String name = select().bySQL(String.class, "select user_name from users limit 1").one();List&lt;String&gt; names = select().bySQL(String.class, "select user_name from users limit ?", 3);List&lt;User&gt; users = select().from(User.class).all();// SELECT * FROM usersList&lt;User&gt; users = select().from(User.class).like("user_name", "%o%").all();// SELECT * FROM users WHERE user_name LIKE ? Limit 12List&lt;User&gt; users = select().from(User.class).order("id desc").limit(5);// SELECT * FROM users ORDER BY id desc Paging 12Page&lt;User&gt; userPage = select().from(User.class).order("id desc").page(1, 3);// SELECT * FROM users ORDER BY id desc LIMIT ?, ? Map 1select().from(User.class).map(User::getUserName).limit(3).collect(Collectors.toList()); Filter 1select().from(User.class).filter(u -&gt; u.getAge() &gt; 10).collect(Collectors.toList()); Lambda 12User user = select().from(User.class).where(User::getUserName).eq("jack").one();// SELECT * FROM users WHERE user_name = ? 12345List&lt;User&gt; user = select().from(User.class) .where(User::getUserName).notNull() .and(User::getAge).gt(10) .all();// SELECT * FROM users WHERE user_name IS NOT NULL AND age &gt; ? 12select().from(User.class).order(User::getId, OrderBy.DESC).order(User::getAge, OrderBy.ASC).all();// SELECT * FROM users ORDER BY id DESC, age ASC Join 1234567891011121314151617181920@Table(name = "order_info")@Datapublic class OrderInfo extends Model &#123; private Long id; private Integer uid; @Column(name = "productname") private String productName; private LocalDateTime createTime; @Ignore private User user; @Ignore private Address address;&#125; 1234567891011121314151617181920212223242526272829// HasOneOrderInfo orderInfo = select().from(OrderInfo.class) .join( Joins.with(Address.class).as(OrderInfo::getAddress) .on(OrderInfo::getId, Address::getOrderId) ).byId(3);orderInfo = select().from(OrderInfo.class) .join( Joins.with(Address.class).as(OrderInfo::getAddress) .on(OrderInfo::getId, Address::getOrderId) ) .join( Joins.with(User.class).as(OrderInfo::getUser) .on(OrderInfo::getUid, User::getId) ).byId(3);// ManyToOneorderInfo = select().from(OrderInfo.class) .join( Joins.with(User.class).as(OrderInfo::getUser) .on(OrderInfo::getUid, User::getId) ).byId(3);// OneToManyUserDto userDto = select().from(UserDto.class).join( Joins.with(OrderInfo.class).as(UserDto::getOrders) .on(UserDto::getId, OrderInfo::getUid) ).byId(1); Insert12Integer id = new User("biezhi", 100).save().asInt();// INSERT INTO users(id,user_name,age) VALUES (?,?,?) or 1Anima.save(new User("jack", 100)); Batch Save 12345List&lt;User&gt; users = new ArrayList&lt;&gt;();users.add(new User("user1", 10));users.add(new User("user2", 11));users.add(new User("user3", 12));Anima.saveBatch(users); 📘 This operation will begin a transaction and rollback when there is a transaction that is unsuccessful. Update12int result = update().from(User.class).set("user_name", newName).where("id", 1).execute();// UPDATE users SET username = ? WHERE id = ? or 12int result = update().from(User.class).set("user_name", newName).where("id", 1).execute();// UPDATE users SET user_name = ? WHERE id = ? or 12345User user = new User();user.setId(1);user.setUserName("jack");user.update();// UPDATE users SET user_name = ? WHERE id = ? 1update().from(User.class).set(User::getUserName, "base64").updateById(2); 1update().from(User.class).set(User::getUserName, "base64").where(User::getId).eq(2).execute(); Delete12int result = delete().from(User.class).where("id", 1).execute();// DELETE FROM users WHERE id = ? or 12345User user = new User();user.setAge(15);user.setUserName("jack");user.delete();// DELETE FROM users WHERE user_name = ? and age = ? 123delete().from(User.class).where(User::getId).deleteById(3);delete().from(User.class).where(User::getId).eq(1).execute();delete().from(User.class).where(User::getAge).lte(20).execute(); Transaction1234Anima.atomic(() -&gt; &#123; int a = 1 / 0; new User("apple", 666).save();&#125;).catchException(e -&gt; Assert.assertEquals(ArithmeticException.class, e.getClass())); 📗 Anima uses the atomic method to complete a transaction. normally, the code will not throw an exception.when a RuntimeException is caught, the transaction will be rollback. Test CodeSee here LicenseApache2]]></content>
      <categories>
        <category>test</category>
        <category>tools</category>
      </categories>
      <tags>
        <tag>test</tag>
        <tag>markdown</tag>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[my first blog article]]></title>
    <url>%2Fmy-first-blog-article.html</url>
    <content type="text"><![CDATA[一级标题二级标题三级标题无序列表 我的技术小黑屋 不会写代码的菜鸟 我要返回火星了 有序列表 我们都是地球人 为啥你就不会 markdown? 看完还不会就要被安排 链接的写法我的技术小屋 带 Title我的技术小屋 图片 带 Title 引用方式  世界依旧很大,大到只能胡说。  面朝大海，春暖花开 从明天起，做一个幸福的人喂马、劈柴，周游世界从明天起，关心粮食和蔬菜我有一所房子，面朝大海，春暖花开从明天起，和每一个亲人通信告诉他们我的幸福那幸福的闪电告诉我的我将告诉每一个人给每一条河每一座山取一个温暖的名字陌生人，我也为你祝福愿你有一个灿烂的前程愿你有情人终成眷属愿你在尘世获得幸福我只愿面朝大海，春暖花开 粗体 粗体 看，我斜了没 真的很斜 粗体＋斜体 此处的故事只能用泪水掩盖 群里单身女生名单 姓名 年龄 三围 罗欲凤 18 18, 27, 30 秋刀鱼 26 28, 25, 33 窝不行 22 23, 28, 35 单行代码引用 123456789package mainimport "fmt"func main()&#123; fmt.Println("我的技术小屋");&#125; 分割线]]></content>
      <categories>
        <category>test</category>
        <category>tools</category>
      </categories>
      <tags>
        <tag>test</tag>
        <tag>markdown</tag>
      </tags>
  </entry>
</search>
