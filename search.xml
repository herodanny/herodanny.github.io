<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[python全栈-magedu-2018-笔记20]]></title>
    <url>%2Fpython-magedu-2018-notes20.html</url>
    <content type="text"><![CDATA[第十章 - Python高阶函数、柯里化高阶函数 First Class Object 函数在Python中是一等公民 函数也是对象，可调用的对象 函数可以作为普通变量、参数、返回值等等 高阶函数 数学概念 y=g(f(x)) 在数学和计算机科学中，高阶函数应当是至少满足下面一个条件的函数 接受一个或多个函数作为参数 输出一个函数 高阶函数 计数器def counter(base):&emsp; def inc(step=1):&emsp;&emsp; base += step&emsp;&emsp; return base&emsp; return inc 分析： 函数couter是不是一个高阶函数？# 只要满足上面一个条件，就是高阶函数。 上面代码有没有什么问题？怎样改进 # base是counter的本地变量，base在inc新的变量赋值，所以会报错 如何调用完成计数功能 f1 = counter(5)和f2=counter(5)，请问f1和f2相等吗？可以把内层函数inc看成counter的本地变量，压栈时都会重新生成 自定义sort函数 排序问题 仿照内建函数sorted，请自行实现一个sort函数（不使用内建函数），能够为列表元素排序 思路 内建函数sorted函数是返回一个新的列表，可以设置升序或降序，可以设置一个排序的函数。自定义的sort函数也要实现这个功能 新建一个列表，遍历原列表，和新列表的值依次比较决定如何插入到新列表中 思考 sorted函数的实现原理，扩展到map、filter函数的实现原理 自定义sort函数 sort函数实现。下面实现的什么排序？还能怎么改变def sort(iterable):&emsp; ret = [ ]&emsp; for x in iterable:&emsp;&emsp; for i, y in enumerate(ret):&emsp;&emsp;&emsp; if x &gt; y: # 找到大的就地插入。如果换成x &lt; y呢，函数什么意思呢？&emsp;&emsp;&emsp;&emsp; ret.insert(i,x) # 降序&emsp;&emsp;&emsp;&emsp; break&emsp;&emsp;&emsp; else: # 不大于，说明是最小的，尾部追加&emsp;&emsp;&emsp;&emsp; ret.append(x)&emsp; return retprint(sort([1,2,5,4,2,3,5,6])) 自定义sort函数 sort函数实现。用一个参数控制顺序def sort(iterable, reverse=False):&emsp; ret = []&emsp; for x in iterable:&emsp;&emsp; for i, y in enumerate(ret):&emsp;&emsp;&emsp; flag = x&gt;y if reverse else x&lt;y&emsp;&emsp;&emsp; if flag: # 是否能进一步改进&emsp;&emsp;&emsp;&emsp; ret.insert(i,x)&emsp;&emsp;&emsp;&emsp; break&emsp;&emsp;&emsp; else:&emsp;&emsp;&emsp;&emsp; ret.append(x)&emsp; return retprint(sort([1,2,5,4,2,3,5,6])) x&gt;y 这种比较逻辑比较死，可以改成灵活的函数。def sort(iterable, reverse=False):&emsp; def comp(a, b):&emsp;&emsp; return a&gt;b if reverse else a&lt;b&emsp; ret = []&emsp; for x in iterable:&emsp;&emsp; for i, y in enumerate(ret):&emsp;&emsp;&emsp; if comp(x, y):&emsp;&emsp;&emsp;&emsp; ret.insert(i,x)&emsp;&emsp;&emsp;&emsp; break&emsp;&emsp;&emsp; else:&emsp;&emsp;&emsp;&emsp; ret.append(x)&emsp; return retprint(sort([1,2,5,4,2,3,5,6])) comp 是内部函数，别人用不了，要放到外面def comp(a, b, reverse):&emsp; return a&gt;b if reverse else a&lt;b &emsp;&emsp; def sort(iterable, reverse=False):&emsp;&emsp;&emsp; ret = []&emsp;&emsp;&emsp; for x in iterable:&emsp;&emsp;&emsp;&emsp; for i, y in enumerate(ret):&emsp;&emsp;&emsp;&emsp;&emsp; if comp(x, y, reverse):&emsp;&emsp;&emsp;&emsp;&emsp;&emsp; ret.insert(i,x)&emsp;&emsp;&emsp;&emsp;&emsp;&emsp; break&emsp;&emsp;&emsp;&emsp;&emsp; else:&emsp;&emsp;&emsp;&emsp;&emsp;&emsp; ret.append(x)&emsp;&emsp;&emsp; return ret&emsp;&emsp; print(sort([1,2,5,4,2,3,5,6])) 把sort写成高阶函数形式def comp(a, b):&emsp; return a &lt; b &emsp;&emsp; def sort(iterable, key=comp, reverse=False):&emsp;&emsp;&emsp; ret = []&emsp;&emsp;&emsp; for x in iterable:&emsp;&emsp;&emsp;&emsp; for i, y in enumerate(ret):&emsp;&emsp;&emsp;&emsp;&emsp; flag = key(x, y) if reverse else key(y, x)&emsp;&emsp;&emsp;&emsp;&emsp; if flag:&emsp;&emsp;&emsp;&emsp;&emsp;&emsp; ret.insert(i,x)&emsp;&emsp;&emsp;&emsp;&emsp;&emsp; break&emsp;&emsp;&emsp;&emsp;&emsp; else:&emsp;&emsp;&emsp;&emsp;&emsp;&emsp; ret.append(x)&emsp;&emsp;&emsp; return ret&emsp;&emsp; print(sort([1,2,5,4,2,3,5,6])) comp是一行函数，可以写成 lambda 表达式 自定义sort函数 sort函数实现。下面实现的什么排序？还能怎么改变def sort(iterable, key=lambda a,b : a&gt;b):&emsp; ret = [ ]&emsp; for x in iterable:&emsp;&emsp; for i, y in enumerate(ret):&emsp;&emsp;&emsp;&emsp; if key(x, y): # 函数的返回值是bool&emsp;&emsp;&emsp;&emsp;&emsp; ret.insert(i,x)&emsp;&emsp;&emsp;&emsp;&emsp; break&emsp;&emsp;&emsp;&emsp; else:&emsp;&emsp;&emsp;&emsp;&emsp; ret.append(x)&emsp; return retprint(sort([1,2,5,4,2,3,5,6]), lambda a,b:a&gt;b) # 升序还是降序？如何反序？ 自定义sort函数 sort函数实现def sort(iterable, reverse=False, key=lambda x,y:x&lt;y):&emsp; ret = []&emsp; for x in iterable:&emsp;&emsp; for i,y in enumerate(ret):&emsp;&emsp;&emsp; flag = key(x,y) if not reverse else not key(x,y)&emsp;&emsp;&emsp; if flag:&emsp;&emsp;&emsp;&emsp; ret.insert(i, x)&emsp;&emsp;&emsp;&emsp; break&emsp;&emsp; else:&emsp;&emsp;&emsp; ret.append(x)&emsp; return retprint(sort([1,2,5,4,2,3,5,6])) 内建函数-高阶函数 sorted(iterable[, key][, reverse]) 排序 filter(function, iterable) –&gt; filter object 过滤数据 map(func, *iterables) –&gt; map object 映射 内建函数-高阶函数 sorted(iterable[, key][, reverse]) 排序 返回一个新的列表，对一个可迭代对象的所有元素排序，排序规则为key定义的函数，reverse表示是否排序翻转 sorted(lst,key=lambda x:6-x) # 返回新列表key只能对一个元素操作，与我们前面自己写的不同，前面的key是x,y对两个元素操作。key只是对元素生成一个新的临时元素用来比较，并不会修改原来的元素。这里6-x只是计算出一个临时值。用来比较的。比较完，添加的是原本的值到新序列中。举例list是[1,2,3,4,5,6]，那么比较的结果就是[6,5,4,3,2,1] list.sort(key=lambda x: 6-x) # 就地修改 内建函数-高阶函数 filter(function, iterable) 过滤可迭代对象的元素，返回一个迭代器（迭代器是惰性求值） function一个具有一个参数的函数，返回bool 例如，过滤出数列中能被3整除的数字list(filter(lambda x: x%3==0, [1,9,55,150,-3,78,28,123])) map(function, *iterables) –&gt; map object 对多个可迭代对象的元素按照指定的函数进行映射，返回一个迭代器 list(map(lambda x:2*x+1, range(5))) dict(map(lambda x: (x%5,x) , range(500)))*iterables意思是收集n个可迭代对象，%5说明key不会超过5 柯里化 Currying 柯里化 指的是将原来接受两个参数的函数变成新的接受一个参数的函数的过程。新的函数返回一个以原有第二个参数为参数的函数 z = f(x, y) 转换成 z = f(x)(y)的形式 举例 将加法函数柯里化&emsp; def add(x, y):&emsp;&emsp; return x + y 转换如下&emsp; def add(x):&emsp;&emsp; def _add(y):&emsp;&emsp;&emsp; return x+y&emsp;&emsp; return _add&emsp; add(5)(6) 通过嵌套函数(返回值是函数)就可以把函数转换成柯里化函数]]></content>
      <categories>
        <category>python-magedu</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python全栈-magedu-2018-笔记19]]></title>
    <url>%2Fpython-magedu-2018-notes19.html</url>
    <content type="text"><![CDATA[第九章 - Python 生成器生成器*** 生成器generator 生成器指的是生成器对象，可以由生成器表达式得到，也可以使用yield关键字得到一个生成器函数，调用这个函数得到一个生成器对象 生成器函数 函数体中包含yield语句的函数，返回生成器对象 生成器对象，是一个可迭代对象，是一个迭代器 生成器对象，是延迟计算、惰性求值的 生成器 举例def inc():&emsp; for i in range(5):&emsp;&emsp; yield iprint(type(inc)) # print(type(inc())) # 生成器函数inc返回值是生成器 x = inc()print(type(x)) # print(next(x)) # 0for m in x:&emsp; print(m, ‘‘) # 输出：1 、2 、3 、4 *for m in x: # 生成器用完了，再迭代也不会报StopIteration，如果直接next(x)会&emsp; print(m, ‘**’) 举例y = (i for i in range(5)) # 生成器表达式等价于上面的生成器函数print(type(y))print(next(y))print(next(y)) 普通的函数调用fn()，函数会立即执行完毕，但是生成器函数可以使用next函数多次执行 生成器函数等价于生成器表达式，只不过生成器函数可以更加的复杂 生成器 举例 def gen():&emsp; print(‘line 1’)&emsp; yield 1&emsp; print(‘line 2’)&emsp; yield 2&emsp; print(‘line 3’)&emsp; return 3 &emsp; next(gen()) # line 1，生成器函数gen()返回值是生成器&emsp; next(gen()) # line 1，gen()又新创建一个生成器&emsp; g = gen()&emsp; print(next(g)) # line 1&emsp; print(next(g)) # line 2&emsp; print(next(g)) # StopIteration，gen中最后是return所以报错&emsp; print(next(g, ‘End’)) # 没有元素给个缺省值 在生成器函数中，使用多个 yield 语句，执行一次后会暂停执行，把yield表达式的值返回 再次执行会执行下一个yield语句 return语句依然可以终止函数运行，但return语句的返回值不能被获取到 return会导致无法继续获取下一个值，抛出StopIteration异常 如果函数没有显示return语句，如果生成器函数执行到结尾，一样会抛出StopIteration异常 生成器 生成器函数 包含yield语句的生成器函数生成 生成器对象 的时候，生成器函数的函数体不会立即执行。 next(generator)会从函数的当前位置向后执行之后碰到的第一个yield语句，会弹出值，并暂停函数执行 再次调用next 函数，和上一条一样的处理过程 没有多余的yield语句能被执行，继续调用next函数，会抛出StopIterator异常 生成器 无限循环 def counter():&emsp; i = 0&emsp; while True:&emsp;&emsp; i += 1&emsp;&emsp; yield i def inc(c):&emsp; return next(c)c = counter()print(inc(c))print(inc(c)) def counter():&emsp; i = 0&emsp; while True:&emsp;&emsp; i += 1&emsp;&emsp; yield i def inc():&emsp; c = counter()&emsp; return next(c) print(inc()) # 是什么print(inc()) # 是什么print(inc()) # 是什么 生成器应用 计数器 def inc():&emsp; def counter():&emsp;&emsp; i = 0&emsp;&emsp; while True:&emsp;&emsp;&emsp; i += 1&emsp;&emsp;&emsp; yield i&emsp;&emsp; c = counter() # c是生成器&emsp;&emsp; return lambda : next(c) foo = inc()print(foo())print(foo()) lambda 表达式是匿名函数 return 返回的是一个匿名函数。且c是外层自由变量，有闭包 等价于下面的代码 简单函数都可以用lambda函数代替，慢慢练。 生成器应用 处理递归问题 def fib():&emsp; x = 0&emsp; y = 1&emsp; while True:&emsp;&emsp; yield y&emsp;&emsp; x, y = y, x+y foo = fib()for _ in range(5):&emsp; print(next(foo)) for _ in range(100):&emsp; next(foo)print(next(foo)) 等价于下面的代码 生成器应用 协程 coroutine 生成器的高级用法 比进程、线程轻量级 是在用户控件调度函数的一种实现 Python3 asyncio 就是协程实现，已经加入到标准库 Python3.5 使用 async、await 关键字直接原生支持协程 协程调度器实现思路 有2个生成器A、B next(A)后，A执行到了yield语句暂停，然后去执行next(B)，B执行到yield语句也暂停，然后再次调用next(A)，再调用next(B)在，周而复始，就实现了调度的效果 可以引入调度的策略来实现切换的方式 协程是一种非抢占式调度 yield from yield from yield from 是 Python3.3出现的新的语法 yield from iterable 是 for item in iterable: yield item 形式的语法糖 从可迭代对象中一个个拿元素def counter(n): # 生成器&emsp;&emsp; for x in range(n):&emsp;&emsp;&emsp; yield x &emsp;&emsp;&emsp;&emsp; def inc(n):&emsp;&emsp;&emsp;&emsp;&emsp; yield from counter(n)&emsp;&emsp;&emsp;&emsp;&emsp; 等价为：&emsp;&emsp;&emsp;&emsp;&emsp; for x in counter(n):&emsp;&emsp;&emsp;&emsp;&emsp;&emsp; yield x &emsp;&emsp;&emsp;&emsp; foo = inc(10)&emsp;&emsp;&emsp;&emsp; print(next(foo))&emsp;&emsp;&emsp;&emsp; print(next(foo))]]></content>
      <categories>
        <category>python-magedu</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python全栈-magedu-2018-笔记18]]></title>
    <url>%2Fpython-magedu-2018-notes18.html</url>
    <content type="text"><![CDATA[第八章 - Python 匿名函数匿名函数 匿名函数，即没有名字的函数 没有名字如何定义 没有名字如何调用 如果能调用，如何使用 匿名函数 Python 借助 Lambda 表达式构建匿名函数 格式 lambda 参数列表 : 表达式lambda x : x 2(lambda x : x 2)(4) # 调用foo = lambda x, y : (x + y) 2 # 不推荐这么用，因为用lambda就是为了匿名使用foo(2, 1)def foo(x,y): # 建议使用普通函数&emsp; return (x + y) 2foo(2, 1) 匿名函数 使用 lambda 关键字来定义匿名函数 参数列表不需要小括号 冒号是用来分割参数列表和表达式的 不需要使用 return，表达式的值，就是匿名函数返回值 lambda 表达式（匿名函数）只能写在一行上，被称为单行函数 用途 在高阶函数传参时，使用 lambda 表达式，往往能简化代码 匿名函数 print((lambda :0)()) print((lambda x, y=3: x + y)(5)) print((lambda x, y=3: x + y)(5, 6)) print((lambda x, *, y=30: x + y)(5)) print((lambda x, *, y=30: x + y)(5, y=10)) print((lambda *args: (x for x in args))(*range(5))) *args是可变位置参数组成一个元组 表达式是生成器表达式是惰性求值的 最后是实参解构 print((lambda *args: [x+1 for x in args])(*range(5))) 表达式是列表解析式 print((lambda *args: {x+2 for x in args})(*range(5))) 集合解析式 [x for x in (lambda *args: map(lambda x: x+1, args))(*range(5))] # 高阶函数 是一个大的列表解析式 [x for x in (lambda *args: map(lambda x: (x+1,args), args))(*range(5))] # map中的lambda中的表达式是在凑个元组]]></content>
      <categories>
        <category>python-magedu</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python全栈-magedu-2018-笔记17]]></title>
    <url>%2Fpython-magedu-2018-notes17.html</url>
    <content type="text"><![CDATA[第七章 - Python 递归函数函数执行流程http://pythontutor.com/visualize.html#mode=edit def foo1(b, b1=3):&emsp; print(“foo1 called”, b, b1) def foo2(c):&emsp; foo3(c)&emsp; print(“foo2 called”, c) def foo3(d):&emsp; print(“foo3 called”, d) def main():&emsp; print(“main called”)&emsp; foo1(100, 101)&emsp; foo2(200)&emsp; print(“main ending”) main() 全局帧中生成foo1、foo2、foo3、main 函数对象 main函数调用 main中查找内建函数print压栈，将常量字符串压栈，调用函数(指调用print函数)，弹出栈顶(调用完将字符串弹出) main中全局查找函数foo1压栈，将常量100、101压栈，调用函数foo1，创建栈帧。print函数压栈，字符串和变量b、b1压栈，调用函数，弹出栈顶，返回值。 main中全局查找foo2函数压栈，将常量200压栈，调用foo2，创建栈帧。foo3函数压栈，变量c引用压栈，调用foo3，创建栈帧。foo3完成print函数调用后返回。foo2恢复调用，执行print后，返回值。main中foo2调用结束弹出栈顶，继续执行print函数调用，弹出栈顶。main函数返回。 调用函数，把调用函数压栈，参数压栈，创建栈帧，执行内部的东西，执行完弹出。恢复到前一个函数。 调用一个函数要保护当前的内容，把当前的执行到哪的环境信息要压入栈中，然后才是把要调用的函数压栈，参数压栈，创建栈帧，在里面执行它的语句。 函数执行流程http://pythontutor.com/visualize.html#mode=edit 递归 Recursion 函数直接或者间接调用自身就是递归 递归需要有边界条件、递归前进段、递归返回段 递归一定要有边界条件 当边界条件不满足的时候，递归前进 当边界条件满足的时候，递归返回 递归 Recursion 斐波那契数列 Fibonacci number：1，1，2，3，5，8，13，21，34，55，89，144，。。。 如果有F(n) 为该数列的第n项，n是正整数，那么这句话可以写成如下形式：F(n)=F(n-1)+F(n-2) F(0)=0, F(1)=1, F(n)=F(n-1)+F(n-2)pre = 0cur = 1 # F(1)为1print(pre, cur, end=’’)n = 4&emsp; # loopfor i in range(n-1):&emsp; pre, cur = cur, pre+cur&emsp; print(cur, end=’’) 递归 Recursion F(0)=0, F(1)=1, F(n)=F(n-1)+F(n-2) def fib(n):&emsp; return 1 if n &lt; 2 else fib(n-1) + fib(n-2) for i in range(5):&emsp; print(fib(i), end=’ ‘) 解析：fib(3) + fib(2)fib(3) 调用 fib(3)、fib(2)、fib(1)fib(2) 调用 fib(2)、fib(1)fib(1) 是边界 递归 Recursion 递归要求 递归一定要有退出条件，递归调用一定要执行到这个退出条件。没有退出条件的递归调用，就是无限调用 递归调用的深度不宜过深 Python 对递归调用的深度做了限制，以保护解释器 超过递归深度限制，抛出 RecursionError：maxinum recursion depth exceeded 超出最大深度 sys.getrecursionlimit() # 1000 递归的性能 for 循环import datetimestart = datetime.datetime.now()pre = 0cur = 1print(pre, cur, end=’ ‘)n = 35for i in range(n-1):&emsp; pre, cur = cur, pre + cur&emsp; print(cur, end=’ ‘)delta = (datetime.datetime.now() - start).total_seconds()print(delta) 递归import datetimen = 35start = datetime.datetime.now()def fib(n):&emsp; return 1 if n &lt; 2 else fib(n-1) + fib(n-2)for i in range(n):&emsp; print(fib(i), end=’ ‘)delta = (datetime.datetime.now() - start).total_seconds()print(delta) 递归的性能 循环稍微复杂一些，但是只要不是死循环，可以多次迭代直至算出结果 fib函数代码极简易懂，但是只能获取到最外层的函数调用，内部递归结果都是中间结果。而且给定一个n都要进行近2n次递归，深度越深，效率越低。为了获取斐波那契数列需要外面在套一个n次的循环，效率就更低了 递归还有深度限制，如果递归复杂，函数反复压栈，栈内存很快就溢出了 思考：这个极简的递归代码能否提高性能呢？ 递归的性能 斐波那契数列的改进pre = 0cur = 1 # No1print(pre, cur, end=’ ‘)def fib(n, pre=0, cur=1): # recursion&emsp; pre, cur = cur, pre + cur&emsp; print(cur, end=’ ‘)&emsp; if n == 2:&emsp;&emsp; return&emsp; fib(n-1, pre, cur) &emsp; fib(n) 改进 上边的fib函数和循环的思想类似 参数n是边界条件，用n来计数 上一次的计算结果直接作为函数的实参 效率很高 和循环比较，性能相近。所以并不是说递归一定效率低下。但是递归有深度限制。 对比一下三个fib函数的性能 递归 间接递归 &emsp; def foo1():&emsp;&emsp; foo2() &emsp; def foo2():&emsp;&emsp; foo1() &emsp; foo1() 间接递归，是通过别的函数调用了函数自身。但是，如果构成了循环递归调用是非常危险的，但是往往这种情况在代码复杂的情况下，还是可能发生这种调用。要用代码的规范来避免这种递归调用的发生。 递归总结 递归是一种很自然的表达，符合逻辑思维 递归相对运行效率低，每一次调用函数都要开辟栈帧 递归有深度限制，如果递归层次太深，函数反复压栈，栈内存很快就溢出了 如果是有限次数的递归，可以使用递归调用，或者使用循环代替，循环代码稍微复杂一些，但是只要不是死循环，可以多次迭代直至算出结果 绝大多数递归，都可以使用循环实现 即使递归代码很简洁，但是能不用则不用递归 递归练习 求n的阶乘 将一个数逆序放入列表中，例如1234 =&gt; [4,3,2,1] 解决猴子吃桃问题 猴子第一天摘下若干桃子，当即吃了一半，还不过瘾，又多吃了一个。第二天早上又将剩下的桃子吃掉一半，又多吃了一个。以后每天早上都吃了前一天剩下的一半零一个。到第10天早上想吃时，只剩下一个桃子了。求第一天共摘多少个桃子。]]></content>
      <categories>
        <category>python-magedu</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python全栈-magedu-2018-笔记16]]></title>
    <url>%2Fpython-magedu-2018-notes16.html</url>
    <content type="text"><![CDATA[第六章 - Python函数返回值、作用域函数的返回值 举例def showplus(x):&emsp; print(x)&emsp; return x + 1 &emsp;&emsp; showplus(5) 举例def showplus(x):&emsp; print(x)&emsp; return x + 1&emsp; print(x+1) # 会执行吗？ &emsp;&emsp; showplus(5) 函数的返回值 多条return语句def guess(x):&emsp; if x &gt; 3:&emsp;&emsp; return “&gt; 3”&emsp; else:&emsp;&emsp; return “&lt;= 3” &emsp;&emsp; print(guess(10)) return可以执行多次吗？ 多条return语句def showplus(x):&emsp; print(x)&emsp; return x + 1&emsp; return x + 2 &emsp;&emsp; showplus(5) 函数返回值 举例def fn(x):&emsp; for i in range(x):&emsp;&emsp; if i &gt; 3:&emsp;&emsp;&emsp; return i&emsp;&emsp; else:&emsp;&emsp;&emsp; print(“{} is not greater than 3”.format(x)) &emsp; print(fn(5)) # 打印什么？&emsp; print(fn(3)) # 打印什么？ 函数的返回值 总结 Python函数使用return语句返回“返回值” 所有函数都有返回值，如果没有return语句，隐式调用return None return 语句并不一定是函数的语句块的最后一条语句 一个函数可以存在多个return语句，但是只有一条可以被执行。如果没有一条return语句被执行到，隐式调用return None 如果有必要，可以显示调用return None，可以简写为return 如果函数执行了return语句，函数就会返回，当前被执行的return语句之后的其它语句就不会被执行了 作用：结束函数调用、返回值 函数的返回值 返回多个值def showlist():&emsp; return [1, 3, 5]showlist函数是返回了多个值吗？def showlist():&emsp; return 1, 3, 5这次showlist函数是否返回了多个值呢？ 函数的返回值 返回多个值 函数不能同时返回多个值 return [1, 3, 5] 是指明返回一个列表，是一个列表对象 return 1, 3, 5 看似返回多个值，隐式的被python封装成了一个元组def showlist():&emsp; return 1, 3, 5x, y, z = showlist() # 使用解构提取更为方便 函数嵌套 函数嵌套 在一个函数中定义了另外一个函数def outer():&emsp; def inner():&emsp;&emsp; print(“inner”)&emsp; print(“outer”)&emsp; inner()outer()inner() 函数有可见范围，这就是作用域的概念 内部函数不能在外部直接使用，会抛NameError异常，因为它不可见 作用域*** 作用域 一个标识符的可见范围，这就是标识符的作用域。一般常说的是变量的作用域 举例，对比左右2个函数 &emsp; x = 5 &emsp; def foo():&emsp;&emsp; print(x) &emsp; foo() &emsp; x = 5 &emsp; def foo():&emsp;&emsp; x += 1&emsp;&emsp; print(x) &emsp; foo()&emsp; 这会报x在赋值之前就引用了的错误&emsp; UnboundLocalError: local variable ‘x’ referenced before assignment &emsp; x到底可见还是不可见？ 作用域*** 全局作用域 在整个程序运行环境中都可见 局部作用域 在函数、类等内部可见 局部变量使用范围不能超过其所在的局部作用域 &emsp; def fn1():&emsp;&emsp; x = 1 # 局部作用域，在fn1内 &emsp; def fn2():&emsp;&emsp; print(x) # x可见吗 &emsp; print(x) # x可见吗 作用域*** 嵌套结构 def outer1(): #&emsp; o = 65&emsp; def inner():&emsp;&emsp; print(“inner {}”.format(o))&emsp;&emsp; print(chr(o))&emsp; print(“outer {}”.format(o))&emsp; inner() outer1() 嵌套结构 def outer2(): #&emsp; o = 65&emsp; def inner():&emsp;&emsp; o = 97&emsp;&emsp; print(“inner {}”.format(o))&emsp;&emsp; print(chr(o))&emsp; print(“outer {}”.format(o))&emsp; inner() outer2() 代码中变量o的差别 作用域*** 从嵌套结构例子看出 外层变量作用域在内层作用域可见 内层作用域inner中，如果定义了o=97，相当于当前作用域中重新定义了一个新的变量o，但是这个o并没有覆盖外层作用域outer中的o 再看下面代码x = 5def foo():&emsp; y = x + 1 # 报错吗&emsp; x += 1 # 报错，报什么错？为什么？换成x=1还有错吗？&emsp; print(x) # 为什么它不报错foo()为什么会报错？就是因为赋值即定义。x在赋值之前就用，会报错。 作用域*** 代码x = 5def foo():&emsp; x += 1 x += 1 其实是 x = x + 1 相当于在foo内部定义一个局部变量x，那么foo内部所有x都是这个局部变量x了 但是这个x还没有完成赋值，就被右边拿来做加1操作了 如何解决这个问题 作用域*** 全局变量globalx = 5def foo():&emsp; global x&emsp; x += 1 使用global关键字的变量，将foo内的x声明为使用外部的全局作用域中定义的x 全局作用域中必须有x的定义 如果全局作用域中没有x定义会怎样？ 作用域*** 全局变量global&emsp; # x = 5&emsp; def foo():&emsp;&emsp; global x&emsp;&emsp; x = 10&emsp;&emsp; x += 1 # 报错吗？&emsp;&emsp; print(x) # 打印什么？&emsp; print(x) #打印什么？做这些实验建议不要使用ipython、jupyter，因为它会上下文中有x定义，可能测试不出效果，也可以先用del x。 使用global关键字的变量，将foo内的x声明为使用外部的全局作用域中定义的x 但是，x = 10 赋值即定义，在内部作用域为一个外部作用域的变量x赋值，不是在内部作用域定义一个新变量，所以x+=1不会报错。注意，这里x的作用域还是全局的 作用域*** global总结 x+=1这种是特殊形式产生的错误的原因？先引用后赋值，而python动态语言是赋值才算定义，才能被引用。解决办法，在这条语句前增加x=0之类的赋值语句，或者使用global 告诉内部作用域，去全局作用域查找变量定义 内部作用域使用x = 5之类的赋值语句会重新定义局部作用域使用的变量x，但是，一旦这个作用域中使用global声明x为全局的，那么x=5相当于在为全局作用域的变量x赋值 global使用原则 外部作用域变量会内部作用域可见，但也不要在这个内部的局部作用域中直接使用，因为函数的目的就是为了封装，尽量与外界隔离 如果函数需要使用外部全局变量，请使用函数的形参传参解决 一句话：不用global。学习它就是为了深入理解变量作用域 闭包* 自由变量：未在本地作用域中定义的变量。例如定义在内层函数外的外层函数的作用域中的变量 闭包：就是一个概念，出现在嵌套函数中，指的是内层函数引用到了外层函数的自由变量，就形成了闭包。很多语言都有这个概念，最熟悉就是JavaScript。（注意：是指引用了外层函数中的，如果引用的变量是在全局作用域内，或是有global 修饰的变量，就不是闭包了。 ） 先看下边一段代码 第4行会报错吗？为什么 第8行打印什么结果？ 第10行打印什么结果？ c是列表的引用, return inc 是返回一个标识符是函数对象，是callable的。foo = counter() 增加了counter函数对象的引用计数，所以它的作用域空间还在。 闭包* 代码解析 第4行会报错吗？为什么 不会报错，c已经在counter函数中定义过了。而且inc中的使用方式是为c的元素修改值，而不是重新定义变量。如果c不是引用列表，是c=0,c+=1这种，还是会报 UnboundLocalError: local variable ‘c’ referenced before assignment 第8行打印什么结果？ 打印 1 2 第10行打印什么结果？ 打印 3 第9行的c和counter中的c不一样，而inc引用的是自由变量真是counter的变量c 这是Python2中实现闭包的方式，Python3还可以使用nonlocal关键字 为什么要用闭包？就是内层函数要使用外层的自由变量。 闭包* 下面这段代码会报错吗？为什么？ 使用global能否解决？ 使用global可以解决，但是这使用的是全局变量，而不是闭包def counter():&emsp; count = 0&emsp; def inc():&emsp;&emsp; global c # 本地和最外层没有定义c还是会报错&emsp;&emsp; count +=1&emsp;&emsp; return count&emsp; return incfoo = counter()foo()foo()global的作用域范围，只在声明的inc()函数当前作用域内 和 全局作用域有效。 如果要对普通变量的闭包，Python3中可以使用nonlocal nonlocal关键字 使用了nonlocal关键字，将变量标记为不在本地作用域定义，而在上级的某一级局部作用域中定义，但不能是全局作用域中定义 count 是外层函数的局部变量，被内部函数引用 内部函数使用nonlocal关键字声明count变量在上级作用域而非本地作用域中定义 上边代码可以正常使用，且形成闭包 下边代码不能正常运行，变量 a 不能在全局作用域中 默认值的作用域 默认值举例def foo(xyz=1):&emsp; print(xyz)foo() # 打印什么？foo() # 打印什么？print(xyz) # 打印什么？默认值是形参，它的作用域看成是函数局部作用域。 默认值举例def foo(xyz=[]):&emsp; xyz.append(1)&emsp; print(xyz)foo() # 打印什么？foo() # 打印什么？print(xyz) # 打印什么？不知是否对：变量名xyz在函数调用时压栈，函数结束时就出栈了。临时的本地变量xyz就消亡了。默认值的对象一直都在，因为 python 中一切皆对象。函数形参就是 默认值的作用域 默认值举例def foo(xyz=[]):&emsp; xyz.append(1)&emsp; print(xyz)foo() # [1]foo() # [1,1]print(xyz) # NameError ，当前作用域没有xyz变量 为什么第二次调用foo函数打印的是[1,1]？ 因为函数也是对象，python把函数的默认值放在了属性中，这个属性就伴随着这个函数对象的整个生命周期 查看foo.defaults属性 默认值的作用域 运行这个例子def foo(xyz=[], u=’abc’, z=123):&emsp; xyz.append(1)&emsp; return xyzprint(1, foo.__defaults__)print(foo(), id(foo))print(2, foo.__defaults__)print(foo(), id(foo))print(3, foo.__defaults__) 函数地址并没有变，就是说函数这个对象的没有变，调用它，它的属性defaults中使用元组保存默认值 xyz默认值是引用类型，引用类型的元素变动，并不是元组的变化 默认值的作用域 非引用类型例子def foo(w, u=’abc’, z=123):&emsp; u = ‘xyz’&emsp; z = 789&emsp; print(w, u, z)print(foo.__defaults__)foo(‘github’)print(foo.__defaults__) 属性__defaults__中使用元组保存所有位置参数默认值，它不会因为在函数体内使用了它而发生改变 默认值的作用域 举例def foo(w, u=’abc’, *, z=123, zz=[456]):&emsp; u = ‘xyz’&emsp; z = 789&emsp; zz.append(1)&emsp; print(w, u, z, zz)print(foo.__defaults__)foo(‘magedu’)print(foo.__kwdefaults__) 属性__defaults__中使用元组保存所有位置参数默认值 属性__kwdefaults__中使用字典保存所有keyword-only参数的默认值 默认值的作用域 使用可变类型作为默认值(如list)，就可能修改这个默认值 有时候这个特性是好的，有的时候这种特性是不好的，有副作用 如何做到按需改变呢？看下面的2种方法 默认值的作用域def foo(xyz=[], u=’abc’, z=123):&emsp; xyz = xyz[:] # 影子拷贝&emsp; xyz.append(1)&emsp; print(xyz)foo()print(1, foo.__defaults__)foo() # xyz还是浅拷贝新的listprint(2, foo.__defaults__)foo([10])print(3, foo.__defaults__)foo([10,5])print(4, foo.__defaults__) 1、函数体内，不改变默认值 xyz都是传入参数或者默认参数的副本，如果就想修改原参数，无能为力 默认值的作用域def foo(xyz=None, u=’abc’, z=123):&emsp; if xyz is None:&emsp;&emsp; xyz = []&emsp; xyz.append(1)&emsp; print(xyz)foo()print(1, foo.__defaults__)foo()print(2, foo.__defaults__)foo([10])print(3, foo.__defaults__)foo([10,5])print(4, foo.__defaults__) 2、使用不可变类型默认值 如果使用缺省值None就创建一个列表 如果传入一个列表，就修改这个列表 默认值的作用域 第一种方法 使用影子拷贝创建一个新的对象，永远不能改变传入的参数 第二种方法 通过值的判断就可以灵活的选择创建或者修改传入对象 这种方式灵活，应用广泛 很多函数的定义，都可以看到使用None这个不可变的值作为默认参数，可以说这是一种惯用法 变量名解析原则LEGB Local，本地作用域、局部作用域的local命名空间。函数调用时创建，调用结束消亡 Enclosing，Python2.2时引入了嵌套函数，实现了闭包，这个就是嵌套函数的外部函数的命名空间 Global，全局作用域，即一个模块的命名空间。模块被import时创建，解释器退出时消亡 Build-in，内置模块的命名空间，生命周期从python解释器启动时创建到解释器退出时消亡。例如 print(open)，print和open都是内置的变量 所以一个名词的查找顺序就是LEGB 函数的销毁 全局函数def foo(xyz=[], u=’abc’, z=123):&emsp; xyz.append(1)&emsp; return xyzprint(foo(), id(foo), foo.__defaults__)def foo(xyz=[], u=’abc’, z=123):&emsp; xyz.append(1)&emsp; return xyzprint(foo(), id(foo), foo.__defaults__)del fooprint(foo(), id(foo), foo.__defaults__) 函数的销毁 全局函数销毁 重新定义同名函数 del 语句删除函数对象 程序结束时 函数的销毁 局部函数def foo(xyz=[], u=’abc’, z=123):&emsp; xyz.append(1)&emsp; def inner(a=10):&emsp;&emsp; pass&emsp; print(inner)&emsp; def inner(a=100):&emsp;&emsp; print(xyz)&emsp; print(inner)&emsp; return innerbar = foo()print(id(foo),id(bar), foo.__defaults__, bar.__defaults__)del barprint(id(foo),id(bar), foo.__defaults__, bar.__defaults__) 函数的销毁 局部函数销毁 重新在上级作用域定义同名函数 del 语句删除函数名称，函数对象的引用计数减1 上级作用域销毁时]]></content>
      <categories>
        <category>python-magedu</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python全栈-magedu-2018-笔记15]]></title>
    <url>%2Fpython-magedu-2018-notes15.html</url>
    <content type="text"><![CDATA[第五章 - Python内建函数Python函数、参数及参数解构函数 函数 数学定义：y=f(x) ，y是x的函数，x是自变量。y=f(x0, x1, …, xn) Python函数 由若干语句组成的语句块、函数名称、参数列表构成，它是组织代码的最小单元 完成一定的功能 函数的作用 结构化编程对代码的最基本的封装，一般按照功能组织一段代码 封装的目的为了复用，减少冗余代码 代码更加简洁美观、可读易懂 函数的分类 内建函数，如max()、reversed()等 库函数，如math.ceil()等 函数定义、调用 def语句定义函数def 函数名(参数列表):&emsp; 函数体（代码块）&emsp; [return 返回值] 函数名就是标识符，命名要求一样 语句块必须缩进，约定4个空格 Python的函数没有return语句，隐式会返回一个None值 定义中的参数列表成为形式参数，只是一种符号表达，简称形参 调用 函数定义，只是声明了一个函数，它不会被执行，需要调用 调用的方式，就是函数名加上小括号，括号内写上参数 调用时写的参数是实际参数，是实实在在传入的值，简称实参 函数定义、调用 函数举例&emsp; def add(x, y):&emsp;&emsp; result = x+y&emsp;&emsp; return result&emsp; out = add(4,5)&emsp; print(out) 上面只是一个函数的定义，有一个函数叫做add，接收2个参数 计算的结果，通过返回值返回 调用通过函数名add加2个参数，返回值可使用变量接收 定义需要在调用前，也就是说调用时，已经被定义过了，否则抛NameError异常 函数是可调用的对象，callable() 看看这个函数是不是通用的？体会一下函数的好处 函数参数 参数调用时传入的参数要和定义的个数相匹配（可变参数例外） 位置参数 def f(x, y, z) 调用使用 f(1, 3, 5) 按照参数定义顺序传入实参 关键字参数 def f(x, y, z) 调用使用 f(x=1, y=3, z=5) 使用形参的名字来传入实参的方式，如果使用了形参名字，那么传参顺序就可和定义顺序不同 传参 f(z=None, y=10, x=[1]) f((1,), z=6, y=4.1) f(y=5, z=6, 2) # 要求位置参数必须在关键字参数之前传入，位置参数是按位置对应的 函数参数默认值 (缺省值) 参数默认值（缺省值） 定义时，在形参后跟上一个值&emsp; def add(x=4, y=5):&emsp;&emsp; return x+y测试调用 add(6, 10) 、add(6, y=7) 、add(x=5) 、add()、add(y=7)、 add(x=5, 6) 、add(y=8,4)、add(x=5, y=6)、add(y=5, x=6)测试定义后面这样的函数 def add(x=4,y)写法应该是 y 在 x=4 前面，因为解释器的想法是 前面没有默认值，必须用户给传进来 所以写前面，x=4是有缺省值的位置参数 作用 参数的默认值可以在未传入足够的实参的时候，对没有给定的参数赋值为默认值 参数非常多的时候，并不需要用户每次都输入所有的参数，简化函数调用 举例 定义一个函数login，参数名称为host、port、username、password 函数参数默认值 举例 定义一个函数login，参数名称为host、port、username、password &emsp; def login(host=’127.0.0.1’,port=’8080’,username=’herodanny’,password=’herodanny’):&emsp;&emsp; print(‘{}:{}@{}/{}’.format(host, port, username, password))&emsp; login()&emsp; login(‘127.0.0.1’, 80, ‘tom’, ‘tom’)&emsp; login(‘127.0.0.1’, username=’root’)&emsp; login(‘localhost’, port=80,password=’com’)&emsp; login(port=80, password=’danny’, host=’www’) 可变参数 问题 有多个数，需要累加求和&emsp; def add(nums):&emsp;&emsp; sum = 0&emsp;&emsp; for x in nums:&emsp;&emsp;&emsp; sum += x&emsp;&emsp; return sum&emsp; add([1,3,5])、add((2,4,6))传入一个可迭代对象，迭代元素求和 可变参数 一个形参可以匹配任意个参数 可变参数 (可变位置参数) 位置参数的可变参数 有多个数，需要累加求和def add(*nums):&emsp; sum = 0&emsp; print(type(nums))&emsp; for x in nums:&emsp;&emsp; sum += x&emsp; print(sum)add(3, 6, 9) # 调用 在形参前使用 * 表示该形参是可变参数，可以接收多个实参 收集多个实参为一个tuple 思考：关键字参数能否也能传递任意多个吗？ 可变参数 (可变关键字参数) 关键字参数的可变参数 配置信息打印def showconfig(**kwargs):&emsp; for k,v in kwargs.items():&emsp; &emsp; print(‘{} = {}’.format(k, v))showconfig(host=’127.0.0.1’,port=’8080’,username=’wayne’,password=’magedu’) 形参前使用**符号，表示可以接收多个关键字参数 收集的实参名称和值组成一个字典 可变参数 可变参数混合使用 配置信息打印def showconfig(username, password,**kwargs)def showconfig(username, *args, **kwargs)def showconfig(username, password, **kwargs, *args) # 这么定义是错误的，星号多的放后面 可变参数 总结 有位置可变参数和关键字可变参数 位置可变参数在形参前使用一个星号 * 关键字可变参数在形参前使用两个星号 ** 位置可变参数和关键字可变参数都可以收集若干个实参，位置可变参数收集形成一个tuple，关键字可变参数收集形成一个dict 混合使用参数的时候，可变参数要放到参数列表的最后，普通参数需要放到参数列表前面，位置可变参数需要在关键字可变参数之前 可变参数 举例def fn(x, y, *args, **kwargs):&emsp; print(x)&emsp; print(y)&emsp; print(args)&emsp; print(kwargs) &emsp; fn(3,5,7,9,10,a=1,b=’python’)&emsp; fn(3,5)&emsp; fn(3,5,7)&emsp; fn(3,5,a=1,b=’python’)&emsp; fn(7,9,y=5,x=3,a=1,b=’python’) # 错误，7和9分别赋给了x，y，又y=5、x=3，重复了 可变参数 举例def fn(*args, x, y, **kwargs): # 如果是带缺省值的形参不能写在*参数后面&emsp; print(x)&emsp; print(y)&emsp; print(args)&emsp; print(kwargs) &emsp; fn(3,5)&emsp; fn(3,5,7)&emsp; fn(3,5,a=1,b=’python’)&emsp; fn(7,9,y=5,x=3,a=1,b=’python’)&emsp; 形参前面是可变，后面是不可变，参数匹配时会尽量先匹配x、y keyword-only参数 keyword-only参数（Python3加入） 如果在一个星号参数后，或者一个位置可变参数后，出现的普通参数，实际上已经不是普通的参数了，而是keyword-only参数 (是指实参传参时要像关键字参数那样写)def fn(*args, x):&emsp; print(x)&emsp; print(args) &emsp;&emsp;&emsp; fn(3,5)&emsp;&emsp;&emsp; fn(3,5,7)&emsp;&emsp;&emsp; fn(3,5,x=7)&emsp;&emsp;&emsp; args可以看做已经截获了所有的位置参数，x不使用关键字参数就不可能拿到实参&emsp;&emsp;&emsp; 思考：def fn(**kwargs, x) 可以吗？ keyword-only参数 举例&emsp; def(**kwargs, x):&emsp;&emsp; print(x)&emsp;&emsp; print(kwargs)直接报语法错误可以理解为kwargs会截获所有的关键字参数，就算你写了x=5，x也永远得不到这个值，所以语法错误，x 就算是 keyword-only 参数，在写实参时也要写成关键字参数，这么又分不清是给前面的可变关键字参数，还是给x keyword-only参数 keyword-only 参数另一种形式&emsp; def fn(*, x,y)&emsp;&emsp; print(x,y)&emsp; fn(x=5,y=6)* 号之后，普通（的位置参数）形参都变成了必须给出的 keyword-only 参数def fn(*, x, y) 的意思就是必须要 2个 keyword-only 参数如果前面是可变参数不必写成 def fn(*args, *, x, y) 这种形式，* 可以省略，所以就变成 def fn(*args, x, y) 可变参数和参数默认值 举例def fn(*args, x=5): # 一般 keyword-only 都和缺省值一起使用&emsp; print(x)&emsp; print(args)fn() # 等价于fn(x=5)，x是keyword-only 但有了缺省值就又可以在传参时偷懒省略关键字参数写法fn(5) # 5 传给了 argsfn(x=6)fn(1,2,3,x=10) 可变参数和参数默认值 举例def fn(y, *args, x=5): # x 原来是位置参数，现在有默认值就是keyword-only参数&emsp; print(‘x={}, y={}’.format(x, y))&emsp; print(args)fn()fn(5)fn(x=6) #fn(1,2,3,x=10)fn(y=17,2,3,x=10) #fn(1,2,y=3,x=10) #x 是 keyword-only参数 可变参数和参数默认值 举例def fn(x=5, **kwargs):&emsp; print(‘x={}’.format(x))&emsp; print(kwargs)fn()fn(5)fn(x=6) #fn(y=3,x=10) # y=3匹配了kwargsfn(3,y=10) 函数参数 参数规则 参数列表参数一般顺序是，普通参数、缺省参数、可变位置参数、keyword-only参数（可带缺省值）、可变关键字参数def fn(x, y, z=3, *arg, m=4, n, **kwargs):&emsp; print(x,y,z,m,n)&emsp; print(args)&emsp; print(kwargs) 注意 代码应该易读易懂，而不是为难别人 请按照书写习惯定义函数参数 函数参数 参数规则举例 参数列表参数一般顺序是，普通参数、缺省参数、可变位置参数、keyword-only参数（可带缺省值）、可变关键字参数def connect(host=’localhost’, port=’3306’, user=’admin’, password=’admin’, **kwargs):&emsp; print(host, port)&emsp; print(user, password)&emsp; print(kwargs)connect(db=’cmdb’)connect(host=’192.168.1.123’, db=’cmdb’)connect(host=’192.168.1.123’, db=’cmdb’, password=’mysql’) 参数解构 举例 加法函数def add(x, y):&emsp; return x+yadd(4, 5)add((4,5))t = (4, 5)add(t[0], t[1])add(*t) 或 add(*(4,5)) add(*[4,5]) add(*{4,6}) # 参数解构add(*range(1,3)) 参数解构 参数解构 给函数提供实参的时候，可以在集合类型前使用*或者**，把集合类型的结构解开，提取出所有元素作为函数的实参 非字典类型使用*解构成位置参数 字典类型使用**解构成关键字参数 提取出来的元素数目要和参数的要求匹配，也要和参数的类型匹配def add(x, y):&emsp; return x+yadd(*(4,5)) add(*[4,5]) add(*{4,6})d = {‘x’: 5, ‘y’: 6}add(**d) # 这里解构出来，就像是关键字参数作实参 x=5，y=6add(*d.keys()) # 可能输出是 ‘yx’，key的顺序不可控add(*d.values())add(**{‘a’: 5, ‘b’: 6}) add(*{‘a’: 5, ‘b’: 6}) 参数解构 参数解构和可变参数 给函数提供实参的时候，可以在集合类型前使用*或者**，把集合类型的结构解开，提取出所有元素作为函数的实参def add(*iterable): # 这里 * 号是可变位置参数&emsp; result = 0for x in iterable:&emsp; result += xreturn resultadd(1,2,3)add(*[1,2,3]) # 这里 * 是参数解构add(*range(10)) 练习 编写一个函数，能够接受至少2个参数，返回最小值和最大值 编写一个函数，接受一个参数n，n为正整数，左右两种打印方式。要求数字必须对齐]]></content>
      <categories>
        <category>python-magedu</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python全栈-magedu-2018-笔记14]]></title>
    <url>%2Fpython-magedu-2018-notes14.html</url>
    <content type="text"><![CDATA[第五章 - Python内建函数内建函数 标识 id 返回对象的唯一标识，CPython返回内存地址 哈希 hash() 返回一个对象的哈希值 类型 type() 返回对象的类型 类型转换 float() int() bin() hex() oct() bool() list() tuple() dict() set() complex() bytes() bytearray() 输入 input([prompt]) 接收用户输入，返回一个字符串 打印 print(*objects, sep=’ ‘, end=’\n’, file=sys.stdout, flush=False) 打印输出，默认使用空格分割、换行结尾，输出到控制台 内建函数 对象长度 len(s) 返回一个集合类型的元素个数 isinstance(obj, class_or_tuple) 判断对象obj是否属于某种类型或者元组中列出的某个类型 isinstance(True, int) issubclass(cls, class_or_tuple) 判断类型cls是否是某种类型的子类或元组中列出的某个类型的子类 issubclass(bool, int) 内建函数 绝对值abs(x) x为数值 最大值max() 最小值min() 返回可迭代对象中最大或最小值 返回多个参数中最大或最小值 round(x) 四舍六入五取偶(是银行家算法)，round(-0.5) pow(x , y) 等价于 x**y range(stop) 从0开始到stop-1的可迭代对象；range(start, stop[, step])从start开始到stop-1结束步长为step的可迭代对象 divmod(x, y) 等价于 tuple (x//y, x%y) sum(iterable[, start]) 对可迭代对象的所有数值元素求和 sum(range(1,100,2)) 内建函数 chr(i) 给一个一定范围的整数返回对应的字符 chr(97) chr(20013) ord(c) 返回字符对应的整数 ord(‘a’) ord(‘中’) str() 、repr()、ascii() 后面说 内建函数 sorted(iterable[, key][, reverse]) 排序 返回一个新的列表，默认升序 reverse是反转 &emsp; sorted([1, 3, 5])&emsp; sorted([1, 3, 5], reverse=True)&emsp; sorted({‘c’:1, ‘b’:2, ‘a’:1}) # 返回的是key的列表&emsp; sorted((100, 5)) # 返回的也是排好序的列表 内建函数 翻转 reversed(seq) 返回一个翻转元素的迭代器 &emsp; list(reversed(“13579”))&emsp; { reversed((2, 4)) } # 有几个元素？&emsp; for x in reversed([‘c’,’b’,’a’]):&emsp;&emsp; print(x)&emsp; reversed(sorted({1, 5, 9})) 内建函数 枚举 enumerate(seq, start=0) 迭代一个序列，返回索引数字和元素构成的二元组 start表示索引开始的数字，默认是0 &emsp;&emsp; for x in enumerate([2,4,6,8]):&emsp;&emsp;&emsp; print(x) &emsp;&emsp; for x in enumerate(“abcde”):&emsp;&emsp;&emsp; print(x,end=” “) 内建函数 迭代器和取元素 iter(iterable)、next(iterator[, default]) iter将一个可迭代对象封装成一个迭代器 next对一个迭代器取下一个元素。如果全部元素都取过了，再次next会抛StopIteration异常 &emsp; it = iter(range(5))&emsp; next(it) &emsp; it = reversed([1,3,5])&emsp; next(it) 可迭代对象 可迭代对象 能够通过迭代一次次返回不同的元素的对象。 所谓相同，不是指值是否相同，而是元素在容器中是否是同一个，例如列表中值可以重复的，[‘a’,’a’]，虽然这个列表有2个元素，值一样，但是两个’a’是不同的元素 可以迭代，但是未必有序，未必可索引 可迭代对象有：list、tuple、string、bytes、bytearray、range、set、dict、生成器(迭代器)等 可以使用成员操作符in、not in，in本质上就是在遍历对象 &emsp; 3 in range(10)&emsp; 3 in (x for x in range(10))&emsp; 3 in {x:y for x,y in zip(range(4),range(4,10))} 迭代器 迭代器 特殊的对象，一定是可迭代对象，具备可迭代对象的特征 通过iter方法把一个可迭代对象封装成迭代器 通过next方法，迭代 迭代器对象 生成器对象，就是迭代器对象 &emsp; for x in iter(range(10)):&emsp;&emsp; print(x) &emsp; range()可以看成类似生成器的可迭代对象，它是惰性求值的.&emsp; 因为 next(range(10))，会报类型错误 TypeError: ‘range’ object is not an iterator.&emsp; 一般生成器是迭代器，迭代器不一定是生成器。 &emsp; g = (x for x in range(10))&emsp; print(type(g))&emsp; print(next(g))&emsp; print(next(g)) 内建函数 拉链函数zip(*iterables) 像拉链一样，把多个可迭代对象合并在一起，返回一个迭代器 将每次从不同对象中取到的元素合并成一个元组 &emsp; list(zip(range(10),range(10)))&emsp; list(zip(range(10),range(10),range(5),range(10))) &emsp; dict(zip(range(10),range(10)))&emsp; {str(x):y for x,y in zip(range(10),range(10))}]]></content>
      <categories>
        <category>python-magedu</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python全栈-magedu-2018-笔记13]]></title>
    <url>%2Fpython-magedu-2018-notes13.html</url>
    <content type="text"><![CDATA[第四章 - Python解析式、生成器解析式、生成器 应该算是python特有的。用熟需要练习，可以大大简化写的代码的长度，原来写好几行，现在写一行就行了。 标准库datetime datetime模块 对日期、时间、时间戳的处理 datetime类 类方法 today() 返回本地时区当前时间的datetime对象 now(tz=None) 返回当前时间的datetime对象，时间到微秒，如果tz为None，返回和today()一样 utcnow() 没有时区的当前时间 fromtimestamp(timestamp, tz=None) 从一个时间戳返回一个datetime对象 datetime对象 timestamp() 返回一个到微秒的时间戳。 时间戳：格林威治时间1970年1月1日0点到现在的秒数 标准库datetime datetime对象 构造方法 datetime.datetime(2016, 12, 6, 16, 29, 43, 79043) year、month、day、hour、minute、second、microsecond，取datetime对象的年月日时分秒及微秒 weekday() 返回星期的天，周一0，周日6 isoweekday() 返回星期的天，周一1，周日7 date() 返回日期date对象 time() 返回时间time对象 replace() 修改并返回新的时间 isocalendar() 返回一个三元组(年，周数，周的天) 标准库datetime 日期格式化* 类方法 strptime(date_string, format) ，返回datetime对象 对象方法 strftime(format) ，返回字符串 字符串format函数格式化 &emsp; import datetime&emsp; dt = datetime.datetime.strptime(“21/11/06 16:30”, “%d/%m/%y %H:%M”)&emsp; print(dt.strftime(“%Y-%m-%d %H:%M:%S”))&emsp; print(“{0:%Y}/{0:%m}/{0:%d} {0:%H}::{0:%M}::{0:%S}”.format(dt)) 标准库datetime timedelta对象 datetime2 = datetime1 + timedelta datetime2 = datetime1 - timedelta timedelta = datetime1 - datetime2 构造方法 datetime.timedelta(days=0, seconds=0, microseconds=0, milliseconds=0,minutes=0, hours=0, weeks=0) year = datetime.timedelta(days=365) total_seconds() 返回时间差的总秒数 标准库time time time.sleep(secs) 将调用线程挂起指定的秒数 列表解析 举例 生成一个列表，元素0~9，对每一个元素自增1后求平方返回新列表 列表解析 举例 生成一个列表，元素0~9，对每一个元素自增1后求平方返回新列表 &emsp;&emsp; l1 = list(range(10))&emsp;&emsp; l2 = []&emsp;&emsp; for i in l1:&emsp;&emsp; &emsp; l2.append((i+1)**2)&emsp;&emsp; print(l2) 列表解析式 &emsp;&emsp; l1 = list(range(10))&emsp;&emsp; l2 = [(i+1)**2 for i in l1]&emsp;&emsp; print(l2)&emsp;&emsp; print(type(l2)) 列表解析 List Comprehension 语法 [返回值 for 元素 in 可迭代对象 if 条件] 使用中括号[]，内部是for循环，if条件语句可选 返回一个新的列表 列表解析式是一种语法糖 编译器会优化，不会因为简写而影响效率，反而因优化提高了效率 减少程序员工作量，减少出错 简化了代码，但可读性增强 列表解析 举例 获取10以内的偶数，比较执行效率 &emsp;&emsp; even = []&emsp;&emsp; for x in range(10):&emsp;&emsp;&emsp;&emsp; if x % 2 == 0:&emsp;&emsp;&emsp;&emsp;&emsp;&emsp; even.append(x) &emsp;&emsp; even = [x for x in range(10) if x%2==0] # range直接 step为2 也行跳过奇数 思考 有这样的赋值语句newlist = [print(i) for i in range(10)]，请问newlist的元素打印出来是什么？ 获取20以内的偶数，如果数是3的倍数也打印[i for i in range(20) if i%2==0 elif i%3==0] 行吗？ 列表解析进阶 [expr for item in iterable if cond1 if cond2] 等价于ret = []for item in iterable:&emsp; if cond1:&emsp;&emsp; if cond2:&emsp;&emsp;&emsp; ret.append(expr) 举例20以内，既能被2整除又能被3整除的数[i for i in range(20) if i%2==0 and i%3==0][i for i in range(20) if i%2==0 if i%3==0] 列表解析进阶 [expr for i in iterable1 for j in iterable2 ] 等价于ret = []for i in iterable1:&emsp; for j in iterable2:&emsp;&emsp; ret.append(expr) 举例[(x, y) for x in ‘abcde’ for y in range(3)][[x, y] for x in ‘abcde’ for y in range(3)][{x: y} for x in ‘abcde’ for y in range(3)] 列表解析进阶 请问下面3种输出各是什么？为什么[(i,j) for i in range(7) if i&gt;4 for j in range(20,25) if j&gt;23][(i,j) for i in range(7) for j in range(20,25) if i&gt;4 if j&gt;23][(i,j) for i in range(7) for j in range(20,25) if i&gt;4 and j&gt;23]三条语句语义上是等价的。语句执行的顺序上有不同。效率也差不多。 列表解析练习 练习（要求使用列表解析式完成） 返回1-10平方的列表 有一个列表lst = [1,4,9,16,2,5,10,15]，生成一个新列表，要求新列表元素是lst相邻2项的和 打印九九乘法表 “0001.abadicddws” 是ID格式，要求ID格式是以点号分割，左边是4位从1开始的整数，右边是10位随机小写英文字母。请依次生成前100个ID的列表 生成器表达式 Generator expression 语法 (返回值 for 元素 in 可迭代对象 if 条件) 列表解析式的中括号换成小括号就行了 返回一个生成器 和列表解析式的区别 生成器表达式是 按需计算（或称惰性求值、延迟计算），需要的时候才计算值 列表解析式是立即返回值 生成器 （ generator object ） 可迭代对象 迭代器 生成器表达式** 举例g = (“{:04}”.format(i) for i in range(1,11))next(g)for x in g:&emsp; print(x)print(‘~~~~’)for x in g:&emsp; print(x) 总结 延迟计算 返回迭代器，可以迭代 从前到后走完一遍后，不能回头 对比列表g = [“{:04}”.format(i) for i in range(1,11)]for x in g:&emsp; print(x)print(‘~~~~’)for x in g:&emsp; print(x) 总结 立即计算 返回的不是迭代器，返回可迭代对象列表 从前到后走完一遍后，可以重新回头迭代 生成器表达式 习题it = (print(“{}”.format(i+1)) for i in range(2))first = next(it)second = next(it)val = first + second val的值是什么？ val = first + second 语句之后能否再次next(it)？ 生成器表达式 习题it = (x for x in range(10) if x % 2)first = next(it)second = next(it)val = first + second val的值是什么？ val = first + second 语句之后能否再次next(it)？ 生成器表达式 和列表解析式的对比 计算方式 生成器表达式延迟计算，列表解析式立即计算 内存占用 单从返回值本身来说，生成器表达式省内存，列表解析式返回新的列表 生成器没有数据，内存占用极少，但是使用的时候，虽然一个个返回数据，但是合起来占用的内存也差不多 列表解析式构造新的列表需要占用内存 计算速度 单看计算时间看，生成器表达式耗时非常短，列表解析式耗时长 但是生成器本身并没有返回任何值，只返回了一个生成器对象 列表解析式构造并返回了一个新的列表 集合解析式（推导式） 语法 {返回值 for 元素 in 可迭代对象 if 条件} 列表解析式的中括号换成大括号{}就行了 立即返回一个集合 用法 {(x,x+1) for x in range(10)} {[x] for x in range(10)} # 字典解析式（推导式） 语法 {返回值 for 元素 in 可迭代对象 if 条件} 列表解析式的中括号换成大括号{}就行了 使用key:value形式 立即返回一个字典 用法 {x:(x,x+1) for x in range(10)} {x:[x,x+1] for x in range(10)} {(x,):[x,x+1] for x in range(10)} {[x]:[x,x+1] for x in range(10)} # {chr(0x41+x):x**2 for x in range(10)} {str(x):y for x in range(3) for y in range(4)} # 输出多少个元素？输出：{‘0’:3, ‘1’:3, ‘2’:3}，有些k-v对去重了。 字典解析式 用法 {str(x):y for x in range(3) for y in range(4)} # 输出多少个元素？ 等价于ret = {}for x in range(3):&emsp; for y in range(4):&emsp;&emsp; ret[str(x)] = y 解析式写法有：列表的、集合的、字典的。元组的那个写法，变成了生成器表达式了。 总结 Python2 引入列表解析式 Python2.4 引入生成器表达式 Python3 引入集合、字典解析式，并迁移到了2.7 一般来说，应该多应用解析式，简短、高效 如果一个解析式非常复杂，难以读懂，要考虑拆解成for循环 生成器和迭代器是不同的对象，但都是可迭代对象，都可以用 for 循环的。]]></content>
      <categories>
        <category>python-magedu</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python全栈-magedu-2018-笔记12]]></title>
    <url>%2Fpython-magedu-2018-notes12.html</url>
    <content type="text"><![CDATA[第三章 - Python 内置数据结构字典dict key-value键值对的数据的集合 可变的、无序的、key不重复 字典dict定义 初始化 d = dict() 或者 d = {} dict(**kwargs) 使用name=value对初始化一个字典 dict(iterable, **kwarg) 使用可迭代对象和name=value对构造字典，不过可迭代对象的元素必须是一个二元结构 d = dict(((1,’a’),(2,’b’))) 或者 d = dict(([1,’a’],[2,’b’])) **kwarg是表示在二元结构后面还是可以加k=v参数来初始化d2 = dict(d, c=3) dict(mapping, **kwarg) 使用一个字典构建另一个字典 d = {‘a’:10, ‘b’:20, ‘c’:None, ‘d’:[1,2,3]} 类方法dict.fromkeys(iterable, value) d = dict.fromkeys(range(5)) d = dict.fromkeys(range(5),0) &emsp; (类方法就相当于java中的静态方法)&emsp; d1 = dict.fromkeys(range(1, 11), [1, 2])&emsp; 这样产生的字典中所有的value都是列表[1,2]的引用，如果append这个列表，所有的value都会被修改。 字典元素的访问 d[key] 返回key对应的值value key不存在抛出KeyError异常 get(key[, default]) 返回key对应的值value key不存在返回缺省值，如果没有设置缺省值就返回None setdefault(key[, default]) 返回key对应的值value key不存在，添加kv对，value为default，并返回default，如果default没有设置，缺省为None 字典增加和修改 d[key] = value 将key对应的值修改为value key不存在添加新的kv对 update([other]) -&gt; None 使用另一个字典的kv对更新本字典 key不存在，就添加 key存在，覆盖已经存在的key对应的值 就地修改 &emsp; d.update(red=1)&emsp; d.update(((‘red’,2),))&emsp; d.update({‘red’:3}) 字典删除 pop(key[, default]) key存在，移除它，并返回它的value key不存在，返回给定的default default未设置，key不存在则抛出KeyError异常 popitem() 移除并返回一个任意的键值对 字典为empty，抛出KeyError异常 clear() 清空字典 字典删除 del语句a = Trueb = [6]d = {‘a’: 1, ‘b’: b, ‘c’: [1,3,5]}del adel d[‘c’] # 删除了一个对象[1,3,5]？del b[0]c = bdel cdel bb = d[‘b’]p del a[‘c’] # 看着像删除了一个对象，本质上减少了一个对象的引用，del 实际上删除的是名称，而不是对象 字典遍历 for … in dict 遍历key &emsp;&emsp; for k in d:&emsp;&emsp;&emsp; print(k) &emsp;&emsp; for k in d.keys():&emsp;&emsp;&emsp; print(k) 字典遍历 for … in dict 遍历value &emsp;&emsp; for k in d:&emsp;&emsp;&emsp; print(d[k]) &emsp;&emsp; for k in d.keys():&emsp;&emsp;&emsp; print(d.get(k)) &emsp;&emsp; for v in d.values():&emsp;&emsp;&emsp; print(v) 字典遍历 for … in dict 遍历item，即k-v对 &emsp;&emsp; for item in d.items():&emsp;&emsp;&emsp; print(item) # item是(k,v)元组，不推荐这种写法 &emsp;&emsp; for item in d.items():&emsp;&emsp;&emsp; print(item[0], item[1]) &emsp;&emsp; for k,v in d.items():&emsp;&emsp;&emsp; print(k, v) # 推荐这种写法 &emsp;&emsp; for k, _ in d.items():&emsp;&emsp;&emsp; print(k) &emsp;&emsp; for _ ,v in d.items():&emsp;&emsp;&emsp; print(v) 字典遍历 总结 Python3中，keys、values、items方法返回一个类似一个生成器的可迭代对象，不会把函数的返回结果复制到内存中 (可以把返回的 dict_items()、dict_keys()、dict_values() 想象成是帮你到字典中取数据) 是 Dictionary view 对象 字典的entry的动态的视图，字典变化，视图将反映出这些变化 Python2中，上面的方法会返回一个新的列表，占据新的内存空间。所以Python2建议使用iterkeys、itervalues、iteritems版本，返回一个迭代器，而不是一个copy 字典遍历和移除 如何在遍历的时候移除元素 &emsp;&emsp; 错误的做法:&emsp;&emsp; d = dict(a=1, b=2, c=’abc’)&emsp;&emsp; for k,v in d.items():&emsp;&emsp;&emsp;&emsp; d.pop(k) # RuntimeError: dictionary changed size during iteration&emsp;&emsp; 用字典视图的对象迭代时，是不能修改字典的大小的&emsp;&emsp; 另外在用for 迭代时，字典的大小是不允许改变的，即不允许增删元素。 &emsp;&emsp; while len(d): # 相当于清空，不如直接clear()&emsp;&emsp;&emsp;&emsp; print(d.popitem()) &emsp;&emsp; 正确的做法:&emsp;&emsp; d = dict(a=1, b=2, c=’abc’)&emsp;&emsp; keys = []&emsp;&emsp; for k,v in d.items():&emsp;&emsp;&emsp;&emsp; if isinstance(v, str):&emsp;&emsp;&emsp;&emsp;&emsp;&emsp; keys.append(k)&emsp;&emsp; for k in keys:&emsp;&emsp;&emsp;&emsp; d.pop(k)&emsp;&emsp; print(d) 字典的key key的要求和set的元素要求一致 set的元素可以就是看做key，set可以看做dict的简化版 hashable 可哈希才可以作为key，可以使用hash()测试，即key不可变的，key变了，通过哈希函数找到的值也就变了。 d = {1 : 0, 2.0 : 3, “abc” : None, (‘hello’, ‘world’, ‘python’) : “string”, b’abc’ : ‘135’} defaultdict collections.defaultdict([default_factory[, …]]) 第一个参数是default_factory，缺省是None，它提供一个初始化函数。当key不存在的时候，会调用这个工厂函数来生成key对应的value &emsp; import random&emsp; d1 = {}&emsp; for k in ‘abcdef’:&emsp;&emsp; for i in range(random.randint(1,5)):&emsp;&emsp;&emsp; if k not in d1.keys():&emsp;&emsp;&emsp;&emsp; d1[k] = []&emsp;&emsp;&emsp; d1[k].append(i) &emsp; print(d1) &emsp; from collections import defaultdict&emsp; import random &emsp; d1 = defaultdict(list)&emsp; for k in ‘abcdef’:&emsp;&emsp; for i in range(random.randint(1,5)):&emsp;&emsp;&emsp; d1[k].append(i) &emsp; print(d1) OrderedDict collections.OrderedDict([items]) key并不是按照加入的顺序排列，可以使用OrderedDict记录顺序 &emsp; from collections import OrderedDict&emsp; import random&emsp; d = {‘banana’: 3, ‘apple’: 4, ‘pear’: 1, ‘orange’: 2}&emsp; print(d)&emsp; keys = list(d.keys())&emsp; random.shuffle(keys)&emsp; print(keys)&emsp; od = OrderedDict()&emsp; for key in keys:&emsp;&emsp; od[key] = d[key]&emsp; print(od)&emsp; print(od.keys()) OrderedDict 有序字典可以记录元素插入的顺序，打印的时候也是按照这个顺序输出打印 3.6版本的Python的字典就是记录key插入的顺序（IPython不一定有效果） 应用场景： 假如使用字典记录了N个产品，这些产品使用ID由小到大加入到字典中 除了使用字典检索的遍历，有时候需要取出ID，但是希望是按照输入的顺序，因为输入顺序是有序的 否则还需要重新把遍历到的值排序 字典练习 用户输入一个数字 打印每一位数字及其重复的次数 数字重复统计 随机产生100个整数 数字的范围[-1000, 1000] 升序输出所有不同的数字及其重复的次数 字符串重复统计 字符表’abcdefghijklmnopqrstuvwxyz’ 随机挑选2个字母组成字符串，共挑选100个 降序输出所有不同的字符串及重复的次数]]></content>
      <categories>
        <category>python-magedu</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python全栈-magedu-2018-笔记11]]></title>
    <url>%2Fpython-magedu-2018-notes11.html</url>
    <content type="text"><![CDATA[第三章 - Python 内置数据结构简单选择排序 简单选择排序 属于选择排序 两两比较大小，找出极值（极大值或极小值）被放置在固定的位置，这个固定位置一般指的是某一端 结果分为升序和降序排列 降序 n个数从左至右，索引从0开始到n-1，两两依次比较，记录大值索引，此轮所有数比较完毕，将大数和索引0数交换，如果大数就是索引1，不交换。第二轮，从1开始比较，找到最大值，将它和索引1位置交换，如果它就在索引1位置则不交换。依次类推，每次左边都会固定下一个大数。 升序 和降序相反 简单选择排序 简单选择排序代码实现（一）*1234567891011121314151617181920212223242526m_list = [ [1, 9, 8, 5, 6, 7, 4, 3, 2], [1, 2, 3, 4, 5, 6, 7, 8, 9], [9, 8, 7, 6, 5, 4, 3, 2, 1]]nums = m_list[1]length = len(nums)print(nums)count_swap = 0count_iter = 0for i in range(length): maxindex = i for j in range(i + 1, length): count_iter += 1 if nums[maxindex] &lt; nums[j]: maxindex = j if i != maxindex: tmp = nums[i] nums[i] = nums[maxindex] nums[maxindex] = tmp count_swap += 1print(nums, count_swap, count_iter) 简单选择排序代码实现（二） 优化实现二元选择排序同时固定左边最大值和右边最小值优点：减少迭代元素的次数 &emsp; 1、length//2 整除，通过几次运算就可以发现规律&emsp; 2、由于使用了负索引，所以条件中要增加&emsp; i == length + minindex &emsp; 还有没有优化的可能？ 12345678910111213141516171819202122232425262728293031count_swap = 0count_iter = 0# 二元选择排序for i in range(length // 2): maxindex = i minindex = -i - 1 minorigin = minindex for j in range(i + 1, length - i): # 每次左右都要少比较一个 count_iter += 1 if nums[maxindex] &lt; nums[j]: maxindex = j if nums[minindex] &gt; nums[-j - 1]: minindex = -j - 1 # print(maxindex, minindex) if i != maxindex: tmp = nums[i] nums[i] = nums[maxindex] nums[maxindex] = tmp count_swap += 1 # 如果最小值被交换过，要更新索引 if i == minindex or i == length + minindex: minindex = maxindex if minorigin != minindex: tmp = nums[minorigin] nums[minorigin] = nums[minindex] nums[minindex] = tmp count_swap += 1print(nums, count_swap, count_iter) 简单选择排序代码实现（二） 改进实现如果一轮比较后，极大值、极小值的值相等，说明比较的序列元素全部相等 12345678910111213141516171819202122232425262728293031323334353637383940m_list = [ [1, 9, 8, 5, 6, 7, 4, 3, 2], [1, 2, 3, 4, 5, 6, 7, 8, 9], [9, 8, 7, 6, 5, 4, 3, 2, 1], [1, 1, 1, 1, 1, 1, 1, 1, 1]]nums = m_list[3]length = len(nums)print(nums)count_swap = 0count_iter = 0# 二元选择排序for i in range(length // 2): maxindex = i minindex = -i - 1 minorigin = minindex for j in range(i + 1, length - i): # 每次左右都要少比较一个 count_iter += 1 if nums[maxindex] &lt; nums[j]: maxindex = j if nums[minindex] &gt; nums[-j - 1]: minindex = -j - 1# print(maxindex, minindex)if nums[maxindex] == nums[minindex]: # 元素全相同 breakif i != maxindex: tmp = nums[i] nums[i] = nums[maxindex] nums[maxindex] = tmp count_swap += 1 # 如果最小值被交换过，要更新索引 if i == minindex or i == length + minindex: minindex = maxindexif minorigin != minindex: tmp = nums[minorigin] nums[minorigin] = nums[minindex] nums[minindex] = tmp count_swap += 1print(nums, count_swap, count_iter) 简单选择排序代码实现（二) 改进实现[1, 1, 1, 1, 1, 1, 1, 1, 2] 这种情况，找到的最小值索引是-2，最大值索引8，上面的代码会交换2次，最小值两个1交换是无用功，所以，增加一个判断 123456789101112131415161718192021222324252627282930313233343536373839404142434445m_list = [ [1, 9, 8, 5, 6, 7, 4, 3, 2], [1, 2, 3, 4, 5, 6, 7, 8, 9], [9, 8, 7, 6, 5, 4, 3, 2, 1], [1, 1, 1, 1, 1, 1, 1, 1, 1], [1, 1, 1, 1, 1, 1, 1, 1, 2]]nums = m_list[4]length = len(nums)print(nums)count_swap = 0count_iter = 0# 二元选择排序for i in range(length // 2): maxindex = i minindex = -i - 1 minorigin = minindex for j in range(i + 1, length - i): # 每次左右都要少比较一个 count_iter += 1 if nums[maxindex] &lt; nums[j]: maxindex = j if nums[minindex] &gt; nums[-j - 1]: minindex = -j - 1 print(maxindex, minindex) if nums[maxindex] == nums[minindex]: # 元素相同 break if i != maxindex: tmp = nums[i] nums[i] = nums[maxindex] nums[maxindex] = tmp count_swap += 1 # 如果最小值被交换过，要更新索引 if i == minindex or i == length + minindex: minindex = maxindex # 最小值索引不同，但值相同就没有必要交换了 if minorigin != minindex and nums[minorigin] != nums[minindex]: tmp = nums[minorigin] nums[minorigin] = nums[minindex] nums[minindex] = tmp count_swap += 1print(nums, count_swap, count_iter) 简单选择排序总结 简单选择排序需要数据一轮轮比较，并在每一轮中发现极值 没有办法知道当前轮是否已经达到排序要求，但是可以知道极值是否在目标索引位置上 遍历次数1,…,n-1之和n(n-1)/2 时间复杂度O(n2) 减少了交换次数，提高了效率，性能略好于冒泡法]]></content>
      <categories>
        <category>python-magedu</category>
      </categories>
      <tags>
        <tag>python, Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python全栈-magedu-2018-笔记10]]></title>
    <url>%2Fpython-magedu-2018-notes10.html</url>
    <content type="text"><![CDATA[第三章 - Python 内置数据结构集set 约定 set 翻译为集合 collection 翻译为集合类型，是一个大概念 set 可变的、无序的、不重复的元素的集合 set定义 初始化 set() -&gt; new empty set object set(iterable) -&gt; new set object &emsp; s1 = set()&emsp; s2 = set(range(5))&emsp; s3 = set(list(range(10)))&emsp; s4 = {} # dict&emsp; s5 = {9,10,11} # set&emsp; s6 = {(1,2),3,’a’}&emsp; s7 = {[1],(1,),1} # unhashable type: ‘list’ set的元素 set的元素要求必须可以hash（因为set就是哈希表啊） 目前学过的不可hash的类型有list、set 元素不可以索引，因为无序 set可以迭代 set增加 add(elem) 增加一个元素到set中 如果元素存在，什么都不做 update(*others) 合并其他元素到set集合中来 参数others必须是可迭代对象 就地修改 set删除 remove(elem) 从set中移除一个元素 元素不存在，抛出KeyError异常。为什么是KeyError？ discard(elem) 从set中移除一个元素 元素不存在，什么都不做 pop() -&gt; item 移除并返回任意的元素。为什么是任意元素？ 空集返回KeyError异常 clear() 移除所有元素 set修改、查询 修改 要么删除，要么加入新的元素 为什么没有修改？ 查询 非线性结构，无法索引 遍历 可以迭代所有元素 成员运算符 in 和 not in 判断元素是否在set中 效率呢？与索引访问列表的效率是差不多的，O(1) set成员运算符的比较 list和set的比较 lst1 = list(range(100)) lst2 = list(range(1000000)) -1 in lst1、-1 in lst2 看看效率 set1 = set(range(100)) set2 = set(range(1000000)) -1 in set1、-1 in set2 看看效率 set成员运算符的比较%%timeit lst1=list(range(100))a = -1 in lst1 %%timeit lst1=list(range(1000000))a = -1 in lst1 %%timeit set1=set(range(100))a = -1 in set1 %%timeit set1=set(range(1000000))a = -1 in set1 set不管元素怎么增加遍历的效率都是一样的。 set和线性结构 线性结构的查询时间复杂度是O(n)，即随着数据规模的增大而增加耗时 set、dict等结构，内部使用hash值作为key，时间复杂度可以做到O(1)，查询时间和数据规模无关 可hash 数值型int、float、complex 布尔型True、False 字符串string、bytes tuple None 以上都是不可变类型，成为可哈希类型，hashable set的元素必须是可hash的 集合 基本概念 全集 所有元素的集合。例如实数集，所有实数组成的集合就是全集 子集subset和超集superset 一个集合A所有元素都在另一个集合B内，A是B的子集，B是A的超集 真子集和真超集 A是B的子集，且A不等于B，A就是B的真子集，B是A的真超集 并集：多个集合合并的结果 交集：多个集合的公共部分 差集：集合中除去和其他集合公共部分 集合运算 并集 将两个集合A和B的所有的元素合并到一起，组成的集合称作集合A与集合B的并集 union(*others) 返回和多个集合合并后的新的集合 | 运算符重载 等同union update(*others) 和多个集合合并，就地修改 |= 等同update 集合运算 交集 集合A和B，由所有属于A且属于B的元素组成的集合 intersection(*others) 返回和多个集合的交集 &amp; 等同intersection intersection_update(*others) 获取和多个集合的交集，并就地修改 &amp;= 等同intersection_update 集合运算 差集 集合A和B，由所有属于A且不属于B的元素组成的集合 difference(*others) 返回和多个集合的差集 - 等同difference difference_update(*others) 获取和多个集合的差集并就地修改 -= 等同difference_update 集合运算 对称差集 集合A和B，由所有不属于A和B的交集元素组成的集合，记作（A-B）∪（B-A） symmetric_differece(other) 返回和另一个集合的差集 \^ 等同symmetric_differece symmetric_differece_update(other) 获取和另一个集合的差集并就地修改 \^= 等同symmetric_differece_update 集合运算 issubset(other)、&lt;= 判断当前集合是否是另一个集合的子集 set1 &lt; set2 判断set1是否是set2的真子集 issuperset(other)、&gt;= 判断当前集合是否是other的超集 set1 &gt; set2 判断set1是否是set的真超集 isdisjoint(other) 当前集合和另一个集合没有交集 没有交集，返回True 集合应用 共同好友 你的好友A、B、C，他的好友C、B、D，求共同好友如果是推荐好友，用差集求，不用查库，在内存中集合运算是非常快的，而且往往用到Redis的 微信群提醒 XXX与群里其他人都不是微信朋友关系 权限判断 有一个API，要求权限同时具备A、B、C才能访问，用户权限是B、C、D，判断用户是否能够访问该API 有一个API，要求权限具备A、B、C任意一项就可访问，用户权限是B、C、D，判断用户是否能够访问该API 一个总任务列表，存储所有任务。一个完成的任务列表。找出为未完成的任务 解决的方法都不是唯一的，下面仅供参考。 集合应用 共同好友 你的好友A、B、C，他的好友C、B、D，求共同好友 交集问题：{‘A’, ‘B’, ‘C’}.intersection({‘B’, ‘C’, ‘D’}) 微信群提醒 XXX与群里其他人都不是微信朋友关系 并集：userid in (A | B | C | …) == False，A、B、C等是微信好友的并集，用户ID不在这个并集中，说明他和任何人都不是朋友 集合应用 权限判断 有一个API，要求权限同时具备A、B、C才能访问，用户权限是B、C、D，判断用户是否能够访问该API API集合A，权限集合P A - P = {} ，A-P为空集，说明P包含A A.issubset(P) 也行，A是P的子集也行 A &amp; P = A 也行 有一个API，要求权限具备A、B、C任意一项就可访问，用户权限是B、C、D，判断用户是否能够访问该API API集合A，权限集合P A &amp; P != {} 就可以 A.isdisjoint(P) == False 表示有交集 集合应用 一个总任务列表，存储所有任务。一个已完成的任务列表。找出为未完成的任务 业务中，任务ID一般不可以重复 所有任务ID放到一个set中，假设为ALL 所有已完成的任务ID放到一个set中，假设为COMPLETED，它是ALL的子集 ALL - COMPLETED = UNCOMPLETED 集合练习 随机产生2组各10个数字的列表，如下要求： 每个数字取值范围[10,20] 统计20个数字中，一共有多少个不同的数字？ 2组中，不重复的数字有几个？分别是什么？ 2组中，重复的数字有几个？分别是什么？ 集合练习 随机产生2组各10个数字的列表，如下要求： 每个数字取值范围[10,20] 统计20个数字中，一共有多少个不同的数字？ 2组比较，不重复的数字有几个？分别是什么？ 2组比较，重复的数字有几个？分别是什么？ &emsp; a = [1, 9, 7, 5, 6, 7, 8, 8, 2, 6]&emsp; b = [1, 9, 0, 5, 6, 4, 8, 3, 2, 3]&emsp; s1 = set(a)&emsp; s2 = set(b)&emsp; print(s1)&emsp; print(s2)&emsp; print(s1.union(s2))&emsp; print(s1.symmetric_difference(s2))&emsp; print(s1.intersection(s2))]]></content>
      <categories>
        <category>python-magedu</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python全栈-magedu-2018-笔记9]]></title>
    <url>%2Fpython-magedu-2018-notes9.html</url>
    <content type="text"><![CDATA[第三章 - Python 内置数据结构封装和解构 封装 将多个值使用逗号分割，组合在一起 本质上，返回一个元组，只是省掉了小括号 python特有语法，被很多语言学习和借鉴 &emsp;&emsp; t1 = (1,2) # 定义为元组&emsp;&emsp; t2 = 1,2 # 将1和2封装成元组，一般都这么写&emsp;&emsp; type(t1)&emsp;&emsp; type(t2) 封装和解构 举例 &emsp;&emsp; a = 4&emsp;&emsp; b = 5 &emsp;&emsp; temp = a&emsp;&emsp; a = b&emsp;&emsp; b = temp &emsp;&emsp; 等价于&emsp;&emsp; a, b = b, a &emsp;&emsp; 上句中，等号右边使用了封装，而左边就使用了解构 解构 把线性结构的元素解开，并顺序的赋给其它变量 左边接纳的变量数要和右边解开的元素个数一致 举例 &emsp;&emsp; lst = [3, 5]&emsp;&emsp; first, second = lst&emsp;&emsp; print(first, second) 解构a,b = 1,2a,b = (1,2)a,b = [1,2]a,b = [10,20]a,b = {10,20}a,b = {‘a’:10,’b’:20} # 非线性结构也可以解构，a为a是key值，b为ba,b = {10,20,30}a,*b = {10,20,30} # a为1，b为[20,30]，*是匹配任意多个元素，因为解构时元素不确定，所以用列表[a,b] = (1,2)[a,b] = 10,20(a,b) = {30,40} Python3的解构 使用 *变量名 接收，但不能单独使用 被 *变量名 收集后组成一个列表 举例 &emsp;&emsp; lst = list(range(1, 101, 2))&emsp;&emsp; head, *mid, tail = lst&emsp;&emsp; *lst2 = lst&emsp;&emsp; *body, tail = lst&emsp;&emsp; head, *tail = lst&emsp;&emsp; head, *m1, *m2, tail = lst&emsp;&emsp; head, *mid, tail = “abcdefghijklmn”&emsp;&emsp; type(mid) 丢弃变量 这是一个惯例，是一个不成文的约定，不是标准 如果不关心一个变量，就可以定义改变量的名字为_ _是一个合法的标识符，也可以作为一个有效的变量使用，但是定义成下划线就是希望不要被使用，除非你明确的知道这个数据需要使用 举例 &emsp;&emsp; lst = [9,8,7,20]&emsp;&emsp; first, *second = lst&emsp;&emsp; head, *_, tail = lst&emsp;&emsp; print(head)&emsp;&emsp; print(tail)&emsp;&emsp; _是合法的标识符，看到下划线就知道这个变量就是不想被使用&emsp;&emsp; print(_) 丢弃变量 举例 &emsp;&emsp; lst = [9,8,7,20]&emsp;&emsp; first, *second = lst&emsp;&emsp; _ , *_, tail = lst&emsp;&emsp; print(_)&emsp;&emsp; print(tail)&emsp;&emsp; print(_) 丢弃变量 总结 _ 这个变量本身无任何语义，没有任何可读性，所以不是用来给人使用的 Python中很多库，都使用这个变量，使用十分广泛。请不要在不明确变量作用域的情况下，使用 _ 导致和库中 _ 冲突 练习 lst = list(range(10)) # 这样一个列表，取出第二个、第四个、倒数第二个 练习 练习 从lst = [1,(2,3,4),5]中，提取4出来 环境变量JAVA_HOME=/usr/bin，返回环境变量名和路径 对列表[1, 9, 8, 5, 6, 7, 4, 3, 2]使用冒泡法排序，要求使用封装和解构来交互数据 练习 练习 从lst = [1,(2,3,4),5]中，提取4出来 &emsp;&emsp; lst = [1,(2,3,4),5]&emsp;&emsp; a,(b,c,d),e = lst&emsp;&emsp; print(a,b,c,d,e) &emsp;&emsp; _, (*_, val), *_ = lst&emsp;&emsp; print(val) &emsp;&emsp; _, [*_, val], *_ = lst&emsp;&emsp; print(val) 练习 练习 环境变量JAVA_HOME=/usr/bin，返回变量名和路径key, _ , val = “JAVA_HOME=/usr/bin”.partition(‘=’)print(key)print(val) 总结： 解构，是Python提供的很好的功能，可以方便的提取复杂数据结构的值 配合 _ 的使用，会更加便利]]></content>
      <categories>
        <category>python-magedu</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python全栈-magedu-2018-笔记8]]></title>
    <url>%2Fpython-magedu-2018-notes8.html</url>
    <content type="text"><![CDATA[第四章 - IPython 使用帮助 ? Ipython的概述和简介 help(name) 查询指定名称的帮助，是python帮助 obj? 列出obj对象的详细信息 obj?? 列出更加详细的信息 特殊变量 _ 表示前一次输出 __ 表示倒数第二次输出 ___ 表示倒数第三次输出 _dh 目录历史 _oh 输出历史 shell命令 !command 执行shell命令 !ls -l !touch test.txt files = !ls -l | grep py 魔术方法 使用%百分号开头的，IPython内置的特殊方法 %magic 格式 % 开头是line magic %% 开头是 cell magic，notebook的cell %alias 定义一个系统命令的别名 alias ll ls -l %timeit statement -n 一个循环loop执行语句多少次 -r 循环执行多少次loop，取最好的结果 %%timeit setup_codecode….. 魔术方法 %cd 改变当前工作目录，cd可以认为是%cd的链接。路径历史在_dh中查看 %pwd、pwd 显示当前工作目录 %ls 、ls 返回文件列表 注意：%pwd这种是魔术方法，是IPython的内部实现，和操作系统无关。而!pwd 就要依赖当前操作系统的shell提供的命令执行，默认windows不支持pwd命令 %%js、%%javascript 在cell中运行js脚本%%jsalert(‘a’ + 1)]]></content>
      <categories>
        <category>python-magedu</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python全栈-magedu-2018-笔记7]]></title>
    <url>%2Fpython-magedu-2018-notes7.html</url>
    <content type="text"><![CDATA[第三章 - Python 内置数据结构线性结构 线性结构 可迭代 for … in len()可以获取长度 通过下标可以访问 可以切片 学过的线性结构 列表、元组、字符串、bytes、bytearray 切片 切片 通过索引区间访问线性结构的一段数据 sequence[start:stop] 表示返回[start, stop)区间的子序列 支持负索引 start为0，可以省略 stop为末尾，可以省略 超过上界（右边界），就取到末尾；超过下界（左边界），取到开头 start一定要在stop的左边 [:] 表示从头至尾，全部元素被取出，等效于copy()方法 切片 切片举例‘www.github.com&#39;[4:10]‘www.github.com&#39;[:10]‘www.github.com&#39;[4:]‘www.github.com&#39;[:]‘www.github.com&#39;[:-1]‘www.github.com&#39;[4:-4]‘www.github.com&#39;[4:50]b’www.github.com&#39;[-40:10]bytearray(b’www.github.com&#39;)[-4:10]tuple(‘www.github.com&#39;)[-10:10]list(‘www.github.com&#39;)[-10:-4] 步长切片 [start:stop:step] step为步长，可以正、负整数，默认是1 step要和start:stop同向，否则返回空序列‘www.github.com&#39;[4:10:2]list(‘www.github.com&#39;)[4:10:-2]tuple(‘www.github.com&#39;)[-10:-4:2]b’www.github.com&#39;[-4:-10:2]bytearray(b’www.github.com&#39;)[-4:-10:-2] 切片可以赋值arr = [ ‘C’, ‘python’, ‘js’, ‘css’, ‘html’, ‘node’]arr[2:4] = [‘pc’,’wd’]arr # [‘C’, ‘python’, ‘pc’, ‘wd’, ‘html’, ‘node’] 切片可以插入和删除元素arr = [‘C’, ‘python’, ‘js’, ‘css’, ‘html’, ‘node’]arr[1:1] = [‘pc’,’wd’] # [1:1]表示在1开始查找，但没有查找，所以是在索引1添加元素arr # [‘C’, ‘pc’, ‘wd’, ‘python’, ‘js’, ‘css’, ‘html’, ‘node’]arr[2:3] = [] # 删除索引2的元素arr # [‘C’, ‘pc’, ‘python’, ‘js’, ‘css’, ‘html’, ‘node’]]]></content>
      <categories>
        <category>python-magedu</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python全栈-magedu-2018-笔记6]]></title>
    <url>%2Fpython-magedu-2018-notes6.html</url>
    <content type="text"><![CDATA[第三章 - Python 内置数据结构bytes、bytearray Python3引入两个新类型 bytes 不可变字节序列 bytearray 字节数组 可变 bytes、bytearray 字符串与bytes 字符串是字符组成的有序序列，字符可以使用编码来理解 bytes是字节组成的有序的不可变序列 bytearray是字节组成的有序的可变序列 编码与解码 字符串按照不同的字符集编码encode返回字节序列bytes encode(encoding=’utf-8’, errors=’strict’) -&gt; bytes 字节序列按照不同的字符集解码decode返回字符串 bytes.decode(encoding=”utf-8”, errors=”strict”) -&gt; str bytearray.decode(encoding=”utf-8”, errors=”strict”) -&gt; str bytes定义 定义 bytes() 空bytes bytes(int) 指定长度的bytes，被0填充 bytes(iterable_of_ints) -&gt; bytes [0,255]的int组成的可迭代对象 bytes(string, encoding[, errors]) -&gt; bytes 等价于string.encode() bytes(bytes_or_buffer) -&gt; immutable copy of bytes_or_buffer 从一个字节序列或者buffer复制出 (是浅拷贝) 一个新的不可变的bytes对象 使用b前缀定义 只允许基本ASCII使用字符形式b’abc9’ 使用16进制表示b”\x41\x61”1234567a = bytes(range(15))ab'\x00\x01\x02\x03\x04\x05\x06\x07\x08\t\n\x0b\x0c\r\x0e'# 看ASCII表，9 是\t，10是\n，13是\r。前面那些 00 01 02 03，# 也有自己的意思，但是没办法用字符表示出来，所以就用它的十六进制表示法表示出来。# 类似当看到返回或自己写的是 b'hello' 其实应该是 \x68\x65\x6c\x6c\x6f # 这样一串，只不过ipython等工具，把他优化成便于人类理解的形式。 bytes操作 和str类型类似，都是不可变类型，所以方法很多都一样。只不过bytes的方法，输入是bytes，输出是bytes&emsp; b’abcdef’.replace(b’f’,b’k’)&emsp; b’abc’.find(b’b’) 类方法 bytes.fromhex(string) string必须是2个字符的16进制的形式，’6162 6a 6b’，空格将被忽略&emsp; bytes.fromhex(‘6162 09 6a 6b00’)&emsp; 输出：b’ab\tjk\x00’ # 即a:61 b:63 \t:09 j:6a k=6b 00:\x00 hex() 返回16进制表示的字符串&emsp; ‘abc’.encode().hex() 索引&emsp; b’abcdef’[2] 返回该字节对应的数，int类型 bytearray定义 定义 bytearray() 空bytearray bytearray(int) 指定字节的bytearray，被0填充 bytearray(iterable_of_ints) -&gt; bytearray [0,255]的int组成的可迭代对象 bytearray(string, encoding[, errors]) -&gt; bytearray 近似string.encode()，不过返回可变对象 bytearray(bytes_or_buffer) 从一个字节序列或者buffer复制出一个新的可变的bytearray对象 （有时也有从bytes转list对象） 注意，b前缀定义的类型是bytes类型 bytearray操作 和bytes类型的方法相同 bytearray(b’abcdef’).replace(b’f’,b’k’) bytearray(b’abc’).find(b’b’) 类方法 bytearray.fromhex(string) string必须是2个字符的16进制的形式，’6162 6a 6b’，空格将被忽略bytearray.fromhex(‘6162 09 6a 6b00’) hex() 返回16进制表示的字符串bytearray(‘abc’.encode()).hex() 索引bytearray(b’abcdef’)[2] 返回该字节对应的数，int类型 bytearray操作 append(int) 尾部追加一个元素 insert(index, int) 在指定索引位置插入元素 extend(iterable_of_ints) 将一个可迭代的整数集合追加到当前bytearray pop(index=-1) 从指定索引上移除元素，默认从尾部移除 remove(value) 找到第一个value移除，找不到抛ValueError异常 注意：上述方法若需要使用int类型，值在[0, 255] clear() 清空bytearray reverse() 翻转bytearray，就地修改 &emsp;&emsp; b = bytearray()&emsp;&emsp; b.append(97)&emsp;&emsp; b.append(99)&emsp;&emsp; b.insert(1,98)&emsp;&emsp; b.extend([65,66,67])&emsp;&emsp; b.remove(66)&emsp;&emsp; b.pop()&emsp;&emsp; b.reverse()&emsp;&emsp; b.clear()]]></content>
      <categories>
        <category>python-magedu</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python全栈-magedu-2018-笔记5]]></title>
    <url>%2Fpython-magedu-2018-notes5.html</url>
    <content type="text"><![CDATA[第三章 - Python 内置数据结构字符串 一个个字符组成的有序的序列，是字符的集合。 python中一个字符也是str类型。 使用单引号、双引号、三引号引住的字符序列 字符串是不可变对象 Python3起，字符串就是Unicode类型 字符串定义 初始化 举例 &emsp;&emsp; s1 = ‘string’&emsp;&emsp; s2 = “string2”&emsp;&emsp; s3 = ‘’’this’s a “String” ‘’’&emsp;&emsp; s4 = ‘hello \n herodanny.github.io’&emsp;&emsp; s5 = r”hello \n herodanny.github.io”&emsp;&emsp; s6 = ‘c:\windows\nt’&emsp;&emsp; s7 = R”c:\windows\nt”&emsp;&emsp; s8 = ‘c:\windows\\nt’&emsp;&emsp; sql = “””select * from user where name=’tom’ “”” 字符串元素访问——下标 字符串支持使用索引访问 &emsp;&emsp; sql = “select * from user where name=’tom’”&emsp;&emsp; sql[4] # 字符串’c’&emsp;&emsp; sql[4] = ‘o’ 有序的字符集合，字符序列&emsp;&emsp; for c in sql:&emsp;&emsp;&emsp; print(c)&emsp;&emsp;&emsp; print(type(c)) # 什么类型？ 可迭代 &emsp;&emsp; lst = list(sql) 字符串join连接* “string”.join(iterable) -&gt; str 将可迭代对象连接起来，使用string作为分隔符 可迭代对象本身元素都是字符串 返回一个新字符串 &emsp;&emsp; lst = [‘1’,’2’,’3’]&emsp;&emsp; print(“\””.join(lst)) # 分隔符是双引号&emsp;&emsp; print(“ “.join(lst))&emsp;&emsp; print(“\n”.join(lst))&emsp;&emsp; lst = [‘1’,[‘a’,’b’],’3’] # 复杂结构列表&emsp;&emsp; print(“ “.join(lst)) # TypeError: sequence item 1: expected str instance, list found 字符串+连接 + -&gt; str 将2个字符串连接在一起 返回一个新字符串 字符串分割 分割字符串的方法分为2类 split系 将字符串按照分隔符分割成若干字符串，并返回列表 partition系 将字符串按照分隔符分割成2段，返回这2段和分隔符的元组 字符串分割* split(sep=None, maxsplit=-1) -&gt; list of strings 从左至右 sep 指定分割字符串，缺省的情况下空白字符串作为分隔符 maxsplit 指定分割的次数，-1 表示遍历整个字符串 &emsp;&emsp; s1 = “I’m \ta super student.”&emsp;&emsp; s1.split()&emsp;&emsp; s1.split(‘s’)&emsp;&emsp; s1.split(‘super’)&emsp;&emsp; s1.split(‘super ‘)&emsp;&emsp; s1.split(‘ ‘)&emsp;&emsp; s1.split(‘ ‘,maxsplit=2)&emsp;&emsp; s1.split(‘\t’,maxsplit=2) 字符串分割 rsplit(sep=None, maxsplit=-1) -&gt; list of strings 从右向左 sep 指定分割字符串，缺省的情况下空白字符串作为分隔符 maxsplit 指定分割的次数，-1 表示遍历整个字符串 &emsp;&emsp; s1 = “I’m \ta super student.”&emsp;&emsp; s1.rsplit()&emsp;&emsp; s1.rsplit(‘s’)&emsp;&emsp; s1.rsplit(‘super’)&emsp;&emsp; s1.rsplit(‘super ‘)&emsp;&emsp; s1.rsplit(‘ ‘)&emsp;&emsp; s1.rsplit(‘ ‘,maxsplit=2)&emsp;&emsp; s1.rsplit(‘\t’,maxsplit=2) 字符串分割 splitlines([keepends]) -&gt; list of strings 按照行来切分字符串 keepends 指的是是否保留行分隔符 行分隔符包括\n、\r\n、\r等 &emsp;&emsp; ‘ab c\n\nde fg\rkl\r\n’.splitlines()&emsp;&emsp; ‘ab c\n\nde fg\rkl\r\n’.splitlines(True)&emsp;&emsp; s1 = ‘’’I’m a super student.&emsp;&emsp; You’re a super teacher.’’’&emsp;&emsp; print(s1)&emsp;&emsp; print(s1.splitlines())&emsp;&emsp; print(s1.splitlines(True)) 字符串分割* partition(sep) -&gt; (head, sep, tail) 从左至右，遇到分隔符就把字符串分割成两部分，返回头、分隔符、尾三部分的三元组；如果没有找到分隔符，就返回头、2个空元素的三元组 sep 分割字符串，必须指定 &emsp;&emsp; s1 = “I’m a super student.”&emsp;&emsp; s1.partition(‘s’)&emsp;&emsp; s1.partition(‘stu’)&emsp;&emsp; s1.partition(‘’) # ValueError: empty separator&emsp;&emsp; s1.partition(‘abc’) rpartition(sep) -&gt; (head, sep, tail) 从右至左，遇到分隔符就把字符串分割成两部分，返回头、分隔符、尾三部分的三元组；如果没有找到分隔符，就返回2个空元素和尾的三元组 字符串大小写 upper() 全大写 lower() 全小写 大小写，做判断的时候用 swapcase() 交互大小写 字符串排版 title() -&gt; str 标题的每个单词都大写 capitalize() -&gt; str 首个单词大写 center(width[, fillchar]) -&gt; str width 打印宽度 fillchar 填充的字符 zfill(width) -&gt; str width 打印宽度，居右，左边用0填充 ljust(width[, fillchar]) -&gt; str 左对齐 rjust(width[, fillchar]) -&gt; str 右对齐 中文用的少，了解一下 字符串修改* replace(old, new[, count]) -&gt; str 字符串中找到匹配替换为新子串，返回新字符串 count表示替换几次，不指定就是全部替换 &emsp;&emsp; ‘https://www.cnblogs.com&#39;.replace(&#39;w&#39;,&#39;p&#39;)&emsp;&emsp; ‘https://www.cnblogs.com&#39;.replace(&#39;w&#39;,&#39;p&#39;,2)&emsp;&emsp; ‘https://www.cnblogs.com&#39;.replace(&#39;w&#39;,&#39;p&#39;,3)&emsp;&emsp; ‘https://www.cnblogs.com&#39;.replace(&#39;ww&#39;,&#39;p&#39;,2)&emsp;&emsp; ‘https://www.cnblogs.com&#39;.replace(&#39;www&#39;,&#39;python&#39;,2) 字符串修改* strip([chars]) -&gt; str 从字符串两端去除指定的字符集chars中的所有字符 如果chars没有指定，去除两端的空白字符 &emsp;&emsp; s = “\r \n \t Hello Python \n \t”&emsp;&emsp; s.strip()&emsp;&emsp; s = “ I am very very very sorry “&emsp;&emsp; s.strip(‘Iy’)&emsp;&emsp; s.strip(‘Iy ‘) lstrip([chars]) -&gt; str 从左开始 rstrip([chars]) -&gt; str 从右开始 字符串查找* find(sub[, start[, end]]) -&gt; int 在指定的区间[start, end)，从左至右，查找子串sub。找到返回索引，没找到返回-1 rfind(sub[, start[, end]]) -&gt; int 在指定的区间[start, end)，从右至左，查找子串sub。找到返回索引，没找到返回-1 &emsp;&emsp; s = “I am very very very sorry”&emsp;&emsp; s.find(‘very’)&emsp;&emsp; s.find(‘very’, 5)&emsp;&emsp; s.find(‘very’, 6, 13)&emsp;&emsp; s.rfind(‘very’, 10)&emsp;&emsp; s.rfind(‘very’, 10, 15)&emsp;&emsp; s.rfind(‘very’,-10,-1) 字符串查找*与 find 的区别就是抛出异常 index(sub[, start[, end]]) -&gt; int 在指定的区间[start, end)，从左至右，查找子串sub。找到返回索引，没找到抛出异常ValueError rindex(sub[, start[, end]]) -&gt; int 在指定的区间[start, end)，从左至右，查找子串sub。找到返回索引，没找到抛出异常ValueError &emsp;&emsp; s = “I am very very very sorry”&emsp;&emsp; s.index(‘very’)&emsp;&emsp; s.index(‘very’, 5)&emsp;&emsp; s.index(‘very’, 6, 13)&emsp;&emsp; s.rindex(‘very’, 10)&emsp;&emsp; s.rindex(‘very’, 10, 15)&emsp;&emsp; s.rindex(‘very’,-10,-1) 字符串查找 时间复杂度 index和count方法都是O(n) 随着列表数据规模的增大，而效率下降 len(string) 返回字符串的长度，即字符的个数，O(1) 字符串查找 count(sub[, start[, end]]) -&gt; int 在指定的区间[start, end)，从左至右，统计子串sub出现的次数 &emsp;&emsp; s = “I am very very very sorry”&emsp;&emsp; s.count(‘very’)&emsp;&emsp; s.count(‘very’, 5)&emsp;&emsp; s.count(‘very’, 10, 14) 字符串判断* endswith(suffix[, start[, end]]) -&gt; bool 在指定的区间[start, end)，字符串是否是suffix结尾 startswith(prefix[, start[, end]]) -&gt; bool 在指定的区间[start, end)，字符串是否是prefix开头 &emsp;&emsp; s = “I am very very very sorry”&emsp;&emsp; s.startswith(‘very’)&emsp;&emsp; s.startswith(‘very’, 5)&emsp;&emsp; s.startswith(‘very’, 5, 9)&emsp;&emsp; s.endswith(‘very’, 5, 9)&emsp;&emsp; s.endswith(‘sorry’, 5)&emsp;&emsp; s.endswith(‘sorry’, 5, -1)&emsp;&emsp; s.endswith(‘sorry’, 5, 100) 字符串判断 is系列 isalnum() -&gt; bool 是否是字母和数字组成 isalpha() 是否是字母 isdecimal() 是否只包含十进制数字 isdigit() 是否全部数字(0~9) isidentifier() 是不是字母和下划线开头，其他都是字母、数字、下划线 islower() 是否都是小写 isupper() 是否全部大写 isspace() 是否只包含空白字符 字符串格式化 字符串的格式化是一种拼接字符串输出样式的手段，更灵活方便 join 拼接只能使用分隔符，且要求被拼接的是可迭代对象 + 拼接字符串还算方便，但是非字符串需要先转换为字符串才能拼接 在2.5版本之前，只能使用printf style风格的print输出 printf-style formatting，来自于C语言的printf函数 格式要求 占位符：使用%和格式字符组成，例如%s、%d等 s调用str()，r会调用repr()。所有对象都可以被这两个转换。 占位符中还可以插入修饰字符，例如%03d表示打印3个位置，不够前面补零 format % values，格式字符串和被格式的值之间使用%分隔 values只能是一个对象，或是一个和格式字符串占位符数目相等的元组 字符串格式化 printf-style formatting 举例 &emsp;&emsp; “I am %03d” % (20,)&emsp;&emsp; ‘I like %s.’ % ‘Python’&emsp;&emsp; ‘%3.2f%% , 0x%x, 0X%02X’ % (89.7654, 10, 15)&emsp;&emsp; “I am %-5d” % (20,)&emsp;&emsp; 3 是显示的最小总宽度，2 是小数点后的位数(如果可用的话)&emsp;&emsp; - 号表示左对齐，默认是有对齐. 字符串格式化*** format函数格式字符串语法——Python鼓励使用 “{} {xxx}”.format(*args, **kwargs) -&gt; str args是位置参数，是一个元组 kwargs是关键字参数，是一个字典 花括号表示占位符 {}表示按照顺序匹配位置参数，{n}表示取位置参数索引为n的值 {xxx}表示在关键字参数中搜索名称一致的 {{}} 表示打印花括号 字符串格式化*** 位置参数“{}:{}”.format(‘192.168.1.100’,8888)，这就是按照位置顺序用位置参数替换前面的格式字符串的占位符中 关键字参数或命名参数“{server} {1}:{0}”.format(8888, ‘192.168.1.100’, server=’Web Server Info : ‘) ，位置参数按照序号匹配，关键字参数按照名词匹配 访问元素“{0[0]}.{0[1]}”.format((‘github’,’com’)) 对象属性访问from collections import namedtuplePoint = namedtuple(‘Point’,’x y’)p = Point(4,5)“{{{0.x},{0.y}}}“.format(p) 有了这些字符串格式化方法，字符串拼接可以丢弃了。 字符串格式化*** 对齐‘{0}*{1}={2:&lt;2}’.format(3,2,2*3)‘{0}*{1}={2:&lt;02}’.format(3,2,2*3)‘{0}*{1}={2:&gt;02}’.format(3,2,2*3)‘{:^30}’.format(‘centered’)‘{:*^30}’.format(‘centered’) 进制“int: {0:d}; hex: {0:x}; oct: {0:o}; bin: {0:b}”.format(42)“int: {0:d}; hex: {0:#x}; oct: {0:#o}; bin: {0:#b}”.format(42)octets = [192, 168, 0, 1]‘{:02X}{:02X}{:02X}{:02X}’.format(octets)\ 是参数解构，分解为4个元素 字符串格式化***请使用format函数格式化字符串 字符串练习 用户输入一个数字 判断是几位数 打印每一位数字及其重复的次数 依次打印每一位数字，顺序个、十、百、千、万…位 1234567891011121314151617181920num = "" # 这里不写，下面的num也不会出错，在python作用域是能访问到的，但是不写不好while True: num = input("Please input a interger: ").strip() if num.isdigit(): num = int(num) # 把前导0也删除，或 lstrip('0') break else: print("Bad number.")count [0] * 10for i in range(10): count[i] = num.count(str(i))for i in range(10): if count[i]: print(i, count[i])lst = list(num)lst.reverse()print(lst) 输入5个数字，打印每个数字的位数，将这些数字排序打印，要求升序打印123456789lst = []for i in range(5): m = input("&gt;&gt;&gt;").strip().lstrip("0") print("这是&#123;&#125;位数".format(len(m))) lst.append(int(m))# print(sorted(lst))lst.sort()print(lst)]]></content>
      <categories>
        <category>python-magedu</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python全栈-magedu-2018-笔记4]]></title>
    <url>%2Fpython-magedu-2018-notes4.html</url>
    <content type="text"><![CDATA[第三章 - Python 内置数据结构元组tuple 一个有序的元素组成的集合 使用小括号 ( ) 表示 元组是不可变对象 元组的定义 初始化 定义 tuple() -&gt; empty tuple tuple(iterable) -&gt; tuple initialized from iterable’s item &emsp;&emsp; t = tuple() # 工厂方法，空元组是不能插入的&emsp;&emsp; t = ()&emsp;&emsp; t = tuple(range(1,7,2)) # iteratable&emsp;&emsp; t = (2,4,6,3,4,2)&emsp;&emsp; t = (1,) # 一个元素元组的定义，注意有个逗号&emsp;&emsp; t = (1,)*5&emsp;&emsp; t = (1,2,3) * 6&emsp;&emsp; 元组就像个只读列表，好处就是比列表占用空间少。&emsp;&emsp; t1 = (1, [2, 3], 4)&emsp;&emsp; t1[1][0] = 10 元组元素的访问 支持索引（下标） 正索引：从左至右，从0开始，为列表中每一个元素编号 负索引：从右至左，从-1开始 正负索引不可以超界，否则引发异常IndexError 元组通过索引访问 tuple[index] ，index就是索引，使用中括号访问 &emsp;&emsp; t[1]&emsp;&emsp; t[-2]&emsp;&emsp; t[1] = 5 元组查询 index(value,[start,[stop]]) 通过值value，从指定区间查找列表内的元素是否匹配 匹配第一个就立即返回索引 匹配不到，抛出异常ValueError count(value) 返回列表中匹配value的次数 时间复杂度 index和count方法都是O(n) 随着列表数据规模的增大，而效率下降 len(tuple) 返回元素的个数 元组其它操作 元组是只读的，所以增、改、删方法都没有 命名元组namedtuple 帮助文档中，查阅namedtuple，有使用例程 namedtuple(typename, field_names, verbose=False, rename=False) 命名元组，返回一个元组的子类，并定义了字段 field_names可以是空白符或逗号分割的字段的字符串，可以是字段的列表 &emsp;&emsp; from collections import namedtuple&emsp;&emsp; Point = namedtuple(‘_Point’,[‘x’,’y’]) # Point为返回的类&emsp;&emsp; p = Point(11, 22) &emsp;&emsp; Student = namedtuple(‘Student’, ‘name age’)&emsp;&emsp; tom = Student(‘tom’, 20)&emsp;&emsp; jerry = Student(‘jerry’, 18)&emsp;&emsp; tom.name 练习 依次接收用户输入的3个数，排序后打印 转换int后，判断大小排序。使用分支结构完成 使用max函数 使用列表的sort方法 冒泡法 冒泡法 冒泡法 属于交换排序 两两比较大小，交换位置。如同水泡咕嘟咕嘟往上冒 结果分为升序和降序排列 升序 n个数从左至右，编号从0开始到n-1，索引0和1的值比较，如果索引0大，则交换两者位置，如果索引1大，则不交换。继续比较索引1和2的值，将大值放在右侧。直至n-2和n-1比较完，第一轮比较完成。第二轮从索引0比较到n-2，因为最右侧n-1位置上已经是最大值了。依次类推，每一轮都会减少最右侧的不参与比较，直至剩下最后2个数比较。 降序 和升序相反 冒泡法 冒泡法代码实现（一） 简单冒泡实现 12345678910111213141516171819num_list = [ [1, 9, 8, 5, 6, 7, 4, 3 ,2], [1, 2, 3, 4, 5, 6, 7, 9, 8]]nums = num_list[1]print(nums)length = len(nums)count_swap = 0count = 0# bubble_sortfor i in range(length-1): # 要比较n-1趟 for j in range(length-i-1): # 每趟要比较的次数 count += 1 if nums[j] &gt; nums[j+1]: tmp = nums[j] nums[j] = nums[j+1] nums[j+1] = tmp count_swap += 1print(nums, count_swap, count) 冒泡法代码实现（二）12345678910111213141516171819202122232425num_list = [ [1, 9, 8, 5, 6, 7, 4, 3 ,2], [1, 2, 3, 4, 5, 6, 7, 8, 9], [1, 2, 3, 4, 5, 6, 7, 9, 8]]nums = num_list[2]print(nums)length = len(nums)count_swap = 0count = 0# bubble_sortfor i in range(length-1): # 要比较n-1趟 flag = False for j in range(length-i-1): # 每趟要比较的次数 count += 1 if nums[j] &gt; nums[j+1]: tmp = nums[j] nums[j] = nums[j+1] nums[j+1] = tmp flag = True # swapped count_swap += 1 if not flag: breakprint(nums, count_swap, count) 冒泡法总结 冒泡法需要数据一轮轮比较 可以设定一个标记判断此轮是否有数据交换发生，如果没有发生交换，可以结束排序，如果发生交换，继续下一轮排序 最差的排序情况是，初始顺序与目标顺序完全相反，遍历次数1,…,n-1之和n(n-1)/2 最好的排序情况是，初始顺序与目标顺序完全相同，遍历次数n-1 时间复杂度O(n2)]]></content>
      <categories>
        <category>python-magedu</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python全栈-magedu-2018-笔记3]]></title>
    <url>%2Fpython-magedu-2018-notes3.html</url>
    <content type="text"><![CDATA[第三章 - Python 内置数据结构分类 数值型 int、float、complex、bool 序列对象 字符串 str 列表 list tuple 键值对 集合set 字典dict 数值型 数值型 int、float、complex、bool都是class，1、5.0、2+3j都是对象即实例 int：python3的int就是长整型，且没有大小限制，受限于内存区域的大小 float：有整数部分和小数部分组成。支持十进制和科学计数法表示。只有双精度型。 complex：有实数和虚数部分组成，实数和虚数部分都是浮点数，3+4.2J bool：int的子类，仅有2个实例True、False对应1和0，可以和整数直接运算 类型转换（built-in） int(x) 返回一个整数 ，int是与类型名相同的内置转换函数，如果字符串不合法抛出异常 float(x) 返回一个浮点数 complex(x)、complex(x,y) 返回一个复数 bool(x) 返回布尔值，前面讲过False等价的对象 数字的处理函数 round()，四舍五入？六入四舍五取偶 math模块、floor()地板、天花板ceil() int() 、// 举例：&emsp; import math&emsp; print(math.floor(2.5), math.floor(-2.5))&emsp; print(math.ceil(2.5), math.ceil(-2.5)) &emsp; 以下打印什么结果？说明什么&emsp; print(int(-3.6), int(-2.5), int(-1.4))&emsp; print(int(3.6), int(2.5), int(1.4))&emsp; print(7//2, 7//-2, -7//2, -(7//2))&emsp; print(2//3, -2//3, -1//3)&emsp; print(round(2.5), round(2.5001), round(2.6))&emsp; print(round(3.5), round(3.5001), round(3.6), round(3.3))&emsp; print(round(-2.5), round(-2.5001), round(-2.6))&emsp; print(round(-3.5), round(-3.5001), round(-3.6), round(-3.3)) round()，四舍六入五取偶 floor()向下取整、ceil()向上取整 int() 取整数部分 // 整除且向下取整 min() max() pow(x,y) 等于 x**y math.sqrt() 进制函数，返回值是字符串 bin() oct() hex() math.pi π math.e 自如常数 类型判断 type(obj) ，返回类型，而不是字符串 isinstance(obj, class_or_tuple)，返回布尔值 举例： type(a) type(‘abc’) type(123) isinstance(6, str)、type(6) == str isinstance(6, (str, bool, int)) type(1+True) # bool型是int的子类 type(1+True+2.0) # 是什么？隐式转换 # 都是数值类型，往高精度转 列表 一个队列，一个排列整齐的队伍 列表内的个体称作元素，由若干元素组成列表 元素可以是任意对象（数字、字符串、对象、列表等） 列表内元素有顺序，可以使用索引 线性的数据结构 使用 [ ] 表示 列表是可变的 列表list、链表、queue、stack的差异 列表list定义 初始化赋值即定义，这也是静态语言和动态语言的区别。 list() -&gt; new empty list list(iterable) -&gt; new list initialized from iterable’s items 列表不能一开始就定义大小 &emsp;&emsp; lst = list()&emsp;&emsp; lst = []&emsp;&emsp; lst = [2, 6, 9, ‘ab’]&emsp;&emsp; lst = list(range(5)) 列表索引访问 索引，也叫下标 正索引：从左至右，从0开始，为列表中每一个元素编号 负索引：从右至左，从-1开始 正负索引不可以超界，否则引发异常IndexError 为了理解方便，可以认为列表是从左至右排列的，左边是头部，右边是尾部，左边是下界，右边是上界 列表通过索引访问 list[index] ，index就是索引，使用中括号访问 列表查询 index(value,[start,[stop]]) 通过值value，从指定区间查找列表内的元素是否匹配 匹配第一个就立即返回索引 匹配不到，抛出异常ValueError count(value) 返回列表中匹配value的次数 时间复杂度 index和count方法都是O(n) 随着列表数据规模的增大，而效率下降 如何返回列表元素的个数？如何遍历？如何设计高效？ len() # 是序列共有的函数，不是list类的方法函数 如何查帮助 官方帮助文档 搜索关键字 IPython中 help(keyword) keyword可以是变量、对象、类名、函数名、方法名 列表元素修改 索引访问修改 list[index] = value 索引不要超界 列表增加、插入元素 append(object) -&gt; None 列表尾部追加元素，返回None 返回None就意味着没有新的列表产生，就地修改 时间复杂度是O(1)，因为直接可以索引到结尾添加 insert(index, object) -&gt; None 在指定的索引index处插入元素object 返回None就意味着没有新的列表产生，就地修改 时间复杂度是O(n)，因为会调整内存布局 索引能超上下界吗？ 超越上界，尾部追加 超越下界，头部追加 列表增加、插入元素 extend(iteratable) -&gt; None 将可迭代对象的元素追加进来，返回None 就地修改 + -&gt; list 连接操作，将两个列表连接起来 产生新的列表，原列表不变 本质上调用的是add()方法 * -&gt; list 重复操作，将本列表元素重复n次，返回新的列表 列表 *重复的坑 * -&gt; list 重复操作，将本列表元素重复n次，返回新的列表 &emsp;&emsp; x = [[1,2,3]]*3&emsp;&emsp; print(x)&emsp;&emsp; x[0][1] = 20&emsp;&emsp; print(x) &emsp;&emsp; y = [1]*5&emsp;&emsp; y[0] = 6&emsp;&emsp; y[1] = 7&emsp;&emsp; print(y)&emsp;&emsp; 上面代码运行结果是什么？为什么？ 列表删除元素 remove(value) -&gt; None 从左至右查找第一个匹配value的值，移除该元素，返回None 就地修改 效率？ pop([index]) -&gt; item 不指定索引index，就从列表尾部弹出一个元素 指定索引index，就从索引处弹出一个元素，索引超界抛出IndexError错误 效率？指定索引的的时间复杂度？不指定索引呢？ clear() -&gt; None 清除列表所有元素，剩下一个空列表（一批元素不要，可能会引起垃圾回收gc） 列表其它操作 reverse() -&gt; None 将列表元素反转，返回None 就地修改 sort(key=None, reverse=False) -&gt; None 只写一个参数，匹配的是第一个参数，要匹配第二个参数，要指明参数名字，这么写 lst.sort(reverse=True) 对列表元素进行排序，就地修改，默认升序 reverse为True，反转，降序 key一个函数，指定key如何排序 lst.sort(key=functionname) in [3,4] in [1, 2, [3,4]] for x in [1,2,3,4] not in 列表复制 先看一段代码 &emsp;&emsp; lst0 = list(range(4))&emsp;&emsp; lst2 = list(range(4))&emsp;&emsp; print(lst0 == lst2)&emsp;&emsp; lst1 = lst0&emsp;&emsp; lst1[2] = 10&emsp;&emsp; print(lst0) &emsp;&emsp; lst0 == lst2相等吗？为什么？lst0里面存的是什么？&emsp;&emsp; == 比较的是对象的内容 (True)&emsp;&emsp; is 比较的是对象的地址 (False) 即 id(lst0) == id(lst2)&emsp;&emsp; 这里虽然都是创建 list(range(4)) 这个对象，解释器并没有优化为只创建一个 &emsp;&emsp; 请问lst0的索引为2的元素的值是什么？&emsp;&emsp; 请问lst1 = lst0这个过程中有没有复制过程？ 列表复制 copy() -&gt; List shadow copy返回一个新的列表 &emsp;&emsp; lst0 = list(range(4))&emsp;&emsp; lst5 = lst0.copy()&emsp;&emsp; id(lst0) 和 id(lst5) 是不同的 ，与 lst5=lst0 还是不一样的&emsp;&emsp; copy是把原列表的item复制到一个片新内存，创建一个新列表&emsp;&emsp; print(lst5 == lst0)&emsp;&emsp; lst5[2] = 10&emsp;&emsp; print(lst5 == lst0)&emsp;&emsp; lst0和lst5一样吗？ 对比前面程序的差别 &emsp;&emsp; lst0 = [1, [2, 3, 4], 5]&emsp;&emsp; lst5 = lst0.copy()&emsp;&emsp; lst5 == lst0&emsp;&emsp; lst5[2] = 10&emsp;&emsp; lst5 == lst0&emsp;&emsp; lst5[2] = 5&emsp;&emsp; lst5[1][1] = 20&emsp;&emsp; lst5 == lst0&emsp;&emsp; list中间元素是个复杂元素，所以copy时只拷贝了它的引用，即它的地址。所以在一边修改之后，另一边也一同修改了。 列表复制 shadow copy 影子拷贝，也叫浅拷贝，遇到引用类型，只是复制了一个引用而已 深拷贝 copy模块提供了deepcopy &emsp;&emsp;&emsp;&emsp; import copy&emsp;&emsp;&emsp;&emsp; lst0 = [1, [2, 3, 4], 5]&emsp;&emsp;&emsp;&emsp; lst5 = copy.deepcopy(lst0)&emsp;&emsp;&emsp;&emsp; lst5[1][1] = 20&emsp;&emsp;&emsp;&emsp; lst5 == lst0 随机数 random模块 randint(a, b) 返回[a, b]之间的整数 choice(seq) 从非空序列的元素中随机挑选一个元素，比如random.choice(range(10))，从0到9中随机挑选一个整数。random.choice([1,3,5,7]) randrange ([start,] stop [,step]) 从指定范围内，按指定基数递增的集合中获取一个随机数，基数缺省值为1。 random.randrange(1,7,2) random.shuffle(list) -&gt;None 就地打乱列表元素 sample(population, k) 从样本空间或总体（序列或者集合类型）中随机取出k个不同的元素，返回一个新的列表 random.sample([‘a’, ‘b’, ‘c’, ‘d’], 2) random.sample([‘a’, ‘a’], 2) 会返回什么结果]]></content>
      <categories>
        <category>python-magedu</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python全栈-magedu-2018-笔记2]]></title>
    <url>%2Fpython-magedu-2018-notes2.html</url>
    <content type="text"><![CDATA[第二章 - Python 基础语法基本语法 注释 —— # 标注的文本 数字 整数，不区分long和int 进制0xa、0o10、0b10 bool，2个值True、False 浮点数 1.2、3.1415、-0.12，1.46e9等价于1.46*109 复数，1+2j 字符串 使用 ‘ “ 单双引号引用的字符的序列 ‘’’和””” 单双三引号，可以跨行、可以在其中自由的使用单双引号 在字符串前面加上r或者R前缀，表示该字符串不做特殊的处理 转义序列 \\ \t \r \n \&#39; \&quot; 前缀r，把里面的所有字符当普通字符对待 缩进 未使用C等语言的花括号，而是采用缩进的方式表示层次关系 约定使用4个空格缩进 续行 在行尾使用 \ 如果使用各种括号，认为括号内是一个整体，内部跨行不用 \ 标识符 一个名字，用来指代一个值 只能字母、下划线和数字 只能以字母或下划线开头 不能是python的关键字，例如def、class就不能作为标识符 Python是大小写敏感的 约定： 不允许使用中文 不允许使用歧义单词，例如class_ 在python中不要随便使用下划线开头的表示符 常量 一旦赋值就不能改变值的标识符 python中无法定义常量 字面常量 一个单独的量，例如 12、”abc” 、’2341356514.03e-9’ 变量 赋值后，可以改变值的标识符 Python的语言类型 Python是动态语言、强类型语言 静态编译语言 实现声明变量类型，类型不能再改变 编译时检查 动态编译语言 不用事先声明类型，随时可以赋值为其他类型 编程时不知道是什么类型，很难推断 强类型语言 不同类型之间操作，必须先强制类型转换为同一类型。print(‘a’+1) 弱类型语言 不同类型间可以操作，自动隐式转换，JavaScript中console.log(1+’a’) 运算符 Operator 算数运算符 + - * / % ** 自然除/结果是浮点数，整除//。注：2.x中/和//都是整除 位运算符 &amp; | ~ ^ &lt;&lt; &gt;&gt; 常用方式：乘除2的倍数，32 // 4相当于 32 &gt;&gt; 2 12，0xc，0o14，0b1100 ~12等于多少，为什么 原码、反码、补码，负数表示法 原码 5 =&gt; 0b101，1 =&gt; 0b1 ，-1 =&gt; -0b1， bin(-1) 反码 正数的反码与原码相同；负数的反码符号位不变其余按位取反 补码 正数的补码与原码相同；负数的补码符号位不变其余按位取反后+1有符号数才用补码表示 负数表示法 数字电路的CPU中的运算器实现了加法器，但是没有减法器，减法是转换成加法 负数在计算机中使用补码存储，-1的补码为1111 1111 5-1 =&gt; 5+(-1)直觉上是0b101-0b1，其实计算机中是0b101+0b11111111，溢出位舍弃 ~12为什么是-13？ 10^9 等于？ 10^-9等于？为什么 &#160;&#160;&#160;&#160; 5 的补码 0000 0101&#160;&#160;&#160;&#160; -1 的原码 1000 0001&#160;&#160;&#160;&#160; -1 的补码 1111 1111 (0xff)&#160;&#160;&#160;&#160; 5-1得 0000 0100 &#160;&#160;&#160;&#160; 12 的补码 0000 1100&#160;&#160;&#160;&#160; ~12 是 1111 0011&#160;&#160;&#160;&#160; 怎么从补码得到原码？&#160;&#160;&#160;&#160; 与得到补码是一样的，最高位不变，其他位取反加一，即补码的补码就是原码&#160;&#160;&#160;&#160; 1000 1101 (即-13) 比较运算符 == != &gt; &lt; &gt;= &lt;= 返回一个bool值 1 &lt; ‘1’ &#160; 报错 &#160;&#160;&#160;&#160;&#160; 1 == ‘1’ &#160; False == 是可以不同类型比较的，除非 大于、小于等做类型重载，不然是不能比较的 链式比较操作符 4&gt;3&gt;2 &#160;&#160;&#160;&#160;&#160; 4&gt;mynumber&gt;=1 逻辑运算符 与或非 and or not 短路运算符 and 如果第一个表达式为False，后面就没有必要计算了，这个逻辑表达式一定是False or 如果第一个表达式True，后面没有必要计算了，这个逻辑表达式一定是True 赋值运算符 a = min(3,5) += -= *= /= %= 等 x = y = z = 10 尽量少用连等，因为如果右边是个引用就麻烦了 成员运算符 in、not in 身份运算符 is 、is not 运算符优先级（由高到低） 运算符 描述 ‘expr’ 字符串转换 {key:expr} 字典 [expr1, expr2, …] 列表 (expr1, expr2, …) 元组 function(expr, …) 函数调用 x[index:index] 切片 x[index] 下标索引值 x.attribute 属性引用 ~x 按位取反 +x, -x 正，负 x ** y 幂 x * y, x / y, x % y 乘法,除,取模 x + y, x - y 加，减 x &lt;&lt; y, x &gt;&gt; y 移位 x &amp; y 按位与 x ^ y 按位异或 x \ y 按位或 x &lt; y, x &lt;= y , x == y, x != y, x &gt;= y, x &gt; y 比较 x is y , x is not y 等同测试 x in y, x not in y 成员测试 not x 逻辑否 x and y 逻辑与 x or y 逻辑或 lambda arg, … : expr Lambda 匿名函数 算数运算符 &gt; 位运算符 &gt; 身份运算符 &gt; 成员运算符 &gt; 逻辑运算符 &gt; 赋值运算符 位运算符也可以看成算术运算 记不住，用括号 长表达式，多用括号，易懂、易读 表达式 Expression 由数字、符号、括号、变量等的组合 算数表达式 逻辑表达式 赋值表达式 Python中，赋值即定义，如果一个变量已经定义，赋值相当于重新定义 内存管理 变量无须事先声明，也不需要指定类型 动态语言的特性 编程中一般无须关心变量的存亡，也不用关心内存的管理 python使用引用计数记录所有对象的引用数 当对象引用数变为0，它就可以被 垃圾回收GC 计数增加： 赋值给其它变量就增加引用计数，例如x=3;y=x 计数减少： 函数运行结束时，局部变量就会被自动销毁，对象引用计数减少 变量被赋值给其它对象。例如x=3;y=x;x=4 有关性能的时候，就需要考虑变量的引用问题，但是该释放内存，还是尽量不释放内存，看需求 程序控制 顺序 按照先后顺序一条条执行 例如，先洗手，再吃饭，再洗碗 分支 根据不同的情况判断，条件满足执行某条件下的语句 例如，先洗手，如果饭没有做好，玩游戏，如果饭做好了，就吃饭，如果饭都没有做，叫外卖 循环 条件满足就反复执行，不满足就不执行或不再执行 例如，先洗手，看饭好了没有，没有好，一会来看一次是否好了，一会儿来看一次，直到饭好了，才可是吃饭。这里循环的条件是饭没有好，饭没有好，就循环的来看饭好了没有 单分支结构 if语句 if condition: 代码块 condition必须是一个bool类型，这个地方有一个隐式转换bool(condition) if 1&lt;2: &#160;&#160;&#160;&#160;print(‘1 less than 2’) 代码块 类似于if语句的冒号后面的就是一个语句块 在if、for、def、class等 真值表 对象/常量 值 “” 假 “string” 真 0 假 &gt;=1 真 &lt;=-1 真 ()空元组 假 []空列表 假 {}空字典 假 None 假 False等价布尔值，相当于bool(value) 空集合 空字符串 空字典 空列表 空元祖 None对象 0 多分支结构 if…elif…else语句&#160;&#160;&#160;&#160;if condition1:&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;代码块1&#160;&#160;&#160;&#160;elif condition2:&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;代码块2&#160;&#160;&#160;&#160;elif condition3:&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;代码块3&#160;&#160;&#160;&#160;……&#160;&#160;&#160;&#160;else:&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;代码块 举例&#160;&#160;&#160;&#160;a = 5&#160;&#160;&#160;&#160;if a&lt;0:&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;print(‘negative’)&#160;&#160;&#160;&#160;elif a==0:&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;print(‘zero’)&#160;&#160;&#160;&#160;else:&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;print(‘positive’) 分支嵌套 举例&#160;&#160;&#160;&#160;score = 80&#160;&#160;&#160;&#160;&#160;if score&lt;0:&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;print(‘wrong’)&#160;&#160;&#160;&#160;else:&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if score==0:&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;print(‘egg’)&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;elif score &lt;= 100:&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;print(‘right’)&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;else:&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;print(‘too big’) 嵌套结构，可以是分支、循环的嵌套 可以互相嵌套多层 练习：给定一个不超过5位的正整数，判断其有几位 使用 input 函数，input返回的是字符串 如果位数多的话可以用折半 num = 8if (num /= 10) == 0: &#160;&#160;&#160;&#160; 为什么这里报错&#160;&#160;&#160;&#160;print(‘1位数’) 循环——while语句 语法&#160;&#160;&#160;&#160;while condition:&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;block 当条件满足即condition为True，进入循环体，执行block 举例&#160;&#160;&#160;&#160;flag=10&#160;&#160;&#160;&#160;while flag:&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;print(flag)&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;flag -= 1 执行结果是什么？为什么？ 如果flag=-10可以吗？如何改造？ 循环——for语句* 语法 for element in iteratable:&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;block 当可迭代对象中有元素可以迭代，进入循环体，执行block range函数 举例：打印1~10&#160;&#160;&#160;&#160;for i in range(10):&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;print(i+1) 执行结果是什么？为什么？ 如果想倒序打印呢 循环 continue语句 中断当前循环的当次执行，继续下一次循环 举例：计算10以内的偶数（for循环）&#160;&#160;&#160;&#160;for i in range(10):&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if not i%2: &#160;&#160;&#160;&#160; # i%2==0这么写也行&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;print(i) 还有其它的实现吗？ &#160;&#160;&#160;&#160;for i in range(0,10,2):&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;print(i) &#160;&#160;&#160;&#160;for i in range(0,10):&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if i &amp; 1: &#160;&#160;&#160;&#160;# 或用 i%2 表示奇数就continue&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;continue&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;print(i) 循环 break语句 终止当前循环 举例：计算1000以内的被7整除的前20个数（for循环）&#160;&#160;&#160;&#160;count = 0&#160;&#160;&#160;&#160;for i in range(0,1000,7):&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;print(i)&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;count += 1&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if count &gt;= 20:&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;break 循环 continue、break语句 总结 continue和break是循环的控制语句，只影响当前循环，包括while、for循环 如果循环嵌套， continue和break也只影响语句所在的那一层循环 continue和break 不是跳出语句块，所以 if cond: break 不是跳出if，而是终止if外的break所在的循环 练习：给定一个不超过5位的正整数，判断该数的位数，依次打印出个位、十位、百位、千位、万位的数字 循环 else子句 语法&#160;&#160;&#160;&#160;while condition:&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;block&#160;&#160;&#160;&#160;else:&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;block&#160;&#160;&#160;&#160;for element in iteratable:&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;block&#160;&#160;&#160;&#160;else:&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;block 如果循环正常的执行结束，就执行else子句；如果使用break终止，else子句不会执行]]></content>
      <categories>
        <category>python-magedu</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python全栈-magedu-2018-笔记1]]></title>
    <url>%2Fpython-magedu-2018-notes1.html</url>
    <content type="text"><![CDATA[第一章 - Python概述、环境搭建操作系统准备准备Linux最小系统即可。 如果在虚拟机中克隆，MAC地址会变。 这里使用CentOS 6.5+ p 2.x和3.x区别 语句函数化，例如print(1,2)打印出1 2，但是2.x中意思是print语句打印元组，3.x中意思是函数的2个参数 整除，例如1/2和1//2，3.x版本中/为自然除 3.x中raw_input重命名为input，不再使用raw_input round函数，在3.x中i.5的取整变为距离最近的偶数 字符串统一使用Unicode 异常的捕获、抛出的语法改变 开发环境——Pyenv Python多版本管理工具 管理Python解释器 管理Python版本 管理Python的虚拟环境 官网 https://github.com/pyenv/pyenv Pyenv 安装 参照安装文档 pyenv的安装 python多版本安装 pyenv之global、shell、local的设置 pyenv的虚拟环境 更新：$ pyenv update 安装git 1yum install git -y 安装Python编译依赖 1yum -y install gcc make patch gdbm-devel openssl-devel sqlite-devel readline-devel zlib-devel bzip2-devel 创建用户python 12useradd python passwd python 使用python用户登录后安装Pyenv 1curl -L https://github.com/pyenv/pyenv-installer/raw/master/bin/pyenv-installer | bash 下载的 pyenv-installer 是一个shell脚本。注意： 在 https://github.com/pyenv/pyenv-installer 有安装文档Mac下pyenv与pyenv-virtualenv的安装和使用 如果curl出现 curl: (35) SSL connect error ，是nss版本低的问题，更新它。 可能需要配置一个有较新包的yum源 [updates] name=CentOS-Updates baseurl=https://mirrors.aliyun.com/centos/6.9/os/x86_64 gpgcheck=0 然后更新nss1yum update nss 在python用户的~/.bash_profile中追加 1234export PATH="/home/python/.pyenv/bin:$PATH" eval "$(pyenv init -)" eval "$(pyenv virtualenv-init -)" source ~/.bash_profile 这样当用户启动的时候，会执行用户的 .bash_profile 中的脚本，就会启动pyenv。 安装好的pyenv 就在~/.pyenv中 Pyenv 使用python 版本及path路径123python --version python -V echo $PATH 可以看到当前系统Python路径 pyenv 命令12pyenvpyenv help install 列出所有可用版本1pyenv install --list 安装指定版本12pyenv install 3.5.3 -v # 加 -v 可以看详细过程 verbosepyenv versions 会从python官网下载安装压缩包到 /tmp 目录，很慢，为了提速，可选用cache方法。 使用缓存方式安装在~/.pyenv目录下，新建cache目录，放入下载好的待安装版本的文件。 不确定要哪一个文件，把下载的3个文件都放进去。一般放 ‘tar.xz’ 包。1$ scp ~/Downloads/Python-3.5.3.tar.xz herodanny@10.211.55.6:~/.pyenv/cache 12pyenv install 3.5.3 -v# 编译安装下载的源文件 安装后的python文件夹在 .pyenv/versions 下。cache文件夹里有下载的压缩包。 pyenv 的 python版本控制version 显示当前的python版本 versions 显示所有可用的python版本，和当前版本。12pyenv versionpyenv versions global 全局设置pyenv global 3.5.3 可以看到所有受pyenv控制的窗口中都是3.5.3的python版本了。 这里用global是作用于非root用户python用户上，如果是root用户安装，请不要使用global，否则影响太大。比如，这里使用的CentOS6.5就是Python2.6，使用了global就成了3.x，会带来很不好的影响。 pyenv global system 回到原来系统版本。 shell 会话设置影响只作用于当前会话 pyenv shell 3.5.3是会话级的，一旦断开sessionid也变了，也不好用。 local 本地设置使用pyenv local设置从当前工作目录开始向下递归都继承这个设置。 123pyenv local 3.5.3python -V# 可能还是显示原来的版本，用pyenv version，要在虚拟环境中python -V 才会显示新的版本 也可以使用 anaconda，特别是 pyenv 不支持windows，pyenv 是自己下源码编，某些情况下可能不如 anaconda 直接编好的二进制分发。其实直接用 pycharm 就可以在 windows 或 linux 下创建虚拟环境。 Virtualenv 虚拟环境设置为什么要使用虚拟环境？ 因为刚才使用的Python环境都是一个公共的空间，如果多个项目使用不同Python版本开发，或者使用不同的Python版本部署运行，或者使用同样的版本开发的但不同项目使用了不同版本的库，等等这些问题都会带来冲突。最好的解决办法就是每一个项目独立运行自己的“独立小环境”中。 使用插件，在plugins/pyenv-virtualenv中pyenv virtualenv 3.5.3 mag353使用python3.5.3版本创建出一个独立的虚拟空间 mag353。 12345$ pyenv versions* system (set by /home/python/.pyenv/version)3.5.33.5.3/envs/mag353mag353 可以在版本列表中存在，就和3.5.3是一样的，就是一个版本了。以后只要使用这个虚拟版本，包就会按照到这些对应的目录下去，而不是使用3.5.3。可以看到真实的虚拟环境是下 envs/ 目录下。.pyenv/versions/ 下是软链接。 在需要设置python版本的文件夹路径下12pyenv local mag353pyenv versions 怎么会起作用的，是利用了当前目录下隐藏文件.python-version和在 .bash_profile 中添加的那几指令。 现在可以对python进行版本的管理，包的管理。 pip 包管理器 pip install xxx yyy pip list pip search keyword 或者 pypi pip help install pip install redis ipython pip install jupyter pip -V pip freeze &gt; requirement pip install -r requirement pip 是Python的包管理工具，3.x的版本直接带了，可以直接使用。 和yun一样为了使用国内镜像，如下配置。mkdir ~/.pip配置文件在 ~/.pip/pip.conf 123[global]index-url=https://mirrors.aliyun.com/pypi/simple/trusted-host=mirrors.aliyun.com 安装 ipythonipython 是增强的交互式 Python 命令行工具，增强的Python Shell，自动补全、自动缩进、支持shell，增加了很多函数12pip install ipython ipython ipython中提供了魔术方法，在代码(包括注释)最上面输入 %%timeit 可以测试运行时间。https://supergis.gitbooks.io/git_notebook/content/doc/jupyter_magics.html 安装 JupyterJupyter 是基于WEB的交互式笔记本，其中可以非常方便的使用Python。独立的交互式笔记本，后台使用Ipython。安装Jupyter，也会安装ipython的。 12345pip/pip3 install jupyterjupyter notebook helpjupyter notebook password # 设置下浏览器访问时的密码jupyter notebook --ip=0.0.0.0 --no-browserss -tanl 浏览器不能访问是服务器端防火墙问题。 Jupyter Notebook基本操作https://jupyter-notebook.readthedocs.io/en/latest/index.html在服务器上配置jupyter设置远程登录Jupyter开发环境搭建 快捷键：shift + enter(运行)、ctrl + enter(运行)、dd(删除一行)、m(用mardkown)。在 jupyter 中也是可以运行 js 代码的。第一行先输入 %%js。_ 表示上次输出的结果。可使用 print() 看看。在python中也表示不关心的变量。 导出包虚拟环境的好处就在于和其他项目运行环境隔离。每一个独立的环境都可以使用pip命令导出已经安装的包，在另一个环境中安装这些包。 123456789(mag353) [python@node web]$ pip freeze &gt; requirement(mag353) [python@node web]$ mkdir ~/magedu/projects/pro1(mag353) [python@node web]$ cd ~/magedu/projects/pro1[python@node pro1]$ pyenv install --list[python@node pro1]$ pyenv install 3.6.4[python@node pro1]$ pyenv virtualenv 3.6.4 mag364[python@node pro1]$ pyenv local mag364(mag364) [python@node pro1]$ mv ../web/requirement ./(mag364) [python@node pro1]$ pip install -r requirement]]></content>
      <categories>
        <category>python-magedu</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[用VsCode写Markdown]]></title>
    <url>%2Fvscode-write-markdown.html</url>
    <content type="text"><![CDATA[Markdown 基本语法段落非常自然，一行文字就是一个段落。 比如： 这是一个段落 会被解释成： 1&lt;p&gt;这是一个段落。&lt;/p&gt; 如果你需要另起一段，请在两个段落之间隔一个空行。 这是一个段落。 这是另一个段落。 会被解释成 123&lt;p&gt;这是一个段落&lt;/p&gt;&lt;p&gt;这是另一个段落&lt;/p&gt; 不隔一个空行的换行行为，在一些编辑器中被解释为换行，即插入一个标签。对与另外一些编辑器，会被解释为插入一个空格。对于后者，若要插入换行标签，请在当前一行的结尾打两个空格。(vscode 就是后者，typora 普通模式是前者，源码模式和 vscode 一样是后者) 没用空一行，在结尾打两个空格的换行，还在一个段落中。 粗体、斜体可以使用星号*或下划线_指定粗体或者斜体。 *这是斜体* _这也是斜体_ **这是粗体** ***这是粗体+斜体*** 会被解释成 1234&lt;em&gt;这是斜体&lt;/em&gt;&lt;em&gt;这也是斜体&lt;/em&gt;&lt;strong&gt;这是粗体&lt;/strong&gt;&lt;strong&gt;&lt;em&gt;这是粗体+斜体&lt;/strong&gt;&lt;/em&gt; 删除线一部分编辑器支持删除线，它不是经典 markdown 中的要素。用波浪线~定义删除线。 ~~就像这样~~ 会被解释成 1&lt;strike&gt;就像这样&lt;/strike&gt; 标题markdown 总支持 1~6 六级标题，通过在一行之前加上不同数量的井号来表示。 # 这是 H1 # ## 这是 H2 ## ### 这是 H3 ### ... ###### 这是 H6 ###### 行尾可以加上任意数量的井号字符，这些字符不会算作标题内容。通常会加上相等数量的字符以保持对称。 此外，H1 和 H2 也可以采用在文本下方添加底线来实现，比如： 这是 H1 ======= 这是 H2 ------- 引用通过在行首加上大于号&gt;来添加引用格式。 &gt; This is a blockquote with two paragraphs. Lorem ipsum dolor sit amet, consectetuer adipiscing elit. Aliquam hendrerit mi posuere lectus. Vestibulum enim wisi, viverra nec, fringilla in, laoreet vitae, risus. &gt; Donec sit amet nisl. Aliquam semper ipsum sit amet velit. Suspendisse id sem consectetuer libero luctus adipiscing. This is a blockquote with two paragraphs. Lorem ipsum dolor sit amet,consectetuer adipiscing elit. Aliquam hendrerit mi posuere lectus.Vestibulum enim wisi, viverra nec, fringilla in, laoreet vitae, risus. Donec sit amet nisl. Aliquam semper ipsum sit amet velit. Suspendisseid sem consectetuer libero luctus adipiscing. 引用可以嵌套： &gt; This is the first level of quoting. &gt; &gt; &gt; This is nested blockquote. &gt; &gt; Back to the first level. This is the first level of quoting. This is nested blockquote. Back to the first level. 也可以嵌套其他格式： &gt; ## 这是一个标题。 &gt; &gt; 1. 这是第一行列表项。 &gt; 2. 这是第二行列表项。 &gt; &gt; 给出一些例子代码： &gt; &gt; return shell_exec(&quot;echo $input | $markdown_script&quot;); 这是一个标题。 这是第一行列表项。 这是第二行列表项。 给出一些例子代码： return shell_exec(&quot;echo $input | $markdown_script&quot;); 列表无序列表使用星号、加号或是减号作为列表标记： * Red * Green * Blue Red Green Blue 等同于 + Red + Green + Blue 和 - Red - Green - Blue 有序列表则使用数字接着一个英文句点： 1. Bird 2. McHale 3. Parish Bird McHale Parish 内敛代码用反引号 ` 来标记内联代码，它们会解释成 &lt;code&gt; 标签。如果代码的内容中有反引号，请用两个反引号包裹。 代码区域有两种方式标记代码区域，原生风格是行首缩进四个空格。 这是一个普通段落： 这是一个代码区块。 会被解释成 &lt;p&gt;这是一个普通段落：&lt;/p&gt; &lt;pre&gt;&lt;code&gt;这是一个代码区块。 &lt;/code&gt;&lt;/pre&gt; 分隔线你可以在一行中用三个以上的星号、减号、底线来建立一个分隔线，行内不能有其他东西。你也可以在星号或是减号中间插入空格。下面每种写法都可以建立分隔线： 12345* * *********- - ---------------------------------------- 链接[an example](http://example.com/) [an example](http://example.com/ &quot;Optional Title&quot;) 会被解释为 &lt;a href=&apos;http://example.com/&apos;&gt;an example&lt;/a&gt; &lt;a href=&apos;http://example.com/&apos; title=&quot;Optional Title&quot;&gt;an example&lt;/a&gt; 除了上面的行内式，也可以使用参考式： [an example][id] 然后在任意空白位置定义： [id]: http://example.com/ &quot;Optional Title&quot; 图像![Alt text](/path/to/img.jpg) ![Alt text](/path/to/img.jpg &quot;Optional Title&quot;) 会被解释为 &lt;img src=&apos;/path/to/img.jpg&apos; alt=&apos;Alt text&apos; /&gt; &lt;img src=&apos;/path/to/img.jpg&apos; alt=&apos;Alt text&apos; title=&apos;Optional Title&apos; /&gt; 同样，图像也有类似的参考式语法。 自动链接如果链接的地址和名字重复，可以用尖括号语法将其简化。 &lt;http://example.com/&gt; 就相当于 [http://example.com/](http://example.com/) 切记，大多数编辑器都会自动将符合url规则的东西视为链接，并且解释成链接。很多时候作者由于疏忽等缘故，链接和后面的中文之间缺少空格，导致链接不正常。所以我建议，链接要么加上尖括号，要么两端加上空格。 转义markdown支持在以下字符前面插入反斜杠 \ 反斜线 ` 反引号 * 星号 _ 底线 {} 花括号 [] 方括号 () 括弧 # 井字号 + 加号 - 减号 . 英文句点 ! 惊叹号 表格| Item | Value | Qty | | :------- | ----: | :---: | | Computer | $1600 | 5 | | Phone | $12 | 12 | | Pipe | $1 | 234 | 会被解释成 123456789101112131415161718192021222324&lt;table&gt;&lt;thead&gt;&lt;tr&gt; &lt;th align="left"&gt;Item&lt;/th&gt; &lt;th align="right"&gt;Value&lt;/th&gt; &lt;th align="center"&gt;Qty&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt; &lt;td align="left"&gt;Computer&lt;/td&gt; &lt;td align="right"&gt;$1600&lt;/td&gt; &lt;td align="center"&gt;5&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt; &lt;td align="left"&gt;Phone&lt;/td&gt; &lt;td align="right"&gt;$12&lt;/td&gt; &lt;td align="center"&gt;12&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt; &lt;td align="left"&gt;Pipe&lt;/td&gt; &lt;td align="right"&gt;$1&lt;/td&gt; &lt;td align="center"&gt;234&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt; 要注意第二行的冒号决定了居左居右还是居中，如果你不加冒号，默认是居左的。 另外可以把第一行去掉，做成没有表头的表格，但第二行始终是要有的。 内联 HTMLmarkdown 的语法简洁，但有其局限性，所以特意保留了内联html这种方式。任何html标签及其内容，都会原样输出到结果中。也就是说，标签中的星号等作为markdown结构的符号，以及构成html标签和实体的符号，都不会做任何转义。 vscode markdown 扩展Markdown All in OneMarkdown Shortcuts]]></content>
      <categories>
        <category>before-development</category>
      </categories>
      <tags>
        <tag>markdown</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[my blog test]]></title>
    <url>%2Fmy-blog-test.html</url>
    <content type="text"><![CDATA[Anima Anima allows you to query database like SQL and Stream.a simple DSL syntax, supports multiple databases, integrates well with Java8,supports multiple relational mappings, and is a database manipulation tool. Document Feature Simple DSL H2、MySQL、SQLite、PostgreSQL、Oracle、SqlServer Paging support Flexible configuration Connection pool support Support LocalDate、LocalDateTime Support lambda expression Relationship (hasOne、hasMany、belongsTo) SQL performance statistics Based Java8 UsageLatest snapshot version If you want to prioritize new features or some BUG fixes you can use it, you need to specify the snapshot repository in pom.xml 12345678910111213141516&lt;repository&gt; &lt;id&gt;snapshots-repo&lt;/id&gt; &lt;url&gt;https://oss.sonatype.org/content/repositories/snapshots&lt;/url&gt; &lt;releases&gt; &lt;enabled&gt;false&lt;/enabled&gt; &lt;/releases&gt; &lt;snapshots&gt; &lt;enabled&gt;true&lt;/enabled&gt; &lt;/snapshots&gt;&lt;/repository&gt;&lt;dependency&gt; &lt;groupId&gt;io.github.biezhi&lt;/groupId&gt; &lt;artifactId&gt;anima&lt;/artifactId&gt; &lt;version&gt;0.2.4-SNAPSHOT&lt;/version&gt;&lt;/dependency&gt; Here’s the RELEASE version. As Gradle 1compile 'io.github.biezhi:anima:0.2.3' As Maven 12345&lt;dependency&gt; &lt;groupId&gt;io.github.biezhi&lt;/groupId&gt; &lt;artifactId&gt;anima&lt;/artifactId&gt; &lt;version&gt;0.2.2&lt;/version&gt;&lt;/dependency&gt; 📒 Although Anima can also be used by adding a jar package, we do not recommend doing this. ExamplesOpen Connection 12345678910111213141516// MySQLAnima.open("jdbc:mysql://127.0.0.1:3306/demo", "root", "123456");// SQLiteAnima.open("jdbc:sqlite:./demo.db");// H2Anima.open("jdbc:h2:file:~/demo;FILE_LOCK=FS;PAGE_SIZE=1024;CACHE_SIZE=8192", "sa", "");// DataSourceDruidDataSource dataSource = new DruidDataSource();dataSource.setDriverClassName("com.mysql.jdbc.Driver");dataSource.setUrl(blade.environment().getOrNull("jdbc.url"));dataSource.setUsername(blade.environment().getOrNull("jdbc.username"));dataSource.setPassword(blade.environment().getOrNull("jdbc.password"));Anima.open(dataSource); 📕 This operation only needs one time 123456789101112131415public class User extends Model &#123; private Integer id; private String userName; private Integer age; public User() &#123; &#125; public User(String userName, Integer age) &#123; this.userName = userName; this.age = age; &#125; &#125; Table Structure 12345CREATE TABLE `users` ( `id` IDENTITY PRIMARY KEY, `user_name` varchar(50) NOT NULL, `age` int(11)) Query123456789101112131415161718192021long count = select().from(User.class).count();// SELECT COUNT(*) FROM userslong count = select().from(User.class).where("age &gt; ?", 15).isNotNull("user_name").count();// SELECT COUNT(*) FROM users WHERE age &gt; ? AND user_name IS NOT NULLUser user = select().from(User.class).byId(2);// SELECT * FROM users WHERE id = ?List&lt;User&gt; users = select().from(User.class).byIds(1, 2, 3);// SELECT * FROM users WHERE id IN (?, ?, ?)String name = select().bySQL(String.class, "select user_name from users limit 1").one();List&lt;String&gt; names = select().bySQL(String.class, "select user_name from users limit ?", 3);List&lt;User&gt; users = select().from(User.class).all();// SELECT * FROM usersList&lt;User&gt; users = select().from(User.class).like("user_name", "%o%").all();// SELECT * FROM users WHERE user_name LIKE ? Limit 12List&lt;User&gt; users = select().from(User.class).order("id desc").limit(5);// SELECT * FROM users ORDER BY id desc Paging 12Page&lt;User&gt; userPage = select().from(User.class).order("id desc").page(1, 3);// SELECT * FROM users ORDER BY id desc LIMIT ?, ? Map 1select().from(User.class).map(User::getUserName).limit(3).collect(Collectors.toList()); Filter 1select().from(User.class).filter(u -&gt; u.getAge() &gt; 10).collect(Collectors.toList()); Lambda 12User user = select().from(User.class).where(User::getUserName).eq("jack").one();// SELECT * FROM users WHERE user_name = ? 12345List&lt;User&gt; user = select().from(User.class) .where(User::getUserName).notNull() .and(User::getAge).gt(10) .all();// SELECT * FROM users WHERE user_name IS NOT NULL AND age &gt; ? 12select().from(User.class).order(User::getId, OrderBy.DESC).order(User::getAge, OrderBy.ASC).all();// SELECT * FROM users ORDER BY id DESC, age ASC Join 1234567891011121314151617181920@Table(name = "order_info")@Datapublic class OrderInfo extends Model &#123; private Long id; private Integer uid; @Column(name = "productname") private String productName; private LocalDateTime createTime; @Ignore private User user; @Ignore private Address address;&#125; 1234567891011121314151617181920212223242526272829// HasOneOrderInfo orderInfo = select().from(OrderInfo.class) .join( Joins.with(Address.class).as(OrderInfo::getAddress) .on(OrderInfo::getId, Address::getOrderId) ).byId(3);orderInfo = select().from(OrderInfo.class) .join( Joins.with(Address.class).as(OrderInfo::getAddress) .on(OrderInfo::getId, Address::getOrderId) ) .join( Joins.with(User.class).as(OrderInfo::getUser) .on(OrderInfo::getUid, User::getId) ).byId(3);// ManyToOneorderInfo = select().from(OrderInfo.class) .join( Joins.with(User.class).as(OrderInfo::getUser) .on(OrderInfo::getUid, User::getId) ).byId(3);// OneToManyUserDto userDto = select().from(UserDto.class).join( Joins.with(OrderInfo.class).as(UserDto::getOrders) .on(UserDto::getId, OrderInfo::getUid) ).byId(1); Insert12Integer id = new User("biezhi", 100).save().asInt();// INSERT INTO users(id,user_name,age) VALUES (?,?,?) or 1Anima.save(new User("jack", 100)); Batch Save 12345List&lt;User&gt; users = new ArrayList&lt;&gt;();users.add(new User("user1", 10));users.add(new User("user2", 11));users.add(new User("user3", 12));Anima.saveBatch(users); 📘 This operation will begin a transaction and rollback when there is a transaction that is unsuccessful. Update12int result = update().from(User.class).set("user_name", newName).where("id", 1).execute();// UPDATE users SET username = ? WHERE id = ? or 12int result = update().from(User.class).set("user_name", newName).where("id", 1).execute();// UPDATE users SET user_name = ? WHERE id = ? or 12345User user = new User();user.setId(1);user.setUserName("jack");user.update();// UPDATE users SET user_name = ? WHERE id = ? 1update().from(User.class).set(User::getUserName, "base64").updateById(2); 1update().from(User.class).set(User::getUserName, "base64").where(User::getId).eq(2).execute(); Delete12int result = delete().from(User.class).where("id", 1).execute();// DELETE FROM users WHERE id = ? or 12345User user = new User();user.setAge(15);user.setUserName("jack");user.delete();// DELETE FROM users WHERE user_name = ? and age = ? 123delete().from(User.class).where(User::getId).deleteById(3);delete().from(User.class).where(User::getId).eq(1).execute();delete().from(User.class).where(User::getAge).lte(20).execute(); Transaction1234Anima.atomic(() -&gt; &#123; int a = 1 / 0; new User("apple", 666).save();&#125;).catchException(e -&gt; Assert.assertEquals(ArithmeticException.class, e.getClass())); 📗 Anima uses the atomic method to complete a transaction. normally, the code will not throw an exception.when a RuntimeException is caught, the transaction will be rollback. Test CodeSee here LicenseApache2]]></content>
      <categories>
        <category>test</category>
        <category>tools</category>
      </categories>
      <tags>
        <tag>test</tag>
        <tag>java</tag>
        <tag>markdown</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[my first blog article]]></title>
    <url>%2Fmy-first-blog-article.html</url>
    <content type="text"><![CDATA[一级标题二级标题三级标题无序列表 我的技术小黑屋 不会写代码的菜鸟 我要返回火星了 有序列表 我们都是地球人 为啥你就不会 markdown? 看完还不会就要被安排 链接的写法我的技术小屋 带 Title我的技术小屋 图片 带 Title 引用方式  世界依旧很大,大到只能胡说。  面朝大海，春暖花开 从明天起，做一个幸福的人喂马、劈柴，周游世界从明天起，关心粮食和蔬菜我有一所房子，面朝大海，春暖花开从明天起，和每一个亲人通信告诉他们我的幸福那幸福的闪电告诉我的我将告诉每一个人给每一条河每一座山取一个温暖的名字陌生人，我也为你祝福愿你有一个灿烂的前程愿你有情人终成眷属愿你在尘世获得幸福我只愿面朝大海，春暖花开 粗体 粗体 看，我斜了没 真的很斜 粗体＋斜体 此处的故事只能用泪水掩盖 群里单身女生名单 姓名 年龄 三围 罗欲凤 18 18, 27, 30 秋刀鱼 26 28, 25, 33 窝不行 22 23, 28, 35 单行代码引用 123456789package mainimport "fmt"func main()&#123; fmt.Println("我的技术小屋");&#125; 分割线]]></content>
      <categories>
        <category>test</category>
        <category>tools</category>
      </categories>
      <tags>
        <tag>test</tag>
        <tag>markdown</tag>
      </tags>
  </entry>
</search>
