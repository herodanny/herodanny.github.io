<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>从菜鸟到老鸟</title>
  
  <subtitle>From Zero To Hero</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://herodanny.github.io/"/>
  <updated>2019-05-19T12:56:20.479Z</updated>
  <id>https://herodanny.github.io/</id>
  
  <author>
    <name>herodanny</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>python全栈-magedu-2018-笔记24</title>
    <link href="https://herodanny.github.io/python-magedu-2018-notes24.html"/>
    <id>https://herodanny.github.io/python-magedu-2018-notes24.html</id>
    <published>2019-05-18T14:39:58.000Z</published>
    <updated>2019-05-19T12:56:20.479Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第十七章-文件操作"><a href="#第十七章-文件操作" class="headerlink" title="第十七章 - 文件操作"></a>第十七章 - 文件操作</h1><h2 id="冯诺伊曼体系架构"><a href="#冯诺伊曼体系架构" class="headerlink" title="冯诺伊曼体系架构"></a>冯诺伊曼体系架构</h2><p><img src="https://raw.githubusercontent.com/herodanny/Image-Hosting/master/data/fengnuoyiman.jpg" alt="fengnuoyiman"></p><ul><li>CPU由运算器和控制器组成<ul><li>运算器，完成各种算数运算、逻辑运算、数据传输等数据加工处理</li><li>控制器，控制程序的执行</li><li>存储器，用于记忆程序和数据，例如内存</li><li>输入设备，将数据或者程序输入到计算机中，例如键盘、鼠标</li><li>输出设备，将数据或程序的处理结果展示给用户，例如显示器、打印机等</li></ul></li></ul><p>一般说IO操作，指的是文件IO，如果指网络IO，都会直接说网络IO  </p><h2 id="文件-IO-常用操作"><a href="#文件-IO-常用操作" class="headerlink" title="文件 IO 常用操作"></a>文件 IO 常用操作</h2><p>open &emsp; &emsp; &emsp; 打开<br>read &emsp; &emsp; &emsp; 读取<br>write &emsp; &emsp; &emsp; 写入<br>close &emsp; &emsp; &emsp; 关闭<br>readline &emsp; &emsp; 行读取<br>readlines &emsp; &ensp; 多行读取<br>seek &emsp; &emsp; &emsp; 文件指针操作<br>tell &emsp; &emsp; &emsp; &ensp; 指针位置  </p><h2 id="open-打开操作"><a href="#open-打开操作" class="headerlink" title="open 打开操作"></a>open 打开操作</h2><p>open(file, mode=’r’, buffering=-1, encoding=None, errors=None, newline=None, closefd=True, opener=None)  </p><p>打开一个文件，返回一个文件对象（流对象）和文件描述符。打开文件失败，则返回异常。<br>基本使用：<br>创建一个文件test，然后打开它，用完<strong>关闭</strong>。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">f = open(<span class="string">"test"</span>) <span class="comment"># file对象，是Text IO对象  </span></span><br><span class="line"><span class="comment"># windows &lt;_io.TextIOWrapper name='test' mode='r' encoding='cp936'&gt;  </span></span><br><span class="line"><span class="comment"># linux &lt;_io.TextIOWrapper name='test' mode='r' encoding='UTF-8'&gt;  </span></span><br><span class="line">print(f.read()) <span class="comment"># 读取文件  </span></span><br><span class="line">f.close() <span class="comment"># 关闭文件</span></span><br></pre></td></tr></table></figure></p><p>文件操作中，最常用的操作就是读和写。<br>文件访问的模式有两种：文本模式和二进制模式。不同模式下，操作函数不尽相同，表现的结果也不一样。  </p><h2 id="open的参数"><a href="#open的参数" class="headerlink" title="open的参数"></a>open的参数</h2><p><strong>file</strong><br>打开或者要创建的文件名或是文件描述符。如果不指定路径，默认是当前路径。  </p><p><strong>mode模式</strong><br>|描述字符|意义|<br>|:–|:–|<br>|r|缺省的，表示只读打开|<br>|w|只写打开|<br>|x|创建并写入一个新文件|<br>|a|写入打开，如果文件存在，则追加|<br>|b|二进制模式|<br>|t|缺省的，文本模式|<br>|+|读写打开一个文件。给原来只读、只写方式打开提供缺失的读或写能力|</p><p>在上面的例子中，可以看到默认是文本打开模式，且是只读的。<br>文本的操作是对字符的操作。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># r模式  </span></span><br><span class="line">f = open(<span class="string">'test'</span>) <span class="comment"># 只读还是只写？  </span></span><br><span class="line">f.read()  </span><br><span class="line">f.write(<span class="string">'abc'</span>)  </span><br><span class="line">f.close()  </span><br><span class="line"></span><br><span class="line">f = open(<span class="string">'test'</span>, <span class="string">'r'</span>) <span class="comment"># 只读  </span></span><br><span class="line">f.write(<span class="string">'abc'</span>)  </span><br><span class="line">f.close()  </span><br><span class="line"></span><br><span class="line">f = open(<span class="string">'test1'</span>, <span class="string">'r'</span>) <span class="comment"># 只读，文件不存在  </span></span><br><span class="line"></span><br><span class="line"><span class="comment"># w模式  </span></span><br><span class="line">f = open(<span class="string">'test'</span>, <span class="string">'w'</span>) <span class="comment"># 只写打开  </span></span><br><span class="line">f.write(<span class="string">'abc'</span>)  </span><br><span class="line">f.close()  </span><br><span class="line"></span><br><span class="line">cat test <span class="comment"># 看看内容  </span></span><br><span class="line"></span><br><span class="line">f = open(<span class="string">'test'</span>, mode=<span class="string">'w'</span>)  </span><br><span class="line">f.close()  </span><br><span class="line"></span><br><span class="line">cat test <span class="comment"># 看看内容  </span></span><br><span class="line"></span><br><span class="line">f = open(<span class="string">'test1'</span>, mode=<span class="string">'w'</span>)  </span><br><span class="line">f.write(<span class="string">'123'</span>)  </span><br><span class="line">f.close()  </span><br><span class="line"></span><br><span class="line">cat test1 <span class="comment"># 看看内容</span></span><br></pre></td></tr></table></figure></p><p>open 默认是只读模式r打开已经存在的文件  </p><p><strong>r</strong><br>只读打开文件，如果使用write方法，会抛异常。<br>如果文件不存在，抛出FileNotFoundError异常。  </p><p><strong>w</strong><br>表示只写方式打开，如果读取则抛出异常<br>如果文件不存在，则直接创建文件<br>如果文件存在，则清空文件内容  </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">f = open(<span class="string">'test2'</span>, <span class="string">'x'</span>)  </span><br><span class="line">f.read() <span class="comment">#  </span></span><br><span class="line">f.write(<span class="string">'abcd'</span>)  </span><br><span class="line">f.close()  </span><br><span class="line"></span><br><span class="line">f = open(<span class="string">'test2'</span>, <span class="string">'x'</span>) <span class="comment">#</span></span><br></pre></td></tr></table></figure><p><strong>x</strong><br>文件不存在，创建文件，并只写方式打开<br>文件存在，抛出FileExistsError异常  </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">f = open(<span class="string">'test2'</span>, <span class="string">'a'</span>)  </span><br><span class="line">f.read() <span class="comment">#  </span></span><br><span class="line"></span><br><span class="line">f.write(<span class="string">'abcde'</span>)  </span><br><span class="line">f.close()  </span><br><span class="line"></span><br><span class="line">cat test2  </span><br><span class="line"></span><br><span class="line">f = open(<span class="string">'test2'</span>, <span class="string">'a'</span>)  </span><br><span class="line">f.write(<span class="string">'\n hello'</span>)  </span><br><span class="line">f.close()  </span><br><span class="line"></span><br><span class="line">cat test2  </span><br><span class="line"></span><br><span class="line">f = open(<span class="string">'test3'</span>, <span class="string">'a'</span>)  </span><br><span class="line">f.write(<span class="string">'test3'</span>)  </span><br><span class="line">f.close()</span><br></pre></td></tr></table></figure><p><strong>a</strong><br>文件存在，只写打开，追加内容<br>文件不存在，则创建后，只写打开，追加内容<br>所以，一般用a+，而不用w+  </p><p>r是只读，wxa都是只写。<br>wxa都可以产生新文件，w不管文件存在与否，都会生成全新内容的文件；a不管文件是否存在，都能在打开的文件尾部追加；x必须要求文件事先不存在，自己造一个新文件  </p><p><strong>文本模式t  (字符流)</strong><br>字符流，将文件的字节按照某种字符编码理解，并照字符操作。open的默认mode就是rt。  </p><p><strong>二进制模式b  (字节流)</strong><br>字节流，将文件就按照字节理解，与字符编码无关。二进制模式操作时，字节操作使用bytes类型  </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">f = open(<span class="string">"test3"</span>,<span class="string">'rb'</span>) <span class="comment"># 二进制只读  </span></span><br><span class="line">s = f.read()  </span><br><span class="line">print(type(s)) <span class="comment"># bytes  </span></span><br><span class="line">print(s)  </span><br><span class="line">f.close() <span class="comment"># 关闭文件</span></span><br><span class="line"></span><br><span class="line">f = open(<span class="string">"test3"</span>,<span class="string">'wb'</span>) <span class="comment"># BufferedReader IO对象，小心一用w原来的内容就没了  </span></span><br><span class="line">s = f.write(<span class="string">"马哥教育"</span>.encode())  </span><br><span class="line">print(s) <span class="comment"># 是什么  </span></span><br><span class="line">f.close()</span><br></pre></td></tr></table></figure><p>思考：windows下，执行下面的代码<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">f = open(<span class="string">"test3"</span>,<span class="string">'rw'</span>) <span class="comment">#  </span></span><br><span class="line"></span><br><span class="line">f = open(<span class="string">"test3"</span>, <span class="string">'r+'</span>)  </span><br><span class="line">s = f.read()  <span class="comment"># 文件指针到末尾  </span></span><br><span class="line">f.write(<span class="string">"马哥教育"</span>)  <span class="comment"># 在末尾写入  </span></span><br><span class="line">print(f.read()) <span class="comment"># 没有显示，为什么  </span></span><br><span class="line">f.close()  </span><br><span class="line"></span><br><span class="line">f = open(<span class="string">"test3"</span>, <span class="string">'r+'</span>)  </span><br><span class="line">s = f.write(<span class="string">"magedu"</span>) <span class="comment">#  在开头写入magedu，文件指针移到写入内容之后  </span></span><br><span class="line">print(f.read())  <span class="comment"># 读magedu之后的内容出来  </span></span><br><span class="line">f.close()  </span><br><span class="line"></span><br><span class="line">cat test3  </span><br><span class="line"></span><br><span class="line">f = open(<span class="string">'test3'</span>, <span class="string">'w+'</span>)  <span class="comment"># w 清空文件了  </span></span><br><span class="line">f.read()  </span><br><span class="line">f.close()  </span><br><span class="line"></span><br><span class="line">cat test3  </span><br><span class="line"></span><br><span class="line">f = open(<span class="string">'test3'</span>, <span class="string">'a+'</span>)  </span><br><span class="line">f.write(<span class="string">'mag'</span>)  </span><br><span class="line">f.read()  </span><br><span class="line">f.close()  </span><br><span class="line"></span><br><span class="line">cat test3  </span><br><span class="line"></span><br><span class="line">f = open(<span class="string">'test3'</span>, <span class="string">'a+'</span>)  </span><br><span class="line">f.write(<span class="string">'edu'</span>)  </span><br><span class="line">f.close()  </span><br><span class="line"></span><br><span class="line">cat test3  </span><br><span class="line"></span><br><span class="line">f = open(<span class="string">'test3'</span>, <span class="string">'x+'</span>) <span class="comment">#  文件存在抛出异常  </span></span><br><span class="line"></span><br><span class="line">f = open(<span class="string">'test4'</span>, <span class="string">'x+'</span>) <span class="comment">#  </span></span><br><span class="line">f.write(<span class="string">'python'</span>)  </span><br><span class="line">f.read()  </span><br><span class="line">f.close()  </span><br><span class="line"></span><br><span class="line">cat test4</span><br></pre></td></tr></table></figure></p><p><strong>+</strong><br>为r、w、a、x提供缺失的读写功能，但是，获取文件对象依旧按照r、w、a、x自己的特征。<br>+不能单独使用，可以认为它是为前面的模式字符做增强功能的。  </p><h2 id="文件指针"><a href="#文件指针" class="headerlink" title="文件指针"></a>文件指针</h2><p>上面的例子中，已经说明了有一个指针。  </p><p><strong>文件指针，指向当前字节位置</strong><br>mode=r, 指针起始在0<br>mode=a，指针起始在EOF  </p><p>tell()显示指针当前位置<br>seek(offset[,whence])<br>移动文件指针位置。offset偏移多少字节，whence从哪里开始。  </p><p><strong>文本模式下</strong><br>whence 0缺省值，表示从头开始，offset只能正整数<br>whence 1表示从当前位置，offset只接受0<br>whence 2表示从EOF开始，offset只接受0  </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 文本模式  </span></span><br><span class="line">f = open(<span class="string">'test4'</span>, <span class="string">'r+'</span>)  </span><br><span class="line">f.tell() <span class="comment"># 起始  </span></span><br><span class="line">f.read()  </span><br><span class="line">f.tell() <span class="comment"># EOF  </span></span><br><span class="line">f.seek(<span class="number">0</span>) <span class="comment"># 起始  </span></span><br><span class="line">f.read()  </span><br><span class="line">f.seek(<span class="number">2</span>,<span class="number">0</span>)  </span><br><span class="line">f.read()  </span><br><span class="line">f.seek(<span class="number">2</span>,<span class="number">0</span>)  </span><br><span class="line">f.seek(<span class="number">2</span>,<span class="number">1</span>) <span class="comment"># offset必须为0  </span></span><br><span class="line">f.seek(<span class="number">2</span>,<span class="number">2</span>) <span class="comment"># offset必须为0  </span></span><br><span class="line">f.close()  </span><br><span class="line"></span><br><span class="line"><span class="comment"># 中文  </span></span><br><span class="line">f = open(<span class="string">'test4'</span>, <span class="string">'w+'</span>)  </span><br><span class="line">f.write(<span class="string">'马哥教育'</span>)  </span><br><span class="line">f.tell()  </span><br><span class="line">f.close()  </span><br><span class="line">f = open(<span class="string">'test4'</span>, <span class="string">'r+'</span>)  </span><br><span class="line">f.read(<span class="number">3</span>)  </span><br><span class="line">f.seek(<span class="number">1</span>)  </span><br><span class="line">f.tell()  </span><br><span class="line">f.read()  <span class="comment"># 中文编码如utf-8，不能从一个字符的半截的某个字节开始读  </span></span><br><span class="line">f.seek(<span class="number">2</span>) <span class="comment"># f.seek(3)  </span></span><br><span class="line">f.close()</span><br></pre></td></tr></table></figure><p>文本模式支持从开头向后偏移的方式。<br>whence为1表示从当前位置开始偏移，但是只支持偏移0，相当于原地不动，所以没有什么用。<br>whence为2表示从EOF开始，只支持偏移0，相当于移动文件指针到EOF。<br>seek是按照字节偏移的。不管那种模式。  </p><p><strong>二进制模式下</strong><br>whence 0 缺省值，表示从头开始，offset只能正整数<br>whence 1 表示从当前位置，offset可正可负<br>whence 2 表示从EOF开始，offset可正可负  </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 二进制模式  </span></span><br><span class="line">f = open(<span class="string">'test4'</span>, <span class="string">'rb+'</span>)  </span><br><span class="line">f.tell() <span class="comment"># 起始  </span></span><br><span class="line">f.read()  </span><br><span class="line">f.tell() <span class="comment"># EOF  </span></span><br><span class="line">f.write(<span class="string">b'abc'</span>)  <span class="comment"># 如果写中文字，最好'啊'.encode()  </span></span><br><span class="line">f.seek(<span class="number">0</span>) <span class="comment"># 起始  </span></span><br><span class="line">f.seek(<span class="number">2</span>,<span class="number">1</span>) <span class="comment"># 从当前指针开始，向后2  </span></span><br><span class="line">f.read()  </span><br><span class="line">f.seek(<span class="number">-2</span>,<span class="number">1</span>) <span class="comment"># 从当前指针开始，向前2  </span></span><br><span class="line"></span><br><span class="line">f.seek(<span class="number">2</span>,<span class="number">2</span>) <span class="comment"># 从EOF开始，向后2  </span></span><br><span class="line">f.seek(<span class="number">0</span>)  </span><br><span class="line">f.seek(<span class="number">-2</span>,<span class="number">2</span>) <span class="comment"># 从EOF开始，向前2  </span></span><br><span class="line">f.read()  </span><br><span class="line"></span><br><span class="line">f.seek(<span class="number">-20</span>,<span class="number">2</span>) <span class="comment"># OSError</span></span><br><span class="line">f.close()</span><br></pre></td></tr></table></figure><p>二进制模式支持任意起点的偏移，从头、从尾、从中间位置开始。<br>向后seek可以超界，但是向前seek的时候，不能超界，否则抛异常。  </p><h2 id="buffering：缓冲区"><a href="#buffering：缓冲区" class="headerlink" title="buffering：缓冲区"></a>buffering：缓冲区</h2><p>-1 表示使用缺省大小的buffer。<br>如果是二进制模式，使用io.DEFAULT_BUFFER_SIZE值，默认是4096或者8192。<br>如果是文本模式，如果是终端设备，是行缓存方式，如果不是，则使用二进制模式的策略。  </p><ul><li>0 只在二进制模式使用，表示关buffer  </li><li>1 只在文本模式使用，表示使用行缓冲。意思就是见到换行符就flush  </li><li>大于1用于指定buffer的大小  </li></ul><p>buffer缓冲区<br>缓冲区一个内存空间，一般来说是一个FIFO队列，到缓冲区满了或者达到阈值，数据才会flush到磁盘。  </p><p>flush()将缓冲区数据写入磁盘<br>close()关闭前会调用flush()  </p><p>io.DEFAULT_BUFFER_SIZE 缺省缓冲区大小，字节  </p><p><strong>先看二进制模式</strong><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> io  </span><br><span class="line"></span><br><span class="line">f = open(<span class="string">'test4'</span>,<span class="string">'w+b'</span>)  </span><br><span class="line">print(io.DEFAULT_BUFFER_SIZE)  </span><br><span class="line">f.write(<span class="string">"magedu.com"</span>.encode())  </span><br><span class="line"><span class="comment"># cat test4  # 是空，是因为文件指针在尾，还是因为没有flush？好像都是  </span></span><br><span class="line">f.seek(<span class="number">0</span>)  </span><br><span class="line"><span class="comment"># cat test4  # 输出: magedu.com  </span></span><br><span class="line">f.write(<span class="string">"www.magedu.com"</span>.encode())  </span><br><span class="line">f.flush()  </span><br><span class="line">f.close()  </span><br><span class="line"></span><br><span class="line">f = open(<span class="string">'test4'</span>,<span class="string">'w+b'</span>,<span class="number">4</span>)  <span class="comment"># 清空了文件  </span></span><br><span class="line">f.write(<span class="string">b"mag"</span>)  </span><br><span class="line"><span class="comment"># cat test4  # 空  </span></span><br><span class="line">f.write(<span class="string">b'edu'</span>)  </span><br><span class="line"><span class="comment"># cat test4  # 输出：mag  </span></span><br><span class="line">f.close()</span><br></pre></td></tr></table></figure></p><p><strong>文本模式</strong><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># buffering=1 使用行缓冲  </span></span><br><span class="line">f = open(<span class="string">'test4'</span>, <span class="string">'w+'</span>, <span class="number">1</span>)  </span><br><span class="line">f.write(<span class="string">"mag"</span>)          <span class="comment"># cat test4   为空  </span></span><br><span class="line">f.write(<span class="string">"magedu"</span>*<span class="number">4</span>)     <span class="comment"># cat test4   为空  </span></span><br><span class="line">f.write(<span class="string">'\n'</span>)           <span class="comment"># cat test4  </span></span><br><span class="line">f.write(<span class="string">'Hello\nPython'</span>) <span class="comment"># cat test4，'Python'这几个字符是写入了的，也对啊，不可能搞的更复杂分为2部分，先flush一部分。  </span></span><br><span class="line">f.close()  </span><br><span class="line"></span><br><span class="line"><span class="comment"># buffering&gt;1，使用指定大小的缓冲区  </span></span><br><span class="line">f = open(<span class="string">'test4'</span>, <span class="string">'w+'</span>, <span class="number">15</span>)  </span><br><span class="line">f.write(<span class="string">"mag"</span>) <span class="comment"># cat test4  </span></span><br><span class="line">f.write(<span class="string">'edu'</span>) <span class="comment"># cat test4  </span></span><br><span class="line">f.write(<span class="string">'Hello\n'</span>) <span class="comment"># cat test4  </span></span><br><span class="line">f.write(<span class="string">'\nPython'</span>) <span class="comment"># cat test4  </span></span><br><span class="line">f.write(<span class="string">'a'</span> * (io.DEFAULT_BUFFER_SIZE - <span class="number">20</span>)) <span class="comment"># 设置为大于1没有什么用  </span></span><br><span class="line">f.write(<span class="string">'\nwww.magedu.com/python'</span>)  </span><br><span class="line">f.close()</span><br></pre></td></tr></table></figure></p><p>buffering=0<br>这是一种特殊的二进制模式，不需要内存的buffer，可以看做是一个FIFO的文件。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">f = open(<span class="string">'test4'</span>,<span class="string">'wb+'</span>,<span class="number">0</span>)  </span><br><span class="line">f.write(<span class="string">b"m"</span>) <span class="comment"># cat test4  </span></span><br><span class="line">f.write(<span class="string">b"a"</span>) <span class="comment"># cat test4  </span></span><br><span class="line">f.write(<span class="string">b"g"</span>) <span class="comment"># cat test4  </span></span><br><span class="line">f.write(<span class="string">b"magedu"</span>*<span class="number">4</span>) <span class="comment"># cat test4  </span></span><br><span class="line">f.write(<span class="string">b'\n'</span>) <span class="comment"># cat test4  </span></span><br><span class="line">f.write(<span class="string">b'Hello\nPython'</span>)  </span><br><span class="line">f.close()</span><br></pre></td></tr></table></figure></p><table><thead><tr><th style="text-align:left">buffering</th><th style="text-align:left">说明</th></tr></thead><tbody><tr><td style="text-align:left">buffering=-1</td><td style="text-align:left">t和b，都是io.DEFAULT_BUFFER_SIZE</td></tr><tr><td style="text-align:left">buffering=0</td><td style="text-align:left">b关闭缓冲区 <br> t不支持</td></tr><tr><td style="text-align:left">buffering=1</td><td style="text-align:left">b就1个字节 <br> t行缓冲，遇到换行符才flush</td></tr><tr><td style="text-align:left">buffering&gt;1</td><td style="text-align:left">b模式表示行缓冲大小。缓冲区的值可以超过io.DEFAULT_BUFFER_SIZE，直到设定的值超出后才把缓冲区flush <br> t模式，是io.DEFAULT_BUFFER_SIZE，flush完后把当前字符串也写入磁盘</td></tr></tbody></table><p>似乎看起来很麻烦，一般来说，只需要记得：  </p><ol><li>文本模式，一般都用默认缓冲区大小  </li><li>二进制模式，是一个个字节的操作，可以指定buffer的大小</li><li>一般来说，默认缓冲区大小是个比较好的选择，除非明确知道，否则不调整它</li><li>一般编程中，明确知道要写磁盘了，都会手动调用一次flush，而不是等到自动flush或者close的时候</li></ol><p><strong>encoding：编码，仅文本模式使用</strong><br>None 表示使用缺省编码，依赖操作系统。windows、linux下测试如下代码<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">f = open(<span class="string">'test1'</span>,<span class="string">'w'</span>)  </span><br><span class="line">f.write(<span class="string">'啊'</span>)  </span><br><span class="line">f.close()</span><br></pre></td></tr></table></figure></p><p>windows下缺省GBK（0xB0A1），Linux下缺省UTF-8（0xE5958A）  </p><p><strong>其他参数</strong><br><strong>errors</strong><br>什么样的编码错误将被捕获<br>None和strict表示有编码错误将抛出ValueError异常；ignore表示忽略  </p><p><strong>newline</strong><br>文本模式中，换行的转换。可以填写为None、”(空串)、’\r’、’\n’、’\r\n’<br>读时，None表示’\r’、’\n’、’\r\n’都被转换为’\n’；”(空串)表示不会自动转换通用换行符；其他合法字符表示换行符就是字符，就会按照指定字符分行<br>写时，None表示’\n’都会被替换为系统缺省分隔符os.linesep；’\n’或’’(空串)表示’\n’不替换；其他合法字符表示’\n’会被替换为指定的字符  </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">f = open(<span class="string">'o:/test'</span>, <span class="string">'w'</span>)  </span><br><span class="line">f.write(<span class="string">'python\rwww.python.org\nwww.magedu.com\r\npython3'</span>)  </span><br><span class="line">f.close()  </span><br><span class="line"></span><br><span class="line">newlines = [<span class="literal">None</span>, <span class="string">''</span>, <span class="string">'\n'</span>, <span class="string">'\r\n'</span>]  </span><br><span class="line"><span class="keyword">for</span> nl <span class="keyword">in</span> newlines:</span><br><span class="line">    f = open(<span class="string">'o:/test'</span>, <span class="string">'r+'</span>, newline=nl) <span class="comment"># 缺省替换所有换行符</span></span><br><span class="line">    print(f.readlines())</span><br><span class="line">    f.close()</span><br></pre></td></tr></table></figure><p><strong>closefd</strong><br>关闭文件描述符，True表示关闭它。False会在文件关闭后保持这个描述符。fileobj.fileno()查看  </p><h2 id="read"><a href="#read" class="headerlink" title="read"></a>read</h2><p>read(size=-1)<br>size表示读取的多少个字符或字节；负数或者None表示读取到EOF  </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">f = open(<span class="string">'o:/test4'</span>, <span class="string">'r+'</span>, <span class="number">0</span>)  </span><br><span class="line">f.write(<span class="string">"magedu"</span>)  </span><br><span class="line">f.write(<span class="string">'\n'</span>)  </span><br><span class="line">f.write(<span class="string">'马哥教育'</span>)  </span><br><span class="line">f.seek(<span class="number">0</span>)  </span><br><span class="line">f.read(<span class="number">7</span>)  </span><br><span class="line">f.close()  </span><br><span class="line"></span><br><span class="line"><span class="comment"># 二进制  </span></span><br><span class="line">f = open(<span class="string">'test4'</span>,<span class="string">'rb+'</span>)  </span><br><span class="line">f.read(<span class="number">7</span>)  </span><br><span class="line">f.read(<span class="number">1</span>)  </span><br><span class="line">f.close()</span><br></pre></td></tr></table></figure><h2 id="行读取"><a href="#行读取" class="headerlink" title="行读取"></a>行读取</h2><p>readline(size=-1)<br>一行行读取文件内容。size设置一次能读取行内几个字符或字节。  </p><p>readlines(hint=-1)<br>读取所有行的列表。指定hint则返回指定行数。  </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 按行迭代  </span></span><br><span class="line">f = open(<span class="string">'test'</span>) <span class="comment"># 返回可迭代对象  </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> line <span class="keyword">in</span> f:</span><br><span class="line">    print(line)  </span><br><span class="line"></span><br><span class="line">f.close()</span><br></pre></td></tr></table></figure><h2 id="write"><a href="#write" class="headerlink" title="write"></a>write</h2><p>write(s)，把字符串s写入到文件中并返回字符个数<br>writelines(lines)，将字符串<strong>列表</strong>写入文件，单个字符串也行  </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">f = open(<span class="string">'test'</span>, <span class="string">'w+'</span>)  </span><br><span class="line"></span><br><span class="line">lines = [<span class="string">'abc'</span>, <span class="string">'123\n'</span>, <span class="string">'magedu'</span>] <span class="comment"># 提供换行符  </span></span><br><span class="line">f.writelines(lines)  </span><br><span class="line"></span><br><span class="line">f.seek(<span class="number">0</span>)  </span><br><span class="line">print(f.read())  </span><br><span class="line">f.close()</span><br></pre></td></tr></table></figure><h2 id="close"><a href="#close" class="headerlink" title="close"></a>close</h2><p>flush并关闭文件对象。<br>文件已经关闭，再次关闭没有任何效果。  </p><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>seekable()是否可seek<br>readable()是否可读<br>writable()是否可写<br>closed是否已经关闭  </p><h2 id="上下文管理"><a href="#上下文管理" class="headerlink" title="上下文管理"></a>上下文管理</h2><p><strong>问题的引出</strong><br>在Linux中，执行  </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 下面必须这么写  </span></span><br><span class="line">lst = []  </span><br><span class="line"><span class="keyword">for</span> _ <span class="keyword">in</span> range(<span class="number">2000</span>):</span><br><span class="line">    lst.append(open(<span class="string">'test'</span>))  <span class="comment"># OSError: [Errno 24] Too many open files: 'test'  </span></span><br><span class="line"></span><br><span class="line">print(len(lst))</span><br></pre></td></tr></table></figure><p>lsof 列出打开的文件。没有就# yum install lsof<br>lsof -p 1427 | grep test | wc -l<br>lsof -p 进程号<br>ulimit -a 查看所有限制。其中open files 就是打开文件数的限制，默认1024  </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> lst:</span><br><span class="line">    x.close()</span><br></pre></td></tr></table></figure><p>将文件一次关闭，然后就可以继续打开了。再看一次lsof。<br>如何解决？  </p><ol><li>异常处理<br>当出现异常的时候，拦截异常。但是，因为很多代码都可能出现OSError异常，还不好判断异常就应为资源限制产生的。  </li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">f = open(<span class="string">'test'</span>)  <span class="comment"># 这里就可能抛出异常  </span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    f.write(<span class="string">"abc"</span>) <span class="comment"># 文件只读，写入失败  </span></span><br><span class="line"><span class="keyword">finally</span>:</span><br><span class="line">    f.close() <span class="comment"># 这样才行</span></span><br></pre></td></tr></table></figure><p>使用finally可以保证打开的文件可以被关闭。  </p><ol start="2"><li>上下文管理<br>一种特殊的语法，交给解释器去解释文件对象  </li></ol><h2 id="上下文管理-1"><a href="#上下文管理-1" class="headerlink" title="上下文管理"></a>上下文管理</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span>  </span></span><br><span class="line"><span class="function"><span class="title">with</span> <span class="title">open</span><span class="params">(<span class="string">'test'</span>)</span> <span class="title">as</span> <span class="title">f</span>:</span></span><br><span class="line">    f.write(<span class="string">"abc"</span>) <span class="comment"># 文件只读，写入失败  </span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 测试f是否关闭  </span></span><br><span class="line">f.closed <span class="comment"># f的作用域</span></span><br></pre></td></tr></table></figure><p>上下文管理  </p><ol><li>使用with … as 关键字  </li><li>上下文管理的语句块并不会开启新的作用域  </li><li>with语句块执行完的时候，会自动关闭文件对象  </li></ol><p>另一种写法<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">f1 = open(<span class="string">'test'</span>)  </span><br><span class="line"><span class="keyword">with</span> f1:</span><br><span class="line">    f1.write(<span class="string">"abc"</span>) <span class="comment"># 文件只读，写入失败  </span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 测试f是否关闭  </span></span><br><span class="line">f1.closed <span class="comment"># f1的作用域</span></span><br></pre></td></tr></table></figure></p><p>对于类似于文件对象的IO对象，一般来说都需要在不使用的时候关闭、注销、以释放资源。<br>IO被打开的时候，会获得一个文件描述符。计算机资源是有限的，所以操作系统都会做限制。就是为了保护计算机的资源不要被完全耗尽，计算资源是共享的，不是独占的。<br>一般情况下，除非特别明确的知道资源情况，否则不要提高资源的限制值来解决问题。  </p><h1 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h1><ol><li><strong>指定一个源文件，实现copy到目标目录</strong>  </li></ol><p>例如把/tmp/test.txt 拷贝到 /tmp/test1.txt  </p><ol start="2"><li><strong>有一个文件，对其进行单词统计，不区分大小写，并显示单词重复最多的10个单词。</strong>  </li></ol><p>简单处理后，大概的得数如下：<br>the，136<br>is，60<br>a，54<br>path，52<br>if，42<br>and，39<br>to，34<br>of，33<br>on，32<br>return，30  </p><p>实际上有效的path很多，作为合法的单词path统计应该有100多个。<br>对单词做进一步处理后，统计如下：<br>path，137<br>the，136<br>is，60<br>a，59<br>os，50<br>if，43<br>and，40<br>to，34<br>of，33<br>on，33  </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;第十七章-文件操作&quot;&gt;&lt;a href=&quot;#第十七章-文件操作&quot; class=&quot;headerlink&quot; title=&quot;第十七章 - 文件操作&quot;&gt;&lt;/a&gt;第十七章 - 文件操作&lt;/h1&gt;&lt;h2 id=&quot;冯诺伊曼体系架构&quot;&gt;&lt;a href=&quot;#冯诺伊曼体系架构&quot; cla
      
    
    </summary>
    
      <category term="python-magedu" scheme="https://herodanny.github.io/categories/python-magedu/"/>
    
    
      <category term="python" scheme="https://herodanny.github.io/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>python全栈-magedu-2018-笔记23</title>
    <link href="https://herodanny.github.io/python-magedu-2018-notes23.html"/>
    <id>https://herodanny.github.io/python-magedu-2018-notes23.html</id>
    <published>2019-05-16T06:14:43.000Z</published>
    <updated>2019-05-19T12:53:44.117Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第十六章-Python之functools"><a href="#第十六章-Python之functools" class="headerlink" title="第十六章 - Python之functools"></a>第十六章 - Python之functools</h1><h2 id="functools模块"><a href="#functools模块" class="headerlink" title="functools模块"></a>functools模块</h2><ul><li>partial方法<ul><li>偏函数，把函数部分的参数固定下来，相当于为部分的参数添加了一个固定的默认值，形成一个新的函数并返回</li><li>从partial生成的新函数，是对原函数的封装</li></ul></li></ul><h2 id="functools模块-1"><a href="#functools模块-1" class="headerlink" title="functools模块"></a>functools模块</h2><ul><li>partial方法举例  </li></ul><p>import functools  </p><p>def add(x, y) -&gt; int:<br>&emsp; return x + y  </p><p>newadd = functools.partial(add, y=5)  </p><p>print(newadd(7))<br>print(newadd(7, y=6))<br>print(newadd(y=10, x=6))  </p><p>import inspect<br>print(inspect.signature(newadd))  </p><h2 id="functools模块-2"><a href="#functools模块-2" class="headerlink" title="functools模块"></a>functools模块</h2><ul><li>partial方法举例</li></ul><p>import functools  </p><p>def add(x, y, *args) -&gt; int:<br>&emsp; print(args)<br>&emsp; return x + y  </p><p>newadd = functools.partial(add, 1,3,6,5)  </p><p>print(newadd(7))<br>print(newadd(7, 10))<br>print(newadd(9, 10, y=20, x=26)) #<br>print(newadd())  </p><p>import inspect<br>print(inspect.signature(newadd))  </p><h2 id="functools模块-3"><a href="#functools模块-3" class="headerlink" title="functools模块"></a>functools模块</h2><ul><li>partial函数本质  </li></ul><p>def partial(func, *args, **keywords):<br>&emsp; def newfunc(*fargs, **fkeywords): # 包装函数<br>&emsp;&emsp; newkeywords = keywords.copy()<br>&emsp;&emsp; newkeywords.update(fkeywords)<br>&emsp;&emsp; return func(*(args + fargs), **newkeywords)<br>&emsp; newfunc.func = func # 保留原函数<br>&emsp; newfunc.args = args # 保留原函数的位置参数<br>&emsp; newfunc.keywords = keywords # 保留原函数的关键字参数参数<br>&emsp; return newfunc  </p><p>def add(x,y):<br>&emsp; return x+y  </p><p>foo = partial(add,4)<br>foo(5)  </p><h2 id="functools模块-4"><a href="#functools模块-4" class="headerlink" title="functools模块"></a>functools模块</h2><ul><li>@functools.lru_cache(maxsize=128, typed=False)<ul><li>Least-recently-used装饰器。lru，最近最少使用。cache缓存</li><li>如果maxsize设置为None，则禁用LRU功能，并且缓存可以无限制增长。当maxsize是二的幂时，LRU功能执行得最好</li><li>如果typed设置为True，则不同类型的函数参数将单独缓存。例如，f(3)和f(3.0)将被视为具有不同结果的不同调用</li></ul></li></ul><h2 id="functools模块-5"><a href="#functools模块-5" class="headerlink" title="functools模块"></a>functools模块</h2><ul><li>举例</li></ul><p>import functools<br>import time<br>@functools.lru_cache()<br>def add(x, y, z=3):<br>&emsp; time.sleep(z)<br>&emsp; return x + y  </p><p>add(4, 5)<br>add(4.0, 5)<br>add(4, 6)<br>add(4, 6, 3)<br>add(6, 4)<br>add(4, y=6)<br>add(x=4, y=6)<br>add(y=6, x=4)<br>思考：缓存的机制是什么？  </p><h2 id="functools模块-6"><a href="#functools模块-6" class="headerlink" title="functools模块"></a>functools模块</h2><ul><li>lru_cache装饰器<ul><li>通过一个字典缓存被装饰函数的调用和返回值</li><li>key是什么？分析代码看看<br>functools._make_key((4,6),{‘z’:3},False)<br>functools._make_key((4,6,3),{},False)<br>functools._make_key(tuple(),{‘z’:3,’x’:4,’y’:6},False)<br>functools._make_key(tuple(),{‘z’:3,’x’:4,’y’:6}, True)  </li></ul></li></ul><h2 id="functools模块-7"><a href="#functools模块-7" class="headerlink" title="functools模块"></a>functools模块</h2><ul><li>lru_cache装饰器<ul><li>斐波那契数列递归方法的改造<br>import functools  </li></ul></li></ul><p>&emsp;&emsp;&emsp;&emsp;@functools.lru_cache() # maxsize=None<br>&emsp;&emsp;&emsp;&emsp;def fib(n):<br>&emsp;&emsp;&emsp;&emsp;&emsp; if n &lt; 3:<br>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp; return n<br>&emsp;&emsp;&emsp;&emsp;&emsp; return fib(n-1) + fib(n-2)  </p><p>&emsp;&emsp;&emsp;&emsp;print([fib(x) for x in range(35)])  </p><h2 id="functools模块-8"><a href="#functools模块-8" class="headerlink" title="functools模块"></a>functools模块</h2><ul><li>lru_cache装饰器应用<ul><li>使用前提<ul><li>同样的函数参数一定得到同样的结果</li><li>函数执行时间很长，且要多次执行</li></ul></li><li>本质是函数调用的参数=&gt;返回值</li><li>缺点<ul><li>不支持缓存过期，key无法过期、失效</li><li>不支持清除操作</li><li>不支持分布式，是一个单机的缓存</li></ul></li><li>适用场景，单机上需要空间换时间的地方，可以用缓存来将计算变成快速的查询</li></ul></li></ul><h2 id="装饰器应用练习"><a href="#装饰器应用练习" class="headerlink" title="装饰器应用练习"></a>装饰器应用练习</h2><ul><li>一、实现一个cache装饰器，实现可过期被清除的功能<ul><li>简化设计，函数的形参定义不包含可变位置参数、可变关键词参数和keyword-only参数</li><li>可以不考虑缓存满了之后的换出问题</li></ul></li><li>二、写一个命令分发器<ul><li>程序员可以方便的注册函数到某一个命令，用户输入命令时，路由到注册的函数</li><li>如果此命令没有对应的注册函数，执行默认函数</li><li>用户输入用input(“&gt;&gt;”)</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;第十六章-Python之functools&quot;&gt;&lt;a href=&quot;#第十六章-Python之functools&quot; class=&quot;headerlink&quot; title=&quot;第十六章 - Python之functools&quot;&gt;&lt;/a&gt;第十六章 - Python之functoo
      
    
    </summary>
    
      <category term="python-magedu" scheme="https://herodanny.github.io/categories/python-magedu/"/>
    
    
      <category term="python" scheme="https://herodanny.github.io/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>python全栈-magedu-2018-笔记22</title>
    <link href="https://herodanny.github.io/python-magedu-2018-notes22.html"/>
    <id>https://herodanny.github.io/python-magedu-2018-notes22.html</id>
    <published>2019-05-16T05:50:19.000Z</published>
    <updated>2019-05-19T12:52:15.093Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第十五章-Python-类型注解"><a href="#第十五章-Python-类型注解" class="headerlink" title="第十五章 - Python 类型注解"></a>第十五章 - Python 类型注解</h1><h2 id="函数定义的弊端"><a href="#函数定义的弊端" class="headerlink" title="函数定义的弊端"></a>函数定义的弊端</h2><ul><li>Python是动态语言，变量随时可以被赋值，且能赋值为不同的类型</li><li>Python不是静态编译型语言，变量类型是在运行器决定的</li><li>动态语言很灵活，但是这种特性也是弊端<br>def add(x, y):<br>&emsp; return x + y<br>print(add(4, 5))<br>print(add(‘hello’, ‘world’))<br>add(4, ‘hello’) #  <ul><li>难发现：由于不做任何类型检查，直到运行期问题才显现出来，或者线上运行时才能暴露出问题</li><li>难使用：函数的使用者看到函数的时候，并不知道你的函数的设计，并不知道应该传入什么类型的数据</li></ul></li></ul><h2 id="函数定义的弊端-1"><a href="#函数定义的弊端-1" class="headerlink" title="函数定义的弊端"></a>函数定义的弊端</h2><ul><li>如何解决这种动态语言定义的弊端呢？<ul><li>增加文档Documentation String<ul><li>这只是一个惯例，不是强制标准，不能要求程序员一定为函数提供说明文档</li><li>函数定义更新了，文档未必同步更新<br>def add(x, y):<br>&emsp; ‘’’<br>&emsp; :param x: int<br>&emsp; :param y: int<br>&emsp; :return: int<br>&emsp; ‘’’<br>&emsp; return x + y<br>print(help(add))  </li></ul></li></ul></li></ul><h2 id="函数注解Function-Annotations"><a href="#函数注解Function-Annotations" class="headerlink" title="函数注解Function Annotations"></a>函数注解Function Annotations</h2><ul><li>如果解决这种动态语言定义的弊端呢？  <ul><li>函数注解<br>def add(x:int , y:int) -&gt; int :<br>&emsp; ‘’’<br>&emsp; :param x: int<br>&emsp; :param y: int<br>&emsp; :return: int<br>&emsp; ‘’’<br>&emsp; return x + y<br>print(help(add))<br>print(add(4, 5))<br>print(add(‘mag’, ‘edu’))  </li></ul></li></ul><h2 id="函数注解Function-Annotations-1"><a href="#函数注解Function-Annotations-1" class="headerlink" title="函数注解Function Annotations"></a>函数注解Function Annotations</h2><ul><li>函数注解<ul><li>Python 3.5引入</li><li>对函数的参数进行类型注解</li><li>对函数的返回值进行类型注解</li><li>只对函数参数做一个辅助的说明，并不对函数参数进行类型检查</li><li>提供给第三方工具，做代码分析，发现隐藏的bug</li><li>函数注解的信息，保存在<strong>annotations</strong>属性中<br>add.__annotations__<br>{‘x’: <class 'int'>, ‘y’: <class 'int'>, ‘return’: <class 'int'>}  </class></class></class></li></ul></li><li>变量注解  <ul><li>Python 3.6引入<br>i : int = 3  </li></ul></li></ul><h2 id="业务应用"><a href="#业务应用" class="headerlink" title="业务应用"></a>业务应用</h2><ul><li>函数参数类型检查</li><li>思路<ul><li>函数参数的检查，一定是在函数外</li><li>函数应该作为参数，传入到检查函数中</li><li>检查函数拿到函数传入的实际参数，与形参声明对比</li><li>__annotations__属性是一个字典，其中包括返回值类型的声明。假设要做位置参数的判断，无法和字典中的声明对应。使用inspect模块</li></ul></li><li>inspet模块<ul><li>提供获取对象信息的函数，可以检查函数和类、类型检查</li></ul></li></ul><h2 id="inspect模块"><a href="#inspect模块" class="headerlink" title="inspect模块"></a>inspect模块</h2><ul><li>signature(callable)，获取签名（函数签名包含了一个函数的信息，包括函数名、它的参数类型、它所在的类和名称空间及其他信息）<br>import inspect<br>def add(x:int, y:int, *args,**kwargs) -&gt; int:<br>&emsp; return x + y<br>sig = inspect.signature(add)<br>print(sig, type(sig)) # 函数签名<br>print(‘params : ‘, sig.parameters) # OrderedDict<br>print(‘return : ‘, sig.return_annotation)<br>print(sig.parameters[‘y’], type(sig.parameters[‘y’]))<br>print(sig.parameters[‘x’].annotation)<br>print(sig.parameters[‘args’])<br>print(sig.parameters[‘args’].annotation)<br>print(sig.parameters[‘kwargs’])<br>print(sig.parameters[‘kwargs’].annotation)  </li></ul><h2 id="inspect模块-1"><a href="#inspect模块-1" class="headerlink" title="inspect模块"></a>inspect模块</h2><ul><li>inspect.isfunction(add)，是否是函数</li><li>inspect.ismethod(add))，是否是类的方法</li><li>inspect.isgenerator(add))，是否是生成器对象</li><li>inspect.isgeneratorfunction(add))，是否是生成器函数</li><li>inspect.isclass(add))，是否是类</li><li>inspect.ismodule(inspect))，是否是模块</li><li>inspect.isbuiltin(print))，是否是内建对象</li><li>还有很多is函数，需要的时候查阅inspect模块帮助</li></ul><h2 id="inspect模块-2"><a href="#inspect模块-2" class="headerlink" title="inspect模块"></a>inspect模块</h2><ul><li>Parameter对象<ul><li>保存在元组中，是只读的</li><li>name，参数的名字</li><li>annotation，参数的注解，可能没有定义</li><li>default，参数的缺省值，可能没有定义</li><li>empty，特殊的类，用来标记default属性或者注释annotation属性的空值</li><li>kind，实参如何绑定到形参，就是形参的类型<ul><li>POSITIONAL_ONLY，值必须是位置参数提供</li><li><strong>POSITIONAL_OR_KEYWORD</strong>，值可以作为关键字或者位置参数提供</li><li><strong>VAR_POSITIONAL</strong>，可变位置参数，对应*args</li><li><strong>KEYWORD_ONLY</strong>，keyword-only参数，对应*或者*args之后的出现的非可变关键字参数</li><li><strong>VAR_KEYWORD</strong>，可变关键字参数，对应**kwargs</li></ul></li></ul></li></ul><h2 id="inspect模块-3"><a href="#inspect模块-3" class="headerlink" title="inspect模块"></a>inspect模块</h2><ul><li>举例<br>import inspect  </li></ul><p>def add(x, y:int=7, *args, z, t=10,**kwargs) -&gt; int:<br>&emsp; return x + y<br>sig = inspect.signature(add)<br>print(sig)<br>print(‘params : ‘, sig.parameters) # 有序字典<br>print(‘return : ‘, sig.return_annotation)<br>print(‘<del>~</del><del>~</del><del>~</del>~’)<br>for i, item in enumerate(sig.parameters.items()):<br>&emsp; name, param = item<br>&emsp; print(i+1, name, param.annotation, param.kind, param.default)<br>&emsp; print(param.default is param.empty, end=’\n\n’)  </p><h2 id="业务应用-1"><a href="#业务应用-1" class="headerlink" title="业务应用"></a>业务应用</h2><ul><li>有函数如下<br>def add(x, y:int=7) -&gt; int:<br>&emsp; return x + y  </li><li>请检查用户输入是否符合参数注解的要求？  </li></ul><h2 id="业务应用-2"><a href="#业务应用-2" class="headerlink" title="业务应用"></a>业务应用</h2><ul><li>有函数如下<br>def add(x, y:int=7) -&gt; int:<br>&emsp; return x + y  </li><li>请检查用户输入是否符合参数注解的要求？</li><li>思路<ul><li>调用时，判断用户输入的实参是否符合要求</li><li>调用时，用户感觉上还是在调用add函数</li><li>对用户输入的数据和声明的类型进行对比，如果不符合，提示用户</li></ul></li></ul><h2 id="业务应用-3"><a href="#业务应用-3" class="headerlink" title="业务应用"></a>业务应用</h2><p>import inspect<br>def add(x, y:int=7) -&gt; int:<br>&emsp; return x + y  </p><p>def check(fn):<br>&emsp; def wrapper(<em>args, **kwargs):<br>&emsp;&emsp; sig = inspect.signature(fn)<br>&emsp;&emsp; params = sig.parameters<br>&emsp;&emsp; values = list(params.values())<br>&emsp;&emsp; for i,p in enumerate(args):<br>&emsp;&emsp;&emsp; if isinstance(p, values[i].annotation): # 实参和形参声明一致<br>&emsp;&emsp;&emsp;&emsp; print(‘==’)<br>&emsp;&emsp; for k,v in kwargs.items():<br>&emsp;&emsp;&emsp; if isinstance(v, params[k].annotation): # 实参和形参声明一致<br>&emsp;&emsp;&emsp;&emsp; print(‘===’)<br>&emsp;&emsp; return fn(\</em>args, **kwargs)<br>&emsp; return wrapp  </p><p>调用测试<br>check(add)(20,10)<br>check(add)(20,y=10)<br>check(add)(y=10,x=20)<br>业务需求是参数有注解就要求实参类型和声明应该一致，没有注解的参数不比较，如何修改代码？  </p><h2 id="业务应用-4"><a href="#业务应用-4" class="headerlink" title="业务应用"></a>业务应用</h2><p>import inspect  </p><p>def check(fn):<br>&emsp; def wrapper(<em>args, <strong>kwargs):<br>&emsp;&emsp; sig = inspect.signature(fn)<br>&emsp;&emsp; params = sig.parameters<br>&emsp;&emsp; values = list(params.values())<br>&emsp;&emsp; for i,p in enumerate(args):<br>&emsp;&emsp;&emsp; param = values[i]<br>&emsp;&emsp;&emsp; if param.annotation is not </strong>param.empty<strong> and not isinstance(p, param.annotation):<br>&emsp;&emsp;&emsp;&emsp; print(p,’!==’,values[i].annotation)<br>&emsp;&emsp; for k,v in kwargs.items():<br>&emsp;&emsp;&emsp;&emsp; if params[k].annotation is not </strong>inspect._empty** and not isinstance(v, params[k].annotation):<br>&emsp;&emsp;&emsp;&emsp; print(k,v,’!===’,params[k].annotation)<br>&emsp;&emsp; return fn(\</em>args, **kwargs)<br>&emsp; return wrapper  </p><p>@check<br>def add(x, y:int=7) -&gt; int:<br>&emsp; return x + y  </p><p>调用测试<br>add(20,10)<br>add(20,y=10)<br>add(y=10,x=20)  </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;第十五章-Python-类型注解&quot;&gt;&lt;a href=&quot;#第十五章-Python-类型注解&quot; class=&quot;headerlink&quot; title=&quot;第十五章 - Python 类型注解&quot;&gt;&lt;/a&gt;第十五章 - Python 类型注解&lt;/h1&gt;&lt;h2 id=&quot;函数定义的
      
    
    </summary>
    
      <category term="python-magedu" scheme="https://herodanny.github.io/categories/python-magedu/"/>
    
    
      <category term="python" scheme="https://herodanny.github.io/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>python全栈-magedu-2018-笔记21</title>
    <link href="https://herodanny.github.io/python-magedu-2018-notes21.html"/>
    <id>https://herodanny.github.io/python-magedu-2018-notes21.html</id>
    <published>2019-05-15T02:45:50.000Z</published>
    <updated>2019-05-19T12:50:58.507Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第十四章-Python-装饰器"><a href="#第十四章-Python-装饰器" class="headerlink" title="第十四章 - Python 装饰器"></a>第十四章 - Python 装饰器</h1><h2 id="装饰器"><a href="#装饰器" class="headerlink" title="装饰器"></a>装饰器</h2><ul><li>需求<ul><li>一个加法函数，想增强它的功能，能够输出被调用过以及调用的参数信息<br>def add(x, y):<br>&emsp; return x + y<br>增加信息输出功能<br>def add(x, y):<br>&emsp; print(“call add, x + y”) # 日志输出到控制台<br>&emsp; # print(“call {}, {} + {}”.format(add.__name__, x, y), file=file)<br>&emsp; return x + y  </li><li>上面的加法函数是完成了需求，但是有以下的缺点<ul><li>打印语句的耦合太高</li><li>加法函数属于业务功能，而输出信息的功能，属于非业务功能代码，不该放在业务函数加法中</li></ul></li></ul></li></ul><h2 id="装饰器-1"><a href="#装饰器-1" class="headerlink" title="装饰器"></a>装饰器</h2><ul><li>做到了业务功能分离，但是fn函数调用传参是个问题，就是fn(4,5)参数4，5写死了<br>def add(x,y):<br>&emsp; return x + y  </li></ul><p>&emsp;&emsp; def logger(fn):<br>&emsp;&emsp;&emsp; print(‘begin’) # 增强的输出<br>&emsp;&emsp;&emsp; x = fn(4,5)<br>&emsp;&emsp;&emsp; print(‘end’) # 增强的功能<br>&emsp;&emsp;&emsp; return x<br>&emsp;&emsp; print(logger(add))  </p><h2 id="装饰器-2"><a href="#装饰器-2" class="headerlink" title="装饰器"></a>装饰器</h2><ul><li>用可变参数解决传参的问题，进一步改变<br>def add(x,y):<br>&emsp; return x + y  </li></ul><p>&emsp;&emsp; def logger(fn,*args,**kwargs): # 可变位置参数，可变关键字参数<br>&emsp;&emsp;&emsp; print(‘begin’)<br>&emsp;&emsp;&emsp; x = fn(*args,**kwargs) # *和**是参数解构<br>&emsp;&emsp;&emsp; print(‘end’)<br>&emsp;&emsp;&emsp; return x  </p><p>&emsp;&emsp; print(logger(add,5,y=60))  </p><h2 id="装饰器-3"><a href="#装饰器-3" class="headerlink" title="装饰器"></a>装饰器</h2><ul><li>柯里化改造包装函数logger<br>def add(x,y):<br>&emsp; return x + y  </li></ul><p>&emsp;&emsp; def logger(fn):<br>&emsp;&emsp;&emsp; def wrapper(<em>args,**kwargs):<br>&emsp;&emsp;&emsp;&emsp; print(‘begin’)<br>&emsp;&emsp;&emsp;&emsp; x = fn(</em>args,**kwargs)<br>&emsp;&emsp;&emsp;&emsp; print(‘end’)<br>&emsp;&emsp;&emsp;&emsp; return x<br>&emsp;&emsp;&emsp; return wrapper  </p><p>&emsp;&emsp; print(logger(add)(5,y=50))  </p><p>&emsp;&emsp; <strong>换一种写法：</strong><br>&emsp;&emsp; add = logger(add)<br>&emsp;&emsp; print(add(x=5, y=10))  </p><p>&emsp;&emsp; <strong>另一种写法：</strong><br>&emsp;&emsp; add = logger(add)  # fn是闭包，所以add重新赋值，不会被销毁<br>&emsp;&emsp; add(4, 100)  </p><h2 id="装饰器-4"><a href="#装饰器-4" class="headerlink" title="装饰器"></a>装饰器</h2><ul><li>装饰器语法糖<br>def logger(fn):<br>&emsp; def wrapper(<em>args,**kwargs):<br>&emsp;&emsp; print(‘begin’)<br>&emsp;&emsp; x = fn(</em>args,**kwargs)<br>&emsp;&emsp; print(‘end’)<br>&emsp;&emsp; return x<br>&emsp; return wrapper  </li></ul><p>&emsp;&emsp; <strong>@logger # 等价于add = logger(add)</strong><br>&emsp;&emsp; def add(x,y):<br>&emsp;&emsp;&emsp; return x + y  </p><p>&emsp;&emsp; print(add(45,40))  </p><ul><li>@logger 是什么？这就是装饰器语法。<br>logger 叫做装饰器、装饰器函数，即return wrapper中wrapper也叫装饰器函数。  </li></ul><h2 id="装饰器-5"><a href="#装饰器-5" class="headerlink" title="装饰器"></a>装饰器</h2><ul><li><p>装饰器（无参）</p><ul><li>它是一个函数</li><li>函数作为它的形参</li><li>返回值也是一个函数</li><li>可以使用@functionname方式，简化调用</li></ul></li><li><p>装饰器和高阶函数</p><ul><li>装饰器是高阶函数，但装饰器是对传入函数的功能的装饰（功能增强）</li></ul></li></ul><h2 id="装饰器-6"><a href="#装饰器-6" class="headerlink" title="装饰器"></a>装饰器</h2><p>import datetime<br>import time  </p><p>def logger(fn):<br>&emsp; def wrap(<em>args, **kwargs):<br>&emsp;&emsp; # before 功能增强<br>&emsp;&emsp; print(“args={}, kwargs={}”.format(args,kwargs))<br>&emsp;&emsp; start = datetime.datetime.now()<br>&emsp;&emsp; ret = fn(</em>args, **kwargs)<br>&emsp;&emsp; # after 功能增强<br>&emsp;&emsp; duration = datetime.datetime.now() - start<br>&emsp;&emsp; print(“function {} took {}s.”.format(fn.__name__, duration.total_seconds()))<br>&emsp;&emsp; return ret<br>&emsp; return wrap  </p><p>@logger # 相当于 add = logger(add)<br>def add(x, y):<br>&emsp; print(“===call add===========”)<br>&emsp; time.sleep(2)<br>&emsp; return x + y  </p><p>print(add(4, y=7))  </p><h2 id="装饰器-7"><a href="#装饰器-7" class="headerlink" title="装饰器"></a>装饰器</h2><ul><li>怎么理解装饰器呢？</li></ul><p><img src="https://raw.githubusercontent.com/herodanny/Image-Hosting/master/data/zhuangshiqi.jpg" alt="zhuangshiqi">  </p><h2 id="文档字符串"><a href="#文档字符串" class="headerlink" title="文档字符串"></a>文档字符串</h2><ul><li>Python的文档<ul><li>Python是文档字符串Documentation Strings</li><li>在函数语句块的第一行，且习惯是多行的文本，所以多使用三引号</li><li>惯例是首字母大写，第一行写概述，空一行，第三行写详细描述</li><li>可以使用特殊属性<strong>doc</strong>访问这个文档  </li></ul></li></ul><p>&emsp;&emsp; def add(x,y):<br>&emsp;&emsp;&emsp; “””This is a function of addition”””<br>&emsp;&emsp;&emsp; a = x+y<br>&emsp;&emsp;&emsp; return x + y  </p><p>&emsp;&emsp; print(“name={}\ndoc={}”.format(add.__name__, add.__doc__))<br>&emsp;&emsp; print(help(add))  </p><h2 id="装饰器-8"><a href="#装饰器-8" class="headerlink" title="装饰器"></a>装饰器</h2><ul><li>副作用<br>def logger(fn):<br>&emsp; def wrapper(<em>args,**kwargs):<br>&emsp;&emsp; ‘I am wrapper’<br>&emsp;&emsp; print(‘begin’)<br>&emsp;&emsp; x = fn(</em>args,**kwargs)<br>&emsp;&emsp; print(‘end’)<br>&emsp;&emsp; return x<br>&emsp; return wrapper  </li></ul><p>&emsp;&emsp; @logger #add = logger(add)<br>&emsp;&emsp; def add(x,y):<br>&emsp;&emsp;&emsp; ‘’’This is a function for add’’’<br>&emsp;&emsp;&emsp; return x + y  </p><p>&emsp;&emsp; print(“name={}, doc={}”.format(add.__name__, add.__doc__))  </p><ul><li>原函数对象的属性都被替换了，而使用装饰器，我们的需求是查看被封装函数的属性，如何解决？<br>add不是原来的add函数了，里面的说明文档等属性都变了。  </li></ul><h2 id="装饰器-9"><a href="#装饰器-9" class="headerlink" title="装饰器"></a>装饰器</h2><ul><li>提供一个函数，被封装函数属性 ==copy==&gt; 包装函数属性<br>def copy_properties(src, dst): # 可以改造成装饰器<br>&emsp; dst.__name__ = src.__name__<br>&emsp; dst.__doc__ = src.__doc__  </li></ul><p>&emsp;&emsp; def logger(fn):<br>&emsp;&emsp;&emsp; def wrapper(*args,**kwargs):<br>&emsp;&emsp;&emsp;&emsp; ‘I am wrapper’<br>&emsp;&emsp;&emsp;&emsp; print(‘begin’)<br>&emsp;&emsp;&emsp;&emsp; x = fn(*args,**kwargs)<br>&emsp;&emsp;&emsp;&emsp; print(‘end’)<br>&emsp;&emsp;&emsp;&emsp; return x<br>&emsp;&emsp;&emsp; copy_properties(fn, wrapper)<br>&emsp;&emsp;&emsp; return wrapper  </p><p>&emsp;&emsp;@logger #add = logger(add)<br>&emsp;&emsp; def add(x,y):<br>&emsp;&emsp;&emsp; ‘’’This is a function for add’’’<br>&emsp;&emsp;&emsp; return x + y  </p><p>&emsp;&emsp; print(“name={}, doc={}”.format(add.__name__, add.__doc__))  </p><h2 id="装饰器-10"><a href="#装饰器-10" class="headerlink" title="装饰器"></a>装饰器</h2><ul><li>通过copy_properties函数将被包装函数的属性覆盖掉包装函数</li><li>凡是被装饰的函数都需要复制这些属性，这个函数很通用</li><li>可以将复制属性的函数构建成装饰器函数，带参装饰器</li></ul><h2 id="装饰器-11"><a href="#装饰器-11" class="headerlink" title="装饰器"></a>装饰器</h2><ul><li>提供一个函数，被封装函数属性 ==copy==&gt; 包装函数属性，改造成带参装饰器<br>def copy_properties(src): # 柯里化<br>&emsp; def _copy(dst):<br>&emsp;&emsp; dst.__name__ = src.__name__<br>&emsp;&emsp; dst.__doc__ = src.__doc__<br>&emsp;&emsp; return dst<br>&emsp; return _copy<br>def logger(fn):<br>&emsp; <strong>@copy_properties(fn) # wrapper = copy_properties(fn)(wrapper)</strong><br>&emsp; # copy_properties()原本是需要2个参数的，这里柯里化了。<br>&emsp; # @func(xxx)中的func(xxx)得到一个newfunc=&gt;@newfunc，得到新的装饰器函数，它一般写在被装饰的函数上面。<br>&emsp; def wrapper(*args,**kwargs):<br>&emsp;&emsp; ‘I am wrapper’<br>&emsp;&emsp; print(‘begin’)<br>&emsp;&emsp; x = fn(*args,**kwargs)<br>&emsp;&emsp; print(‘end’)<br>&emsp;&emsp; return x<br>&emsp; return wrapper  </li></ul><p>&emsp;&emsp; @logger #add = logger(add)<br>&emsp;&emsp; def add(x,y):<br>&emsp;&emsp;&emsp; ‘’’This is a function for add’’’<br>&emsp;&emsp;&emsp; return x + y<br>&emsp;&emsp; print(“name={}, doc={}”.format(add.__name__, add.__doc__))  </p><h2 id="带参装饰器"><a href="#带参装饰器" class="headerlink" title="带参装饰器"></a>带参装饰器</h2><ul><li>需求，对原来函数再做功能的增强，里面再要传参呢？  <ul><li>获取函数的执行时长，对时长超过阈值的函数记录一下<br><strong>def</strong> logger(duration):  # logger(fn, duration)不合适，需要柯里化<br>&emsp; <strong>def</strong> _logger(fn):<br>&emsp;&emsp; @copy_properties(fn) # wrapper = wrapper(fn)(wrapper)<br>&emsp;&emsp; <strong>def</strong> wrapper(<em>args,**kwargs):<br>&emsp;&emsp;&emsp; start = datetime.datetime.now()<br>&emsp;&emsp;&emsp; ret = fn(</em>args,**kwargs)<br>&emsp;&emsp;&emsp; delta = (datetime.datetime.now() - start).total_seconds()<br>&emsp;&emsp;&emsp; print(‘so slow’) if delta &gt; duration else print(‘so fast’)<br>&emsp;&emsp;&emsp; return ret<br>&emsp;&emsp; return wrapper<br>&emsp; return _logger  </li></ul></li></ul><p>&emsp;&emsp;&emsp;&emsp; <strong>@logger(5)</strong> # add = logger(5)(add)<br>&emsp;&emsp;&emsp;&emsp; # 语法糖只会add=logger(add)不会识别add=logger(add, 50)，不能别参数，所以要柯里化<br>&emsp;&emsp;&emsp;&emsp; # 如果有多个参数要传，则直接写，如 logger(5,6,7)。。。没必要再做柯里化<br>&emsp;&emsp;&emsp;&emsp; def add(x,y):<br>&emsp;&emsp;&emsp;&emsp;&emsp; time.sleep(3)<br>&emsp;&emsp;&emsp;&emsp;&emsp; return x + y  </p><p>&emsp;&emsp;&emsp;&emsp; print(add(5, 6))  </p><h2 id="带参装饰器-1"><a href="#带参装饰器-1" class="headerlink" title="带参装饰器"></a>带参装饰器</h2><ul><li>带参装饰器</li><li>它是一个函数</li><li>函数作为它的形参</li><li>返回值是一个不带参的装饰器函数(特殊情况也不一定)</li><li>使用@functionname(参数列表)方式调用</li><li>可以看做在装饰器外层又加了一层函数</li></ul><h2 id="带参装饰器-2"><a href="#带参装饰器-2" class="headerlink" title="带参装饰器"></a>带参装饰器</h2><ul><li>将记录的功能提取出来，这样就可以通过外部提供的函数来灵活的控制输出<br>def logger(duration, <strong>func=lambda name, duration: print(‘{} took {}s’.format(name, duration))</strong>):<br>&emsp; def _logger(fn):<br>&emsp;&emsp; @copy_properties(fn) # wrapper = wrapper(fn)(wrapper)<br>&emsp;&emsp; def wrapper(*args,**kwargs):<br>&emsp;&emsp;&emsp; start = datetime.datetime.now()<br>&emsp;&emsp;&emsp; ret = fn(*args,**kwargs)<br>&emsp;&emsp;&emsp; delta = (datetime.datetime.now() - start)  .total_seconds()<br>&emsp;&emsp;&emsp; if delta &gt; duration:<br>&emsp;&emsp;&emsp;&emsp; <strong>func(fn.__name__, duration)</strong><br>&emsp;&emsp;&emsp; return ret<br>&emsp;&emsp; return wrapper<br>&emsp; return _logger</li></ul><h2 id="functools模块"><a href="#functools模块" class="headerlink" title="functools模块"></a>functools模块</h2><ul><li><a href="https://segmentfault.com/a/1190000009398663" target="_blank" rel="noopener">简单聊聊Python中的wraps修饰器</a>  </li><li>functools.update_wrapper(wrapper, wrapped , assigned=WRAPPER_ASSIGNMENTS, updated=WRAPPER_UPDATES)<ul><li>类似copy_properties功能</li><li>wrapper 包装函数、被更新者，wrapped 被包装函数、数据源</li><li>元组WRAPPER_ASSIGNMENTS中是要被覆盖的属性<br>‘__module__‘, ‘__name__‘, ‘__qualname__‘, ‘__doc__‘, ‘__annotations__‘<br>模块名、名称、限定名、文档、参数注解  </li><li>元组WRAPPER_UPDATES中是要被更新的属性，__dict__属性字典</li><li>增加一个__wrapped__属性，保留着wrapped函数</li></ul></li></ul><h2 id="functools模块-1"><a href="#functools模块-1" class="headerlink" title="functools模块"></a>functools模块</h2><p>import datetime, time, functools  </p><p>def logger(duration, func=lambda name, duration: print(‘{} took {}s’.format(name, duration))):<br>&emsp; def _logger(fn):<br>&emsp;&emsp; def wrapper(*args,**kwargs):<br>&emsp;&emsp;&emsp; start = datetime.datetime.now()<br>&emsp;&emsp;&emsp; ret = fn(*args,**kwargs)<br>&emsp;&emsp;&emsp; delta = (datetime.datetime.now() - start).total_seconds()<br>&emsp;&emsp;&emsp; if delta &gt; duration:<br>&emsp;&emsp;&emsp;&emsp; func(fn.__name__, duration)<br>&emsp;&emsp;&emsp; return ret<br>&emsp;&emsp; return <strong>functools.update_wrapper(wrapper, fn)</strong><br>&emsp; return _logger  </p><p>@logger(5) # add = logger(5)(add)<br>def add(x,y):<br>&emsp; time.sleep(1)<br>&emsp; return x + y  </p><p>print(add(5, 6), add.__name__, add.__wrapped__, add.__dict__, sep=’\n’)  </p><h2 id="functools模块-2"><a href="#functools模块-2" class="headerlink" title="functools模块"></a>functools模块</h2><ul><li>@functools.wraps(wrapped, assigned=WRAPPER_ASSIGNMENTS, updated=WRAPPER_UPDATES)<ul><li>类似copy_properties功能</li><li>wrapped 被包装函数</li><li>元组WRAPPER_ASSIGNMENTS中是要被覆盖的属性<br>‘__module__‘, ‘__name__‘, ‘__qualname__‘, ‘__doc__‘, ‘__annotations__‘<br>模块名、名称、限定名、文档、参数注解  </li><li>元组WRAPPER_UPDATES中是要被更新的属性，<strong>dict</strong>属性字典</li><li>增加一个<strong>wrapped</strong>属性，保留着wrapped函数</li></ul></li></ul><h2 id="functools模块-3"><a href="#functools模块-3" class="headerlink" title="functools模块"></a>functools模块</h2><p>import datetime, time, functools  </p><p>def logger(duration, func=lambda name, duration: print(‘{} took {}s’.format(name, duration))):<br>&emsp; def _logger(fn):<br>&emsp;&emsp; <a href="mailto:**@functools.wraps" target="_blank" rel="noopener">**@functools.wraps</a>(fn)*<em><br>&emsp;&emsp; def wrapper(\</em>args,**kwargs):<br>&emsp;&emsp;&emsp; start = datetime.datetime.now()<br>&emsp;&emsp;&emsp; ret = fn(*args,**kwargs)<br>&emsp;&emsp;&emsp; delta = (datetime.datetime.now() - start).total_seconds()<br>&emsp;&emsp;&emsp; if delta &gt; duration:<br>&emsp;&emsp;&emsp;&emsp; func(fn.__name__, duration)<br>&emsp;&emsp;&emsp; return ret<br>&emsp;&emsp; return wrapper<br>&emsp;return _logger</p><p>@logger(5) # add = logger(5)(add)<br>def add(x,y):<br>&emsp; time.sleep(1)<br>&emsp;return x + y  </p><p>print(add(5, 6), add.__name__, add.__wrapped__, add.__dict__, sep=’\n’)  </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;第十四章-Python-装饰器&quot;&gt;&lt;a href=&quot;#第十四章-Python-装饰器&quot; class=&quot;headerlink&quot; title=&quot;第十四章 - Python 装饰器&quot;&gt;&lt;/a&gt;第十四章 - Python 装饰器&lt;/h1&gt;&lt;h2 id=&quot;装饰器&quot;&gt;&lt;a h
      
    
    </summary>
    
      <category term="python-magedu" scheme="https://herodanny.github.io/categories/python-magedu/"/>
    
    
      <category term="python" scheme="https://herodanny.github.io/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>python全栈-magedu-2018-笔记20</title>
    <link href="https://herodanny.github.io/python-magedu-2018-notes20.html"/>
    <id>https://herodanny.github.io/python-magedu-2018-notes20.html</id>
    <published>2019-05-09T14:07:43.000Z</published>
    <updated>2019-05-19T12:49:16.074Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第十三章-Python高阶函数、柯里化"><a href="#第十三章-Python高阶函数、柯里化" class="headerlink" title="第十三章 - Python高阶函数、柯里化"></a>第十三章 - Python高阶函数、柯里化</h1><h2 id="高阶函数"><a href="#高阶函数" class="headerlink" title="高阶函数"></a>高阶函数</h2><ul><li>First Class Object<ul><li>函数在Python中是一等公民</li><li>函数也是对象，可调用的对象</li><li>函数可以作为普通变量、参数、返回值等等</li></ul></li><li>高阶函数<ul><li>数学概念 y=g(f(x))</li><li>在数学和计算机科学中，高阶函数应当是至少满足下面一个条件的函数<ul><li>接受一个或多个函数作为参数</li><li>输出一个函数</li></ul></li></ul></li></ul><h2 id="高阶函数-1"><a href="#高阶函数-1" class="headerlink" title="高阶函数"></a>高阶函数</h2><ul><li>计数器<br>def counter(base):<br>&emsp; def inc(step=1):<br>&emsp;&emsp; base += step<br>&emsp;&emsp; return base<br>&emsp; return inc</li><li>分析：<ul><li>函数couter是不是一个高阶函数？# 只要满足上面一个条件，就是高阶函数。  </li><li>上面代码有没有什么问题？怎样改进 # base是counter的本地变量，base在inc新的变量赋值，所以会报错  </li><li>如何调用完成计数功能</li><li>f1 = counter(5)和f2=counter(5)，请问f1和f2相等吗？<br>可以把内层函数inc看成counter的本地变量，压栈时都会重新生成  </li></ul></li></ul><h2 id="自定义sort函数"><a href="#自定义sort函数" class="headerlink" title="自定义sort函数"></a>自定义sort函数</h2><ul><li><p>排序问题</p><ul><li>仿照内建函数sorted，请自行实现一个sort函数（不使用内建函数），能够为列表元素排序</li></ul></li><li><p>思路</p><ul><li>内建函数sorted函数是返回一个<strong>新的列表</strong>，可以设置<strong>升序或降序</strong>，可以设置一个<strong>排序的函数</strong>。<br>自定义的sort函数也要实现这个功能</li><li>新建一个列表，遍历原列表，和新列表的值依次比较决定如何插入到新列表中</li></ul></li><li><p>思考</p><ul><li>sorted函数的实现原理，扩展到map、filter函数的实现原理</li></ul></li></ul><h2 id="自定义sort函数-1"><a href="#自定义sort函数-1" class="headerlink" title="自定义sort函数"></a>自定义sort函数</h2><ul><li>sort函数实现。下面实现的什么排序？还能怎么改变<br>def sort(iterable):<br>&emsp; ret = [ ]<br>&emsp; for x in iterable:<br>&emsp;&emsp; for i, y in enumerate(ret):<br>&emsp;&emsp;&emsp; if x &gt; y: # 找到大的就地插入。如果换成x &lt; y呢，函数什么意思呢？<br>&emsp;&emsp;&emsp;&emsp; ret.insert(i,x) # 降序<br>&emsp;&emsp;&emsp;&emsp; break<br>&emsp;&emsp;&emsp; else: # 不大于，说明是最小的，尾部追加<br>&emsp;&emsp;&emsp;&emsp; ret.append(x)<br>&emsp; return ret<br>print(sort([1,2,5,4,2,3,5,6]))  </li></ul><h2 id="自定义sort函数-2"><a href="#自定义sort函数-2" class="headerlink" title="自定义sort函数"></a>自定义sort函数</h2><ul><li><p>sort函数实现。用一个参数控制顺序<br>def sort(iterable, reverse=False):<br>&emsp; ret = []<br>&emsp; for x in iterable:<br>&emsp;&emsp; for i, y in enumerate(ret):<br>&emsp;&emsp;&emsp; flag = x&gt;y if reverse else x&lt;y<br>&emsp;&emsp;&emsp; if flag: # 是否能进一步改进<br>&emsp;&emsp;&emsp;&emsp; ret.insert(i,x)<br>&emsp;&emsp;&emsp;&emsp; break<br>&emsp;&emsp;&emsp; else:<br>&emsp;&emsp;&emsp;&emsp; ret.append(x)<br>&emsp; return ret<br>print(sort([1,2,5,4,2,3,5,6]))</p></li><li><p>x&gt;y 这种比较逻辑比较死，可以改成灵活的函数。<br>def sort(iterable, reverse=False):<br>&emsp; def comp(a, b):<br>&emsp;&emsp; return a&gt;b if reverse else a&lt;b<br>&emsp; ret = []<br>&emsp; for x in iterable:<br>&emsp;&emsp; for i, y in enumerate(ret):<br>&emsp;&emsp;&emsp; if comp(x, y):<br>&emsp;&emsp;&emsp;&emsp; ret.insert(i,x)<br>&emsp;&emsp;&emsp;&emsp; break<br>&emsp;&emsp;&emsp; else:<br>&emsp;&emsp;&emsp;&emsp; ret.append(x)<br>&emsp; return ret<br>print(sort([1,2,5,4,2,3,5,6]))</p></li><li><p>comp 是内部函数，别人用不了，要放到外面<br>def comp(a, b, reverse):<br>&emsp; return a&gt;b if reverse else a&lt;b  </p></li></ul><p>&emsp;&emsp; def sort(iterable, reverse=False):<br>&emsp;&emsp;&emsp; ret = []<br>&emsp;&emsp;&emsp; for x in iterable:<br>&emsp;&emsp;&emsp;&emsp; for i, y in enumerate(ret):<br>&emsp;&emsp;&emsp;&emsp;&emsp; if comp(x, y, reverse):<br>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp; ret.insert(i,x)<br>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp; break<br>&emsp;&emsp;&emsp;&emsp;&emsp; else:<br>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp; ret.append(x)<br>&emsp;&emsp;&emsp; return ret<br>&emsp;&emsp; print(sort([1,2,5,4,2,3,5,6]))</p><ul><li>把sort写成高阶函数形式<br>def comp(a, b):<br>&emsp; return a &lt; b  </li></ul><p>&emsp;&emsp; def sort(iterable, key=comp, reverse=False):<br>&emsp;&emsp;&emsp; ret = []<br>&emsp;&emsp;&emsp; for x in iterable:<br>&emsp;&emsp;&emsp;&emsp; for i, y in enumerate(ret):<br>&emsp;&emsp;&emsp;&emsp;&emsp; flag = key(x, y) if reverse else key(y, x)<br>&emsp;&emsp;&emsp;&emsp;&emsp; if flag:<br>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp; ret.insert(i,x)<br>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp; break<br>&emsp;&emsp;&emsp;&emsp;&emsp; else:<br>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp; ret.append(x)<br>&emsp;&emsp;&emsp; return ret<br>&emsp;&emsp; print(sort([1,2,5,4,2,3,5,6]))</p><ul><li>comp是一行函数，可以写成 lambda 表达式</li></ul><h2 id="自定义sort函数-3"><a href="#自定义sort函数-3" class="headerlink" title="自定义sort函数"></a>自定义sort函数</h2><ul><li>sort函数实现。下面实现的什么排序？还能怎么改变<br>def sort(iterable, key=lambda a,b : a&gt;b):<br>&emsp; ret = [ ]<br>&emsp; for x in iterable:<br>&emsp;&emsp; for i, y in enumerate(ret):<br>&emsp;&emsp;&emsp;&emsp; if key(x, y): # 函数的返回值是bool<br>&emsp;&emsp;&emsp;&emsp;&emsp; ret.insert(i,x)<br>&emsp;&emsp;&emsp;&emsp;&emsp; break<br>&emsp;&emsp;&emsp;&emsp; else:<br>&emsp;&emsp;&emsp;&emsp;&emsp; ret.append(x)<br>&emsp; return ret<br>print(sort([1,2,5,4,2,3,5,6]), lambda a,b:a&gt;b) # 升序还是降序？如何反序？  </li></ul><h2 id="自定义sort函数-4"><a href="#自定义sort函数-4" class="headerlink" title="自定义sort函数"></a>自定义sort函数</h2><ul><li>sort函数实现<br>def sort(iterable, reverse=False, key=lambda x,y:x&lt;y):<br>&emsp; ret = []<br>&emsp; for x in iterable:<br>&emsp;&emsp; for i,y in enumerate(ret):<br>&emsp;&emsp;&emsp; flag = key(x,y) if not reverse else not key(x,y)<br>&emsp;&emsp;&emsp; if flag:<br>&emsp;&emsp;&emsp;&emsp; ret.insert(i, x)<br>&emsp;&emsp;&emsp;&emsp; break<br>&emsp;&emsp; else:<br>&emsp;&emsp;&emsp; ret.append(x)<br>&emsp; return ret<br>print(sort([1,2,5,4,2,3,5,6]))</li></ul><h2 id="内建函数-高阶函数"><a href="#内建函数-高阶函数" class="headerlink" title="内建函数-高阶函数"></a>内建函数-高阶函数</h2><ul><li>sorted(iterable[, key][, reverse])<ul><li>排序</li></ul></li><li>filter(function, iterable) –&gt; filter object<ul><li>过滤数据</li></ul></li><li>map(func, *iterables) –&gt; map object<ul><li>映射</li></ul></li></ul><h2 id="内建函数-高阶函数-1"><a href="#内建函数-高阶函数-1" class="headerlink" title="内建函数-高阶函数"></a>内建函数-高阶函数</h2><ul><li>sorted(iterable[, key][, reverse]) 排序  <ul><li>返回一个新的列表，对一个可迭代对象的所有元素排序，排序规则为key定义的函数，reverse表示是否排序翻转</li><li>sorted(lst,key=lambda x:6-x) # 返回新列表<br>key只能对一个元素操作，与我们前面自己写的不同，前面的key是x,y对两个元素操作。<br>key只是对元素生成一个新的临时元素用来比较，并不会修改原来的元素。这里6-x只是计算出一个临时值。用来比较的。<br>比较完，添加的是原本的值到新序列中。举例list是[1,2,3,4,5,6]，那么比较的结果就是[6,5,4,3,2,1]  </li><li>list.sort(key=lambda x: 6-x) # 就地修改</li></ul></li></ul><h2 id="内建函数-高阶函数-2"><a href="#内建函数-高阶函数-2" class="headerlink" title="内建函数-高阶函数"></a>内建函数-高阶函数</h2><ul><li><p>filter(function, iterable)</p><ul><li>过滤可迭代对象的元素，返回一个迭代器（迭代器是惰性求值）  </li><li>function一个具有一个参数的函数，返回bool</li><li>例如，过滤出数列中能被3整除的数字<br>list(filter(lambda x: x%3==0, [1,9,55,150,-3,78,28,123]))  </li></ul></li><li><p>map(function, *iterables) –&gt; map object</p><ul><li>对可迭代对象的元素按照指定的函数进行映射(就是把元素当成key得到value)，返回一个迭代器<ul><li>list(map(lambda x:2*x+1, range(5)))</li><li>dict(map(lambda x: (x%5,x) , range(500)))<br>*iterables意思是收集n个可迭代对象，%5说明key不会超过5  </li></ul></li></ul></li></ul><h2 id="柯里化-Currying"><a href="#柯里化-Currying" class="headerlink" title="柯里化 Currying"></a>柯里化 Currying</h2><ul><li>柯里化<ul><li>指的是将原来接受两个参数的函数变成新的接受一个参数的函数的过程。新的函数返回一个以原有第二个参数为参数的函数</li><li>z = f(x, y) 转换成 z = f(x)(y)的形式</li></ul></li><li>举例  <ul><li>将加法函数柯里化<br>&emsp; def add(x, y):<br>&emsp;&emsp; return x + y  </li><li>转换如下<br>&emsp; def add(x):<br>&emsp;&emsp; def _add(y):<br>&emsp;&emsp;&emsp; return x+y<br>&emsp;&emsp; return _add<br>&emsp; add(5)(6)</li></ul></li><li>通过嵌套函数(返回值是函数)就可以把函数转换成柯里化函数</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;第十三章-Python高阶函数、柯里化&quot;&gt;&lt;a href=&quot;#第十三章-Python高阶函数、柯里化&quot; class=&quot;headerlink&quot; title=&quot;第十三章 - Python高阶函数、柯里化&quot;&gt;&lt;/a&gt;第十三章 - Python高阶函数、柯里化&lt;/h1&gt;&lt;
      
    
    </summary>
    
      <category term="python-magedu" scheme="https://herodanny.github.io/categories/python-magedu/"/>
    
    
      <category term="python" scheme="https://herodanny.github.io/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>python全栈-magedu-2018-笔记19</title>
    <link href="https://herodanny.github.io/python-magedu-2018-notes19.html"/>
    <id>https://herodanny.github.io/python-magedu-2018-notes19.html</id>
    <published>2019-05-09T00:04:58.000Z</published>
    <updated>2019-05-19T12:47:30.366Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第十二章-Python-生成器"><a href="#第十二章-Python-生成器" class="headerlink" title="第十二章 - Python 生成器"></a>第十二章 - Python 生成器</h1><h2 id="生成器"><a href="#生成器" class="headerlink" title="生成器***"></a>生成器***</h2><ul><li><p>生成器generator</p><ul><li>生成器指的是生成器对象，可以由生成器表达式得到，也可以使用yield关键字得到一个生成器函数，调用这个函数得到一个生成器对象</li></ul></li><li><p>生成器函数</p><ul><li>函数体中包含yield语句的函数，返回生成器对象</li><li>生成器对象，是一个可迭代对象，是一个迭代器</li><li>生成器对象，是延迟计算、惰性求值的</li></ul></li></ul><h2 id="生成器-1"><a href="#生成器-1" class="headerlink" title="生成器"></a>生成器</h2><ul><li><p>举例<br>def inc():<br>&emsp; for i in range(5):<br>&emsp;&emsp; yield i<br>print(type(inc))  # <class 'function'><br>print(type(inc()))  # 生成器函数inc返回值是生成器 <class 'generator'><br>x = inc()<br>print(type(x))  # <class 'generator'><br>print(next(x))  # 0<br>for m in x:<br>&emsp; print(m, ‘<em>‘)  # 输出：1 </em>、2 <em>、3 </em>、4 *<br>for m in x:  # 生成器用完了，再迭代也不会报StopIteration，如果直接next(x)会<br>&emsp; print(m, ‘**’)  </class></class></class></p></li><li><p>举例<br>y = (i for i in range(5))  # 生成器表达式等价于上面的生成器函数<br>print(type(y))<br>print(next(y))<br>print(next(y))  </p></li><li><p>普通的函数调用fn()，函数会立即执行完毕，但是生成器函数可以使用next函数多次执行</p></li><li>生成器函数等价于生成器表达式，只不过生成器函数可以更加的复杂</li></ul><h2 id="生成器-2"><a href="#生成器-2" class="headerlink" title="生成器"></a>生成器</h2><ul><li>举例  </li></ul><p>def gen():<br>&emsp; print(‘line 1’)<br>&emsp; yield 1<br>&emsp; print(‘line 2’)<br>&emsp; yield 2<br>&emsp; print(‘line 3’)<br>&emsp; return 3</p><p>&emsp; next(gen()) # line 1，生成器函数gen()返回值是生成器<br>&emsp; next(gen()) # line 1，gen()又新创建一个生成器<br>&emsp; g = gen()<br>&emsp; print(next(g)) # line 1<br>&emsp; print(next(g)) # line 2<br>&emsp; print(next(g)) # StopIteration，gen中最后是return所以报错<br>&emsp; print(next(g, ‘End’)) # 没有元素给个缺省值  </p><ul><li>在生成器函数中，使用多个 yield 语句，执行一次后会暂停执行，把yield表达式的值返回</li><li>再次执行会执行下一个yield语句</li><li>return语句依然可以终止函数运行，但return语句的返回值不能被获取到</li><li>return会导致无法继续获取下一个值，抛出StopIteration异常</li><li>如果函数没有显示return语句，如果生成器函数执行到结尾，一样会抛出StopIteration异常</li></ul><h2 id="生成器-3"><a href="#生成器-3" class="headerlink" title="生成器"></a>生成器</h2><ul><li>生成器函数<ul><li>包含yield语句的生成器函数生成 生成器对象 的时候，<strong>生成器函数的函数体不会立即执行</strong>。  </li><li>next(generator)会从函数的当前位置向后执行之后碰到的第一个yield语句，会弹出值，并暂停函数执行</li><li>再次调用next 函数，和上一条一样的处理过程</li><li>没有多余的yield语句能被执行，继续调用next函数，会抛出StopIterator异常</li></ul></li></ul><h2 id="生成器-4"><a href="#生成器-4" class="headerlink" title="生成器"></a>生成器</h2><ul><li>无限循环  </li></ul><p>def counter():<br>&emsp; i = 0<br>&emsp; while True:<br>&emsp;&emsp; i += 1<br>&emsp;&emsp; yield i  </p><p>def inc(c):<br>&emsp; return next(c)<br>c = counter()<br>print(inc(c))<br>print(inc(c))  </p><p>def counter():<br>&emsp; i = 0<br>&emsp; while True:<br>&emsp;&emsp; i += 1<br>&emsp;&emsp; yield i  </p><p>def inc():<br>&emsp; c = counter()<br>&emsp; return next(c)  </p><p>print(inc()) # 是什么<br>print(inc()) # 是什么<br>print(inc()) # 是什么  </p><h2 id="生成器应用"><a href="#生成器应用" class="headerlink" title="生成器应用"></a>生成器应用</h2><ul><li>计数器  </li></ul><p>def inc():<br>&emsp; def counter():<br>&emsp;&emsp; i = 0<br>&emsp;&emsp; while True:<br>&emsp;&emsp;&emsp; i += 1<br>&emsp;&emsp;&emsp; yield i<br>&emsp;&emsp; c = counter()  # c是生成器<br>&emsp;&emsp; return lambda : next(c)  </p><p>foo = inc()<br>print(foo())<br>print(foo())  </p><ul><li>lambda 表达式是匿名函数</li><li>return 返回的是一个匿名函数。且c是外层自由变量，有闭包  </li><li>等价于下面的代码  </li></ul><p><img src="https://raw.githubusercontent.com/herodanny/Image-Hosting/master/data/shengchengqi1.jpg" alt="shengchengqi1"></p><p>简单函数都可以用lambda函数代替，慢慢练。  </p><h2 id="生成器应用-1"><a href="#生成器应用-1" class="headerlink" title="生成器应用"></a>生成器应用</h2><ul><li>处理递归问题</li></ul><p>def fib():<br>&emsp; x = 0<br>&emsp; y = 1<br>&emsp; while True:<br>&emsp;&emsp; yield y<br>&emsp;&emsp; x, y = y, x+y  </p><p>foo = fib()<br>for _ in range(5):<br>&emsp; print(next(foo))  </p><p>for _ in range(100):<br>&emsp; next(foo)<br>print(next(foo))  </p><ul><li>等价于下面的代码  </li></ul><p><img src="https://raw.githubusercontent.com/herodanny/Image-Hosting/master/data/shengchengqi2.jpg" alt="shengchengqi2">  </p><h2 id="生成器应用-2"><a href="#生成器应用-2" class="headerlink" title="生成器应用"></a>生成器应用</h2><ul><li>协程 coroutine  <ul><li>生成器的高级用法</li><li>比进程、线程轻量级</li><li>是在用户控件调度函数的一种实现</li><li>Python3 asyncio 就是协程实现，已经加入到标准库</li><li>Python3.5 使用 async、await 关键字直接原生支持协程</li><li>协程调度器实现思路<ul><li>有2个生成器A、B</li><li>next(A)后，A执行到了yield语句暂停，然后去执行next(B)，B执行到yield语句也暂停，然后再次调用next(A)，再调用next(B)在，周而复始，就实现了调度的效果</li><li>可以引入调度的策略来实现切换的方式</li></ul></li><li>协程是一种非抢占式调度</li><li><a href="https://blog.csdn.net/soonfly/article/details/78361819" target="_blank" rel="noopener">理解Python协程:从yield/send到yield from再到async/await</a>  </li></ul></li></ul><h2 id="yield-from"><a href="#yield-from" class="headerlink" title="yield from"></a>yield from</h2><p><img src="https://raw.githubusercontent.com/herodanny/Image-Hosting/master/data/yieldfrom1.jpg" alt="yieldfrom1"></p><h2 id="yield-from-1"><a href="#yield-from-1" class="headerlink" title="yield from"></a>yield from</h2><ul><li>yield from 是 Python3.3出现的新的语法</li><li>yield from iterable 是 for item in iterable: yield item 形式的语法糖<ul><li>从可迭代对象中一个个拿元素<br>def counter(n): # 生成器<br>&emsp;&emsp; for x in range(n):<br>&emsp;&emsp;&emsp; yield x  </li></ul></li></ul><p>&emsp;&emsp;&emsp;&emsp; def inc(n):<br>&emsp;&emsp;&emsp;&emsp;&emsp; yield from counter(n)<br>&emsp;&emsp;&emsp;&emsp;&emsp; 等价为：<br>&emsp;&emsp;&emsp;&emsp;&emsp; for x in counter(n):<br>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp; yield x</p><p>&emsp;&emsp;&emsp;&emsp; foo = inc(10)<br>&emsp;&emsp;&emsp;&emsp; print(next(foo))<br>&emsp;&emsp;&emsp;&emsp; print(next(foo))  </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;第十二章-Python-生成器&quot;&gt;&lt;a href=&quot;#第十二章-Python-生成器&quot; class=&quot;headerlink&quot; title=&quot;第十二章 - Python 生成器&quot;&gt;&lt;/a&gt;第十二章 - Python 生成器&lt;/h1&gt;&lt;h2 id=&quot;生成器&quot;&gt;&lt;a h
      
    
    </summary>
    
      <category term="python-magedu" scheme="https://herodanny.github.io/categories/python-magedu/"/>
    
    
      <category term="python" scheme="https://herodanny.github.io/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>python全栈-magedu-2018-笔记18</title>
    <link href="https://herodanny.github.io/python-magedu-2018-notes18.html"/>
    <id>https://herodanny.github.io/python-magedu-2018-notes18.html</id>
    <published>2019-05-08T07:38:40.000Z</published>
    <updated>2019-05-19T12:45:57.550Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第十一章-Python-匿名函数"><a href="#第十一章-Python-匿名函数" class="headerlink" title="第十一章 - Python 匿名函数"></a>第十一章 - Python 匿名函数</h1><h2 id="匿名函数"><a href="#匿名函数" class="headerlink" title="匿名函数"></a>匿名函数</h2><ul><li>匿名函数，即没有名字的函数<ul><li>没有名字如何定义</li><li>没有名字如何调用</li><li>如果能调用，如何使用</li></ul></li></ul><h2 id="匿名函数-1"><a href="#匿名函数-1" class="headerlink" title="匿名函数"></a>匿名函数</h2><ul><li>Python 借助 Lambda 表达式构建匿名函数</li><li>格式<ul><li>lambda 参数列表 : 表达式<br>lambda x : x <strong> 2<br>(lambda x : x </strong> 2)(4) # 调用<br>foo = lambda x, y : (x + y) <strong> 2 # 不推荐这么用，因为用lambda就是为了匿名使用<br>foo(2, 1)<br>def foo(x,y): #  建议使用普通函数<br>&emsp; return (x + y) </strong> 2<br>foo(2, 1)  </li></ul></li></ul><h2 id="匿名函数-2"><a href="#匿名函数-2" class="headerlink" title="匿名函数"></a>匿名函数</h2><ul><li>使用 lambda 关键字来定义匿名函数</li><li>参数列表不需要小括号</li><li>冒号是用来分割参数列表和表达式的</li><li>不需要使用 return，表达式的值，就是匿名函数返回值</li><li>lambda 表达式（匿名函数）<strong>只能写在一行上</strong>，被称为单行函数</li><li>用途<ul><li>在高阶函数传参时，使用 lambda 表达式，往往能简化代码</li></ul></li></ul><h2 id="匿名函数-3"><a href="#匿名函数-3" class="headerlink" title="匿名函数"></a>匿名函数</h2><ul><li>print((lambda :0)())  </li><li>print((lambda x, y=3: x + y)(5))  </li><li>print((lambda x, y=3: x + y)(5, 6))</li><li>print((lambda x, *, y=30: x + y)(5))</li><li>print((lambda x, *, y=30: x + y)(5, y=10))</li><li>print((lambda *args: (x for x in args))(*range(5))) <ul><li>*args是可变位置参数组成一个元组 表达式是生成器表达式是惰性求值的 最后是实参解构</li></ul></li><li>print((lambda *args: [x+1 for x in args])(*range(5)))<ul><li>表达式是列表解析式</li></ul></li><li>print((lambda *args: {x+2 for x in args})(*range(5)))<ul><li>集合解析式</li></ul></li><li>[x for x in (lambda *args: map(lambda x: x+1, args))(*range(5))] # 高阶函数<ul><li>是一个大的列表解析式</li></ul></li><li>[x for x in (lambda *args: map(lambda x: (x+1,args), args))(*range(5))] # map中的lambda中的表达式是在凑个元组</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;第十一章-Python-匿名函数&quot;&gt;&lt;a href=&quot;#第十一章-Python-匿名函数&quot; class=&quot;headerlink&quot; title=&quot;第十一章 - Python 匿名函数&quot;&gt;&lt;/a&gt;第十一章 - Python 匿名函数&lt;/h1&gt;&lt;h2 id=&quot;匿名函数&quot;
      
    
    </summary>
    
      <category term="python-magedu" scheme="https://herodanny.github.io/categories/python-magedu/"/>
    
    
      <category term="python" scheme="https://herodanny.github.io/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>python全栈-magedu-2018-笔记17</title>
    <link href="https://herodanny.github.io/python-magedu-2018-notes17.html"/>
    <id>https://herodanny.github.io/python-magedu-2018-notes17.html</id>
    <published>2019-05-08T05:04:34.000Z</published>
    <updated>2019-05-19T12:43:21.170Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第十章-Python-递归函数"><a href="#第十章-Python-递归函数" class="headerlink" title="第十章 - Python 递归函数"></a>第十章 - Python 递归函数</h1><h2 id="函数执行流程"><a href="#函数执行流程" class="headerlink" title="函数执行流程"></a>函数执行流程</h2><p><a href="http://pythontutor.com/visualize.html#mode=edit" target="_blank" rel="noopener">http://pythontutor.com/visualize.html#mode=edit</a>  </p><p>def foo1(b, b1=3):<br>&emsp; print(“foo1 called”, b, b1)</p><p>def foo2(c):<br>&emsp; foo3(c)<br>&emsp; print(“foo2 called”, c)  </p><p>def foo3(d):<br>&emsp; print(“foo3 called”, d)  </p><p>def main():<br>&emsp; print(“main called”)<br>&emsp; foo1(100, 101)<br>&emsp; foo2(200)<br>&emsp; print(“main ending”)  </p><p>main()  </p><ul><li>全局帧中生成foo1、foo2、foo3、main 函数对象  </li><li>main函数调用</li><li>main中查找内建函数print压栈，将常量字符串压栈，调用函数(指调用print函数)，弹出栈顶(调用完将字符串弹出)</li><li>main中全局查找函数foo1压栈，将常量100、101压栈，调用函数foo1，创建栈帧。print函数压栈，字符串和变量b、b1压栈，调用函数，弹出栈顶，返回值。  </li><li>main中全局查找foo2函数压栈，将常量200压栈，调用foo2，创建栈帧。foo3函数压栈，变量c引用压栈，调用foo3，创建栈帧。foo3完成print函数调用后返回。foo2恢复调用，执行print后，返回值。main中foo2调用结束弹出栈顶，继续执行print函数调用，弹出栈顶。main函数返回。  </li></ul><p><img src="https://raw.githubusercontent.com/herodanny/Image-Hosting/master/data/hanshuzhixingliucheng1.jpg" alt="hanshuzhixingliucheng1"></p><ul><li>调用函数，把调用函数压栈，参数压栈，创建栈帧，执行内部的东西，执行完弹出。恢复到前一个函数。</li><li>调用一个函数要保护当前的内容，把当前的执行到哪的环境信息要压入栈中，然后才是把要调用的函数压栈，参数压栈，创建栈帧，在里面执行它的语句。  </li></ul><h2 id="函数执行流程-1"><a href="#函数执行流程-1" class="headerlink" title="函数执行流程"></a>函数执行流程</h2><p><a href="http://pythontutor.com/visualize.html#mode=edit" target="_blank" rel="noopener">http://pythontutor.com/visualize.html#mode=edit</a>  </p><p><img src="https://raw.githubusercontent.com/herodanny/Image-Hosting/master/data/hanshuzhixingliucheng2.jpg" alt="hanshuzhixingliucheng2"></p><h2 id="递归-Recursion"><a href="#递归-Recursion" class="headerlink" title="递归 Recursion"></a>递归 Recursion</h2><ul><li>函数直接或者间接调用自身就是递归</li><li>递归需要有边界条件、递归前进段、递归返回段</li><li>递归一定要有<strong>边界条件</strong></li><li>当边界条件不满足的时候，递归前进</li><li>当边界条件满足的时候，递归返回</li></ul><p><img src="https://raw.githubusercontent.com/herodanny/Image-Hosting/master/data/digui.jpg" alt="digui"></p><h2 id="递归-Recursion-1"><a href="#递归-Recursion-1" class="headerlink" title="递归 Recursion"></a>递归 Recursion</h2><ul><li>斐波那契数列 Fibonacci number：1，1，2，3，5，8，13，21，34，55，89，144，。。。</li><li>如果有F(n) 为该数列的第n项，n是正整数，那么这句话可以写成如下形式：F(n)=F(n-1)+F(n-2)  </li><li>F(0)=0, F(1)=1, F(n)=F(n-1)+F(n-2)<br>pre = 0<br>cur = 1 # F(1)为1<br>print(pre, cur, end=’’)<br>n = 4<br>&emsp; # loop<br>for i in range(n-1):<br>&emsp; pre, cur = cur, pre+cur<br>&emsp; print(cur, end=’’)  </li></ul><h2 id="递归-Recursion-2"><a href="#递归-Recursion-2" class="headerlink" title="递归 Recursion"></a>递归 Recursion</h2><ul><li>F(0)=0, F(1)=1, F(n)=F(n-1)+F(n-2)  </li></ul><p>def fib(n):<br>&emsp; return 1 if n &lt; 2 else fib(n-1) + fib(n-2)  </p><p>for i in range(5):<br>&emsp; print(fib(i), end=’ ‘)  </p><p>解析：<br>fib(3) + fib(2)<br>fib(3) 调用 fib(3)、fib(2)、fib(1)<br>fib(2) 调用 fib(2)、fib(1)<br>fib(1) 是边界  </p><h2 id="递归-Recursion-3"><a href="#递归-Recursion-3" class="headerlink" title="递归 Recursion"></a>递归 Recursion</h2><ul><li>递归要求  <ul><li>递归一定要有退出条件，递归调用一定要执行到这个退出条件。没有退出条件的递归调用，就是无限调用  </li><li>递归调用的深度不宜过深  <ul><li>Python 对递归调用的深度做了限制，以保护解释器</li><li>超过递归深度限制，抛出 RecursionError：maxinum recursion depth exceeded 超出最大深度</li><li>sys.getrecursionlimit() # 1000</li></ul></li></ul></li></ul><h2 id="递归的性能"><a href="#递归的性能" class="headerlink" title="递归的性能"></a>递归的性能</h2><ul><li><p>for 循环<br>import datetime<br>start = datetime.datetime.now()<br>pre = 0<br>cur = 1<br>print(pre, cur, end=’ ‘)<br>n = 35<br>for i in range(n-1):<br>&emsp; pre, cur = cur, pre + cur<br>&emsp; print(cur, end=’ ‘)<br>delta = (datetime.datetime.now() - start).total_seconds()<br>print(delta)  </p></li><li><p>递归<br>import datetime<br>n = 35<br>start = datetime.datetime.now()<br>def fib(n):<br>&emsp; return 1 if n &lt; 2 else fib(n-1) + fib(n-2)<br>for i in range(n):<br>&emsp; print(fib(i), end=’ ‘)<br>delta = (datetime.datetime.now() - start).total_seconds()<br>print(delta)  </p></li></ul><h2 id="递归的性能-1"><a href="#递归的性能-1" class="headerlink" title="递归的性能"></a>递归的性能</h2><ul><li>循环稍微复杂一些，但是只要不是死循环，可以多次迭代直至算出结果  </li><li>fib函数代码极简易懂，但是只能获取到最外层的函数调用，内部递归结果都是中间结果。而且给定一个n都要进行近2n次递归，深度越深，效率越低。为了获取斐波那契数列需要外面在套一个n次的循环，效率就更低了</li><li>递归还有深度限制，如果递归复杂，函数反复压栈，栈内存很快就溢出了</li><li>思考：这个极简的递归代码能否提高性能呢？  </li></ul><h2 id="递归的性能-2"><a href="#递归的性能-2" class="headerlink" title="递归的性能"></a>递归的性能</h2><ul><li>斐波那契数列的改进<br>pre = 0<br>cur = 1 # No1<br>print(pre, cur, end=’ ‘)<br>def fib(n, pre=0, cur=1): # recursion<br>&emsp; pre, cur = cur, pre + cur<br>&emsp; print(cur, end=’ ‘)<br>&emsp; if n == 2:<br>&emsp;&emsp; return<br>&emsp; fib(n-1, pre, cur)  </li></ul><p>&emsp; fib(n)</p><ul><li><p>改进  </p><ul><li>上边的fib函数和循环的思想类似</li><li>参数n是边界条件，用n来计数</li><li>上一次的计算结果直接作为函数的实参</li><li>效率很高</li><li>和循环比较，性能相近。所以并不是说递归一定效率低下。但是递归有深度限制。</li></ul></li><li><p>对比一下三个fib函数的性能</p></li></ul><h2 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h2><ul><li>间接递归  </li></ul><p>&emsp; def foo1():<br>&emsp;&emsp; foo2()  </p><p>&emsp; def foo2():<br>&emsp;&emsp; foo1()</p><p>&emsp; foo1()</p><p>间接递归，是通过别的函数调用了函数自身。<br>但是，如果构成了循环递归调用是非常危险的，但是往往这种情况在代码复杂的情况下，还是可能发生这种调用。要用代码的规范来避免这种递归调用的发生。  </p><h2 id="递归总结"><a href="#递归总结" class="headerlink" title="递归总结"></a>递归总结</h2><ul><li>递归是一种很自然的表达，符合逻辑思维</li><li>递归相对运行效率低，每一次调用函数都要开辟栈帧</li><li>递归有深度限制，如果递归层次太深，函数反复压栈，栈内存很快就溢出了</li><li>如果是有限次数的递归，可以使用递归调用，或者使用循环代替，循环代码稍微复杂一些，但是只要不是死循环，可以多次迭代直至算出结果</li><li>绝大多数递归，都可以使用循环实现</li><li>即使递归代码很简洁，但是<strong>能不用则不用</strong>递归</li></ul><h2 id="递归练习"><a href="#递归练习" class="headerlink" title="递归练习"></a>递归练习</h2><ul><li>求n的阶乘</li><li>将一个数逆序放入列表中，例如1234 =&gt; [4,3,2,1]</li><li>解决猴子吃桃问题<ul><li>猴子第一天摘下若干桃子，当即吃了一半，还不过瘾，又多吃了一个。第二天早上又将剩下的桃子吃掉一半，又多吃了一个。以后每天早上都吃了前一天剩下的一半零一个。到第10天早上想吃时，只剩下一个桃子了。求第一天共摘多少个桃子。  </li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;第十章-Python-递归函数&quot;&gt;&lt;a href=&quot;#第十章-Python-递归函数&quot; class=&quot;headerlink&quot; title=&quot;第十章 - Python 递归函数&quot;&gt;&lt;/a&gt;第十章 - Python 递归函数&lt;/h1&gt;&lt;h2 id=&quot;函数执行流程&quot;&gt;&lt;
      
    
    </summary>
    
      <category term="python-magedu" scheme="https://herodanny.github.io/categories/python-magedu/"/>
    
    
      <category term="python" scheme="https://herodanny.github.io/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>python全栈-magedu-2018-笔记16</title>
    <link href="https://herodanny.github.io/python-magedu-2018-notes16.html"/>
    <id>https://herodanny.github.io/python-magedu-2018-notes16.html</id>
    <published>2019-05-07T09:43:54.000Z</published>
    <updated>2019-05-19T12:41:46.264Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第九章-Python-函数返回值、作用域"><a href="#第九章-Python-函数返回值、作用域" class="headerlink" title="第九章 - Python 函数返回值、作用域"></a>第九章 - Python 函数返回值、作用域</h1><h2 id="函数的返回值"><a href="#函数的返回值" class="headerlink" title="函数的返回值"></a>函数的返回值</h2><ul><li>举例<br>def showplus(x):<br>&emsp; print(x)<br>&emsp; return x + 1</li></ul><p>&emsp;&emsp; showplus(5)</p><ul><li>举例<br>def showplus(x):<br>&emsp; print(x)<br>&emsp; return x + 1<br>&emsp; print(x+1) # 会执行吗？  </li></ul><p>&emsp;&emsp; showplus(5)</p><h2 id="函数的返回值-1"><a href="#函数的返回值-1" class="headerlink" title="函数的返回值"></a>函数的返回值</h2><ul><li>多条return语句<br>def guess(x):<br>&emsp; if x &gt; 3:<br>&emsp;&emsp; return “&gt; 3”<br>&emsp; else:<br>&emsp;&emsp; return “&lt;= 3”  </li></ul><p>&emsp;&emsp; print(guess(10))  </p><ul><li>return可以执行多次吗？  </li><li>多条return语句<br>def showplus(x):<br>&emsp; print(x)<br>&emsp; return x + 1<br>&emsp; return x + 2  </li></ul><p>&emsp;&emsp; showplus(5)</p><h2 id="函数返回值"><a href="#函数返回值" class="headerlink" title="函数返回值"></a>函数返回值</h2><ul><li>举例<br>def fn(x):<br>&emsp; for i in range(x):<br>&emsp;&emsp; if i &gt; 3:<br>&emsp;&emsp;&emsp; return i<br>&emsp;&emsp; else:<br>&emsp;&emsp;&emsp; print(“{} is not greater than 3”.format(x))</li></ul><p>&emsp; print(fn(5)) # 打印什么？<br>&emsp; print(fn(3)) # 打印什么？</p><h2 id="函数的返回值-2"><a href="#函数的返回值-2" class="headerlink" title="函数的返回值"></a>函数的返回值</h2><ul><li>总结<ul><li>Python函数使用return语句返回“返回值”</li><li>所有函数都有返回值，如果没有return语句，隐式调用return None</li><li>return 语句并不一定是函数的语句块的最后一条语句</li><li>一个函数可以存在多个return语句，但是只有一条可以被执行。如果没有一条return语句被执行到，隐式调用return None</li><li>如果有必要，可以显示调用return None，可以简写为return</li><li>如果函数执行了return语句，函数就会返回，当前被执行的return语句之后的其它语句就不会被执行了</li><li>作用：结束函数调用、返回值</li></ul></li></ul><h2 id="函数的返回值-3"><a href="#函数的返回值-3" class="headerlink" title="函数的返回值"></a>函数的返回值</h2><ul><li>返回多个值<br>def showlist():<br>&emsp; return [1, 3, 5]<br>showlist函数是返回了多个值吗？<br>def showlist():<br>&emsp; return 1, 3, 5<br>这次showlist函数是否返回了多个值呢？</li></ul><h2 id="函数的返回值-4"><a href="#函数的返回值-4" class="headerlink" title="函数的返回值"></a>函数的返回值</h2><ul><li>返回多个值<ul><li>函数不能同时返回多个值</li><li>return [1, 3, 5] 是指明返回一个列表，是<strong>一个</strong>列表对象</li><li>return 1, 3, 5 看似返回多个值，隐式的被python封装成了<strong>一个</strong>元组<br>def showlist():<br>&emsp; return 1, 3, 5<br>x, y, z = showlist() # 使用解构提取更为方便</li></ul></li></ul><h2 id="函数嵌套"><a href="#函数嵌套" class="headerlink" title="函数嵌套"></a>函数嵌套</h2><ul><li>函数嵌套  <ul><li>在一个函数中定义了另外一个函数<br>def outer():<br>&emsp; def inner():<br>&emsp;&emsp; print(“inner”)<br>&emsp; print(“outer”)<br>&emsp; inner()<br>outer()<br>inner()  </li></ul></li><li>函数有可见范围，这就是<strong>作用域</strong>的概念  </li><li>内部函数不能在外部直接使用，会抛NameError异常，因为它不可见</li></ul><h2 id="作用域"><a href="#作用域" class="headerlink" title="作用域***"></a>作用域***</h2><ul><li>作用域<ul><li>一个标识符的可见范围，这就是标识符的作用域。一般常说的是变量的作用域</li><li>举例，对比左右2个函数  </li></ul></li></ul><p>&emsp; x = 5 </p><p>&emsp; def foo():<br>&emsp;&emsp; print(x)</p><p>&emsp; foo() </p><p><br></p><p>&emsp; x = 5  </p><p>&emsp; def foo():<br>&emsp;&emsp; x += 1<br>&emsp;&emsp; print(x)</p><p>&emsp; foo()<br>&emsp; 这会报x在赋值之前就引用了的错误<br>&emsp; UnboundLocalError: local variable ‘x’ referenced before assignment  </p><p>&emsp; x到底可见还是不可见？</p><h2 id="作用域-1"><a href="#作用域-1" class="headerlink" title="作用域***"></a>作用域***</h2><ul><li>全局作用域<ul><li>在整个程序运行环境中都可见</li></ul></li><li>局部作用域<ul><li>在函数、类等内部可见</li><li>局部变量使用范围不能超过其所在的局部作用域</li></ul></li></ul><p>&emsp; def fn1():<br>&emsp;&emsp; x = 1 # 局部作用域，在fn1内  </p><p>&emsp; def fn2():<br>&emsp;&emsp; print(x) # x可见吗</p><p>&emsp; print(x) # x可见吗</p><h2 id="作用域-2"><a href="#作用域-2" class="headerlink" title="作用域***"></a>作用域***</h2><ul><li>嵌套结构  </li></ul><p>def outer1(): #<br>&emsp; o = 65<br>&emsp; def inner():<br>&emsp;&emsp; print(“inner {}”.format(o))<br>&emsp;&emsp; print(chr(o))<br>&emsp; print(“outer {}”.format(o))<br>&emsp; inner()  </p><p>outer1()</p><ul><li>嵌套结构  </li></ul><p>def outer2(): #<br>&emsp; o = 65<br>&emsp; def inner():<br>&emsp;&emsp; o = 97<br>&emsp;&emsp; print(“inner {}”.format(o))<br>&emsp;&emsp; print(chr(o))<br>&emsp; print(“outer {}”.format(o))<br>&emsp; inner()  </p><p>outer2()</p><ul><li>代码中变量o的差别</li></ul><h2 id="作用域-3"><a href="#作用域-3" class="headerlink" title="作用域***"></a>作用域***</h2><ul><li>从嵌套结构例子看出<ul><li>外层变量作用域在内层作用域可见</li><li>内层作用域inner中，如果定义了o=97，相当于当前作用域中重新定义了一个新的变量o，但是这个o并没有覆盖外层作用域outer中的o</li><li>再看下面代码<br>x = 5<br>def foo():<br>&emsp; y = x + 1 # 报错吗<br>&emsp; x += 1 # 报错，报什么错？为什么？换成x=1还有错吗？<br>&emsp; print(x) # 为什么它不报错<br>foo()<br>为什么会报错？就是因为赋值即定义。x在赋值之前就用，会报错。  </li></ul></li></ul><h2 id="作用域-4"><a href="#作用域-4" class="headerlink" title="作用域***"></a>作用域***</h2><ul><li>代码<br>x = 5<br>def foo():<br>&emsp; x += 1  </li></ul><p><img src="https://raw.githubusercontent.com/herodanny/Image-Hosting/master/data/zuoyongyu.jpg" alt="zuoyongyu"></p><ul><li>x += 1 其实是 x = x + 1</li><li>相当于在foo内部定义一个局部变量x，那么foo内部所有x都是这个局部变量x了</li><li>但是这个x还没有完成赋值，就被右边拿来做加1操作了</li><li>如何解决这个问题</li></ul><h2 id="作用域-5"><a href="#作用域-5" class="headerlink" title="作用域***"></a>作用域***</h2><ul><li><p>全局变量global<br>x = 5<br>def foo():<br>&emsp; global x<br>&emsp; x += 1  </p></li><li><p>使用global关键字的变量，将foo内的x声明为使用外部的全局作用域中定义的x</p></li><li>全局作用域中必须有x的定义</li><li>如果全局作用域中没有x定义会怎样？</li></ul><h2 id="作用域-6"><a href="#作用域-6" class="headerlink" title="作用域***"></a>作用域***</h2><ul><li>全局变量global<br>&emsp; # x = 5<br>&emsp; def foo():<br>&emsp;&emsp; global x<br>&emsp;&emsp; x = 10<br>&emsp;&emsp; x += 1 # 报错吗？<br>&emsp;&emsp; print(x) # 打印什么？<br>&emsp; print(x) #打印什么？<br>做这些实验建议不要使用ipython、jupyter，因为它会上下文中有x定义，可能测试不出效果，也可以先用del x。  </li><li>使用global关键字的变量，将foo内的x声明为使用外部的全局作用域中定义的x</li><li>但是，x = 10 赋值即定义，在内部作用域为一个外部作用域的变量x赋值，<strong>不是在内部作用域定义一个新变量</strong>，所以x+=1不会报错。注意，<strong>这里x的作用域还是全局的</strong></li></ul><h2 id="作用域-7"><a href="#作用域-7" class="headerlink" title="作用域***"></a>作用域***</h2><ul><li><p>global总结</p><ul><li>x+=1这种是特殊形式产生的错误的原因？先引用后赋值，而python动态语言是赋值才算定义，才能被引用。解决办法，在这条语句前增加x=0之类的赋值语句，或者使用global 告诉内部作用域，去全局作用域查找变量定义</li><li><p><strong>内部作用域使用x = 5之类的赋值语句会重新定义局部作用域使用的变量x，但是，一旦这个作用域中使用global声明x为全局的，那么x=5相当于在为全局作用域的变量x赋值</strong></p></li><li><p>global使用原则</p><ul><li>外部作用域变量会内部作用域可见，但也不要在这个内部的局部作用域中直接使用，因为函数的目的就是为了封装，尽量与外界隔离</li><li>如果函数需要使用外部全局变量，请使用函数的<strong>形参传参</strong>解决</li><li>一句话：<strong>不用global</strong>。学习它就是为了深入理解变量作用域</li></ul></li></ul></li></ul><h2 id="闭包"><a href="#闭包" class="headerlink" title="闭包*"></a>闭包*</h2><ul><li>自由变量：未在本地作用域中定义的变量。例如定义在内层函数外的外层函数的作用域中的变量</li><li><p>闭包：就是一个概念，出现在嵌套函数中，指的是<strong>内层函数引用到了外层函数的自由变量</strong>，就形成了闭包。很多语言都有这个概念，最熟悉就是JavaScript。（注意：是指引用了外层函数中的，如果引用的变量是在全局作用域内，或是有global 修饰的变量，就不是闭包了。  ）  </p></li><li><p>先看下边一段代码</p></li></ul><p><img src="https://raw.githubusercontent.com/herodanny/Image-Hosting/master/data/bibao1.jpg" alt="bibao1"></p><ul><li>第4行会报错吗？为什么</li><li>第8行打印什么结果？</li><li>第10行打印什么结果？</li></ul><p>c是列表的引用, return inc 是返回一个标识符是函数对象，是callable的。<br>foo = counter() 增加了counter函数对象的引用计数，所以它的作用域空间还在。  </p><h2 id="闭包-1"><a href="#闭包-1" class="headerlink" title="闭包*"></a>闭包*</h2><ul><li>代码解析<ul><li>第4行会报错吗？为什么<ul><li>不会报错，c已经在counter函数中定义过了。而且inc中的使用方式是为c的元素修改值，而不是重新定义变量。<br>如果c不是引用列表，是c=0,c+=1这种，还是会报 UnboundLocalError: local variable ‘c’ referenced before assignment  </li></ul></li><li>第8行打印什么结果？<ul><li>打印 1 2</li></ul></li><li>第10行打印什么结果？<ul><li>打印 3</li><li>第9行的c和counter中的c不一样，而inc引用的是自由变量真是counter的变量c</li></ul></li><li>这是Python2中实现闭包的方式，Python3还可以使用nonlocal关键字</li></ul></li></ul><p>为什么要用闭包？就是内层函数要使用外层的自由变量。  </p><h2 id="闭包-2"><a href="#闭包-2" class="headerlink" title="闭包*"></a>闭包*</h2><ul><li>下面这段代码会报错吗？为什么？</li><li>使用global能否解决？</li></ul><p><img src="https://raw.githubusercontent.com/herodanny/Image-Hosting/master/data/bibao2.jpg" alt="bibao2"></p><ul><li><p>使用global可以解决，但是这使用的是全局变量，而不是闭包<br>def counter():<br>&emsp; count = 0<br>&emsp; def inc():<br>&emsp;&emsp; global c  # 本地和最外层没有定义c还是会报错<br>&emsp;&emsp; count +=1<br>&emsp;&emsp; return count<br>&emsp; return inc<br>foo = counter()<br>foo()<br>foo()<br>global的作用域范围，只在声明的inc()函数当前作用域内 和 全局作用域有效。  </p></li><li><p>如果要对普通变量的闭包，Python3中可以使用nonlocal  </p></li></ul><h2 id="nonlocal关键字"><a href="#nonlocal关键字" class="headerlink" title="nonlocal关键字"></a>nonlocal关键字</h2><ul><li>使用了nonlocal关键字，将变量标记为不在本地作用域定义，而在<strong>上级的某一级局部作用域中</strong>定义，但<strong>不能是全局作用域中</strong>定义  </li></ul><p><img src="https://raw.githubusercontent.com/herodanny/Image-Hosting/master/data/nonlocal1.jpg" alt="nonlocal1"></p><ul><li>count 是外层函数的局部变量，被内部函数引用</li><li>内部函数使用nonlocal关键字声明count变量在上级作用域而非本地作用域中定义</li><li>上边代码可以正常使用，且形成闭包</li><li>下边代码不能正常运行，变量 a 不能在全局作用域中</li></ul><p><img src="https://raw.githubusercontent.com/herodanny/Image-Hosting/master/data/nonlocal2.jpg" alt="nonlocal2"></p><h2 id="默认值的作用域"><a href="#默认值的作用域" class="headerlink" title="默认值的作用域"></a>默认值的作用域</h2><ul><li><p>默认值举例<br>def foo(xyz=1):<br>&emsp; print(xyz)<br>foo() # 打印什么？<br>foo() # 打印什么？<br>print(xyz) # 打印什么？<br>默认值是形参，它的作用域看成是函数局部作用域。  </p></li><li><p>默认值举例<br>def foo(xyz=[]):<br>&emsp; xyz.append(1)<br>&emsp; print(xyz)<br>foo() # 打印什么？<br>foo() # 打印什么？<br>print(xyz) # 打印什么？<br>不知是否对：变量名xyz在函数调用时压栈，函数结束时就出栈了。临时的本地变量xyz就消亡了。<br>默认值的对象一直都在，因为 python 中一切皆对象。<br>函数形参就是</p></li></ul><h2 id="默认值的作用域-1"><a href="#默认值的作用域-1" class="headerlink" title="默认值的作用域"></a>默认值的作用域</h2><ul><li><p>默认值举例<br>def foo(xyz=[]):<br>&emsp; xyz.append(1)<br>&emsp; print(xyz)<br>foo() # [1]<br>foo() # [1,1]<br>print(xyz) # NameError ，当前作用域没有xyz变量  </p></li><li><p>为什么第二次调用foo函数打印的是[1,1]？  </p><ul><li>因为<strong>函数</strong>也是<strong>对象</strong>，python把函数的默认值放在了属性中，这个属性就伴随着这个函数对象的整个生命周期</li><li>查看foo.<strong>defaults</strong>属性</li></ul></li></ul><h2 id="默认值的作用域-2"><a href="#默认值的作用域-2" class="headerlink" title="默认值的作用域"></a>默认值的作用域</h2><ul><li>运行这个例子<br>def foo(xyz=[], u=’abc’, z=123):<br>&emsp; xyz.append(1)<br>&emsp; return xyz<br>print(1, foo.__defaults__)<br>print(foo(), id(foo))<br>print(2, foo.__defaults__)<br>print(foo(), id(foo))<br>print(3, foo.__defaults__)  </li><li>函数地址并没有变，就是说函数这个对象的没有变，调用它，它的属性<strong>defaults</strong>中使用<strong>元组</strong>保存默认值</li><li>xyz默认值是引用类型，引用类型的元素变动，并不是元组的变化</li></ul><h2 id="默认值的作用域-3"><a href="#默认值的作用域-3" class="headerlink" title="默认值的作用域"></a>默认值的作用域</h2><ul><li>非引用类型例子<br>def foo(w, u=’abc’, z=123):<br>&emsp; u = ‘xyz’<br>&emsp; z = 789<br>&emsp; print(w, u, z)<br>print(foo.__defaults__)<br>foo(‘github’)<br>print(foo.__defaults__)  </li><li>属性__defaults__中使用元组保存所有位置参数默认值，它不会因为在函数体内使用了它而发生改变</li></ul><h2 id="默认值的作用域-4"><a href="#默认值的作用域-4" class="headerlink" title="默认值的作用域"></a>默认值的作用域</h2><ul><li>举例<br>def foo(w, u=’abc’, *, z=123, zz=[456]):<br>&emsp; u = ‘xyz’<br>&emsp; z = 789<br>&emsp; zz.append(1)<br>&emsp; print(w, u, z, zz)<br>print(foo.__defaults__)<br>foo(‘magedu’)<br>print(foo.__kwdefaults__)</li><li>属性__defaults__中使用元组保存所有位置参数默认值</li><li>属性__kwdefaults__中使用字典保存所有keyword-only参数的默认值</li></ul><h2 id="默认值的作用域-5"><a href="#默认值的作用域-5" class="headerlink" title="默认值的作用域"></a>默认值的作用域</h2><ul><li>使用可变类型作为默认值(如list)，就可能修改这个默认值</li><li>有时候这个特性是好的，有的时候这种特性是不好的，有副作用</li><li>如何做到按需改变呢？看下面的2种方法</li></ul><h2 id="默认值的作用域-6"><a href="#默认值的作用域-6" class="headerlink" title="默认值的作用域"></a>默认值的作用域</h2><p>def foo(xyz=[], u=’abc’, z=123):<br>&emsp; xyz = xyz[:] # 影子拷贝<br>&emsp; xyz.append(1)<br>&emsp; print(xyz)<br>foo()<br>print(1, foo.__defaults__)<br>foo() # xyz还是浅拷贝新的list<br>print(2, foo.__defaults__)<br>foo([10])<br>print(3, foo.__defaults__)<br>foo([10,5])<br>print(4, foo.__defaults__)</p><ul><li>1、函数体内，不改变默认值<ul><li>xyz都是传入参数或者默认参数的副本，如果就想修改原参数，无能为力</li></ul></li></ul><h2 id="默认值的作用域-7"><a href="#默认值的作用域-7" class="headerlink" title="默认值的作用域"></a>默认值的作用域</h2><p>def foo(xyz=None, u=’abc’, z=123):<br>&emsp; if xyz is None:<br>&emsp;&emsp; xyz = []<br>&emsp; xyz.append(1)<br>&emsp; print(xyz)<br>foo()<br>print(1, foo.__defaults__)<br>foo()<br>print(2, foo.__defaults__)<br>foo([10])<br>print(3, foo.__defaults__)<br>foo([10,5])<br>print(4, foo.__defaults__)</p><ul><li>2、使用不可变类型默认值<ul><li>如果使用缺省值None就创建一个列表</li><li>如果传入一个列表，就修改这个列表</li></ul></li></ul><h2 id="默认值的作用域-8"><a href="#默认值的作用域-8" class="headerlink" title="默认值的作用域"></a>默认值的作用域</h2><ul><li>第一种方法<ul><li>使用影子拷贝创建一个新的对象，永远不能改变传入的参数</li></ul></li><li>第二种方法<ul><li>通过值的判断就可以灵活的选择创建或者修改传入对象</li><li>这种方式灵活，应用广泛</li><li>很多函数的定义，都可以看到使用None这个不可变的值作为默认参数，可以说这是一种惯用法</li></ul></li></ul><h2 id="变量名解析原则LEGB"><a href="#变量名解析原则LEGB" class="headerlink" title="变量名解析原则LEGB"></a>变量名解析原则LEGB</h2><ul><li>Local，本地作用域、局部作用域的local命名空间。函数调用时创建，调用结束消亡</li><li>Enclosing，Python2.2时引入了嵌套函数，实现了闭包，这个就是嵌套函数的外部函数的命名空间</li><li>Global，全局作用域，即一个模块的命名空间。模块被import时创建，解释器退出时消亡</li><li>Build-in，内置模块的命名空间，生命周期从python解释器启动时创建到解释器退出时消亡。例如 print(open)，print和open都是内置的变量</li><li>所以一个名词的查找顺序就是LEGB</li></ul><p><img src="https://raw.githubusercontent.com/herodanny/Image-Hosting/master/data/legb.jpg" alt="legb"></p><h2 id="函数的销毁"><a href="#函数的销毁" class="headerlink" title="函数的销毁"></a>函数的销毁</h2><ul><li>全局函数<br>def foo(xyz=[], u=’abc’, z=123):<br>&emsp; xyz.append(1)<br>&emsp; return xyz<br>print(foo(), id(foo), foo.__defaults__)<br>def foo(xyz=[], u=’abc’, z=123):<br>&emsp; xyz.append(1)<br>&emsp; return xyz<br>print(foo(), id(foo), foo.__defaults__)<br>del foo<br>print(foo(), id(foo), foo.__defaults__)</li></ul><h2 id="函数的销毁-1"><a href="#函数的销毁-1" class="headerlink" title="函数的销毁"></a>函数的销毁</h2><ul><li>全局函数销毁<ul><li>重新定义同名函数</li><li>del 语句删除函数对象</li><li>程序结束时</li></ul></li></ul><h2 id="函数的销毁-2"><a href="#函数的销毁-2" class="headerlink" title="函数的销毁"></a>函数的销毁</h2><ul><li>局部函数<br>def foo(xyz=[], u=’abc’, z=123):<br>&emsp; xyz.append(1)<br>&emsp; def inner(a=10):<br>&emsp;&emsp; pass<br>&emsp; print(inner)<br>&emsp; def inner(a=100):<br>&emsp;&emsp; print(xyz)<br>&emsp; print(inner)<br>&emsp; return inner<br>bar = foo()<br>print(id(foo),id(bar), foo.__defaults__, bar.__defaults__)<br>del bar<br>print(id(foo),id(bar), foo.__defaults__, bar.__defaults__)  </li></ul><h2 id="函数的销毁-3"><a href="#函数的销毁-3" class="headerlink" title="函数的销毁"></a>函数的销毁</h2><ul><li>局部函数销毁<ul><li>重新在上级作用域定义同名函数</li><li>del 语句删除函数名称，函数对象的引用计数减1</li><li>上级作用域销毁时</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;第九章-Python-函数返回值、作用域&quot;&gt;&lt;a href=&quot;#第九章-Python-函数返回值、作用域&quot; class=&quot;headerlink&quot; title=&quot;第九章 - Python 函数返回值、作用域&quot;&gt;&lt;/a&gt;第九章 - Python 函数返回值、作用域&lt;/
      
    
    </summary>
    
      <category term="python-magedu" scheme="https://herodanny.github.io/categories/python-magedu/"/>
    
    
      <category term="python" scheme="https://herodanny.github.io/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>python全栈-magedu-2018-笔记15</title>
    <link href="https://herodanny.github.io/python-magedu-2018-notes15.html"/>
    <id>https://herodanny.github.io/python-magedu-2018-notes15.html</id>
    <published>2019-05-04T05:26:29.000Z</published>
    <updated>2019-05-19T12:39:17.864Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第八章-Python函数、参数及参数解构"><a href="#第八章-Python函数、参数及参数解构" class="headerlink" title="第八章 - Python函数、参数及参数解构"></a>第八章 - Python函数、参数及参数解构</h1><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><ul><li>函数<ul><li>数学定义：y=f(x) ，y是x的函数，x是自变量。y=f(x0, x1, …, xn)</li><li>Python函数<ul><li>由若干语句组成的语句块、函数名称、参数列表构成，它是组织代码的最小单元</li><li>完成一定的功能</li></ul></li></ul></li><li>函数的作用<ul><li>结构化编程对代码的最基本的封装，一般按照功能组织一段代码</li><li>封装的目的为了复用，减少冗余代码</li><li>代码更加简洁美观、可读易懂</li></ul></li><li>函数的分类<ul><li>内建函数，如max()、reversed()等</li><li>库函数，如math.ceil()等</li></ul></li></ul><h2 id="函数定义、调用"><a href="#函数定义、调用" class="headerlink" title="函数定义、调用"></a>函数定义、调用</h2><ul><li>def语句定义函数<br>def 函数名(参数列表):<br>&emsp; 函数体（代码块）<br>&emsp; [return 返回值]  <ul><li>函数名就是标识符，命名要求一样</li><li>语句块必须缩进，约定4个空格</li><li>Python的函数没有return语句，隐式会返回一个None值</li><li>定义中的参数列表成为形式参数，只是一种符号表达，简称<strong>形参</strong></li></ul></li><li>调用<ul><li>函数定义，只是声明了一个函数，它不会被执行，需要调用</li><li>调用的方式，就是函数名加上小括号，括号内写上参数</li><li>调用时写的参数是实际参数，是实实在在传入的值，简称<strong>实参</strong></li></ul></li></ul><h2 id="函数定义、调用-1"><a href="#函数定义、调用-1" class="headerlink" title="函数定义、调用"></a>函数定义、调用</h2><ul><li>函数举例<br>&emsp; def add(x, y):<br>&emsp;&emsp; result = x+y<br>&emsp;&emsp; return result<br>&emsp; out = add(4,5)<br>&emsp; print(out)  </li><li>上面只是一个函数的定义，有一个函数叫做add，接收2个参数</li><li>计算的结果，通过返回值返回</li><li>调用通过函数名add加2个参数，返回值可使用变量接收</li><li>定义需要在调用前，也就是说调用时，已经被定义过了，否则抛NameError异常</li><li>函数是可调用的对象，callable()</li><li>看看这个函数是不是通用的？体会一下函数的好处</li></ul><h2 id="函数参数"><a href="#函数参数" class="headerlink" title="函数参数"></a>函数参数</h2><ul><li>参数调用时传入的参数要和定义的个数相匹配（可变参数例外）</li><li><strong>位置参数</strong><ul><li>def f(x, y, z) 调用使用 f(1, 3, 5)</li><li>按照参数定义顺序传入实参</li></ul></li><li><strong>关键字参数</strong><ul><li>def f(x, y, z) 调用使用 f(x=1, y=3, z=5)</li><li>使用形参的名字来<strong>传入实参</strong>的方式，如果使用了形参名字，那么传参顺序就可和定义顺序不同</li></ul></li><li>传参<ul><li>f(z=None, y=10, x=[1])</li><li>f((1,), z=6, y=4.1)</li><li>f(y=5, z=6, 2) #</li><li><strong>要求位置参数必须在关键字参数之前传入</strong>，位置参数是按位置对应的</li></ul></li></ul><h2 id="函数参数默认值-缺省值"><a href="#函数参数默认值-缺省值" class="headerlink" title="函数参数默认值 (缺省值)"></a>函数参数默认值 (缺省值)</h2><ul><li>参数默认值（缺省值）  <ul><li>定义时，在形参后跟上一个值<br>&emsp; def add(x=4, y=5):<br>&emsp;&emsp; return x+y<br>测试调用 add(6, 10) 、add(6, y=7) 、add(x=5) 、add()、add(y=7)、 add(x=5, 6) 、add(y=8,4)、add(x=5, y=6)、add(y=5, x=6)<br>测试定义后面这样的函数 def add(x=4,y)<br>写法应该是 y 在 x=4 前面，因为解释器的想法是 前面没有默认值，必须用户给传进来 所以写前面，x=4是有缺省值的位置参数  </li></ul></li><li>作用<ul><li>参数的默认值可以在未传入足够的实参的时候，对没有给定的参数赋值为默认值</li><li>参数非常多的时候，并不需要用户每次都输入所有的参数，简化函数调用</li></ul></li><li>举例<ul><li>定义一个函数login，参数名称为host、port、username、password</li></ul></li></ul><h2 id="函数参数默认值"><a href="#函数参数默认值" class="headerlink" title="函数参数默认值"></a>函数参数默认值</h2><ul><li>举例<ul><li>定义一个函数login，参数名称为host、port、username、password</li></ul></li></ul><p>&emsp; def login(host=’127.0.0.1’,port=’8080’,username=’herodanny’,password=’herodanny’):<br>&emsp;&emsp; print(‘{}:{}@{}/{}’.format(host, port, username, password))<br>&emsp; login()<br>&emsp; login(‘127.0.0.1’, 80, ‘tom’, ‘tom’)<br>&emsp; login(‘127.0.0.1’, username=’root’)<br>&emsp; login(‘localhost’, port=80,password=’com’)<br>&emsp; login(port=80, password=’danny’, host=’www’)  </p><h2 id="可变参数"><a href="#可变参数" class="headerlink" title="可变参数"></a>可变参数</h2><ul><li>问题<ul><li>有多个数，需要累加求和<br>&emsp; def add(nums):<br>&emsp;&emsp; sum = 0<br>&emsp;&emsp; for x in nums:<br>&emsp;&emsp;&emsp; sum += x<br>&emsp;&emsp; return sum<br>&emsp; add([1,3,5])、add((2,4,6))<br>传入一个可迭代对象，迭代元素求和  </li></ul></li><li>可变参数<ul><li>一个形参可以匹配任意个参数</li></ul></li></ul><h2 id="可变参数-可变位置参数"><a href="#可变参数-可变位置参数" class="headerlink" title="可变参数 (可变位置参数)"></a>可变参数 (可变位置参数)</h2><ul><li>位置参数的可变参数  <ul><li>有多个数，需要累加求和<br>def add(*nums):<br>&emsp; sum = 0<br>&emsp; print(type(nums))<br>&emsp; for x in nums:<br>&emsp;&emsp; sum += x<br>&emsp; print(sum)<br>add(3, 6, 9) # 调用  </li></ul></li><li>在形参前使用 * 表示该形参是可变参数，可以接收多个实参  </li><li>收集多个实参为一个tuple  </li><li>思考：关键字参数能否也能传递任意多个吗？</li></ul><h2 id="可变参数-可变关键字参数"><a href="#可变参数-可变关键字参数" class="headerlink" title="可变参数 (可变关键字参数)"></a>可变参数 (可变关键字参数)</h2><ul><li>关键字参数的可变参数<ul><li>配置信息打印<br>def showconfig(**kwargs):<br>&emsp; for k,v in kwargs.items():<br>&emsp; &emsp; print(‘{} = {}’.format(k, v))<br>showconfig(host=’127.0.0.1’,port=’8080’,username=’wayne’,password=’magedu’)  </li></ul></li><li>形参前使用**符号，表示可以接收多个关键字参数</li><li>收集的实参名称和值组成一个字典</li></ul><h2 id="可变参数-1"><a href="#可变参数-1" class="headerlink" title="可变参数"></a>可变参数</h2><ul><li>可变参数混合使用<ul><li>配置信息打印<br>def showconfig(username, password,**kwargs)<br>def showconfig(username, *args, **kwargs)<br>def showconfig(username, password, **kwargs, *args)  # 这么定义是错误的，星号多的放后面</li></ul></li></ul><h2 id="可变参数-2"><a href="#可变参数-2" class="headerlink" title="可变参数"></a>可变参数</h2><ul><li>总结<ul><li>有位置可变参数和关键字可变参数</li><li>位置可变参数在形参前使用一个星号 *</li><li>关键字可变参数在形参前使用两个星号 **</li><li>位置可变参数和关键字可变参数都可以收集若干个实参，位置可变参数收集形成一个tuple，关键字可变参数收集形成一个dict</li><li>混合使用参数的时候，可变参数要放到参数列表的最后，普通参数需要放到参数列表前面，位置可变参数需要在关键字可变参数之前</li></ul></li></ul><h2 id="可变参数-3"><a href="#可变参数-3" class="headerlink" title="可变参数"></a>可变参数</h2><ul><li>举例<br>def fn(x, y, *args, **kwargs):<br>&emsp; print(x)<br>&emsp; print(y)<br>&emsp; print(args)<br>&emsp; print(kwargs)  </li></ul><p>&emsp; fn(3,5,7,9,10,a=1,b=’python’)<br>&emsp; fn(3,5)<br>&emsp; fn(3,5,7)<br>&emsp; fn(3,5,a=1,b=’python’)<br>&emsp; fn(7,9,y=5,x=3,a=1,b=’python’) # 错误，7和9分别赋给了x，y，又y=5、x=3，重复了</p><h2 id="可变参数-4"><a href="#可变参数-4" class="headerlink" title="可变参数"></a>可变参数</h2><ul><li>举例<br>def fn(*args, x, y, **kwargs):  # 如果是带缺省值的形参不能写在*参数后面<br>&emsp; print(x)<br>&emsp; print(y)<br>&emsp; print(args)<br>&emsp; print(kwargs)  </li></ul><p>&emsp; fn(3,5)<br>&emsp; fn(3,5,7)<br>&emsp; fn(3,5,a=1,b=’python’)<br>&emsp; fn(7,9,y=5,x=3,a=1,b=’python’)<br>&emsp; 形参前面是可变，后面是不可变，参数匹配时会尽量先匹配x、y  </p><h2 id="keyword-only参数"><a href="#keyword-only参数" class="headerlink" title="keyword-only参数"></a>keyword-only参数</h2><ul><li>keyword-only参数（Python3加入）  <ul><li>如果在<strong>一个星号参数</strong>后，或者<strong>一个位置可变参数</strong>后，出现的普通参数，实际上已经不是普通的参数了，而是keyword-only参数 (是指实参传参时要像关键字参数那样写)<br>def fn(*args, x):<br>&emsp; print(x)<br>&emsp; print(args)  </li></ul></li></ul><p>&emsp;&emsp;&emsp; fn(3,5)<br>&emsp;&emsp;&emsp; fn(3,5,7)<br>&emsp;&emsp;&emsp; fn(3,5,x=7)<br>&emsp;&emsp;&emsp; args可以看做已经截获了所有的位置参数，x不使用关键字参数就不可能拿到实参<br>&emsp;&emsp;&emsp; 思考：def fn(**kwargs, x) 可以吗？  </p><h2 id="keyword-only参数-1"><a href="#keyword-only参数-1" class="headerlink" title="keyword-only参数"></a>keyword-only参数</h2><ul><li>举例<br>&emsp; def(**kwargs, x):<br>&emsp;&emsp; print(x)<br>&emsp;&emsp; print(kwargs)<br>直接报语法错误<br>可以理解为kwargs会截获所有的关键字参数，就算你写了x=5，x也永远得不到这个值，所以语法错误，x 就算是 keyword-only 参数，在写实参时也要写成关键字参数，这么又分不清是给前面的可变关键字参数，还是给x  </li></ul><h2 id="keyword-only参数-2"><a href="#keyword-only参数-2" class="headerlink" title="keyword-only参数"></a>keyword-only参数</h2><ul><li>keyword-only 参数另一种形式<br>&emsp; def fn(*, x,y)<br>&emsp;&emsp; print(x,y)<br>&emsp; fn(x=5,y=6)<br>* 号之后，普通（的位置参数）形参都变成了必须给出的 keyword-only 参数<br>def fn(*, x, y) 的意思就是必须要 2个 keyword-only 参数<br>如果前面是可变参数不必写成 def fn(*args, *, x, y) 这种形式，* 可以省略，所以就变成 def fn(*args, x, y)</li></ul><h2 id="可变参数和参数默认值"><a href="#可变参数和参数默认值" class="headerlink" title="可变参数和参数默认值"></a>可变参数和参数默认值</h2><ul><li>举例<br>def fn(*args, x=5):  # 一般 keyword-only 都和缺省值一起使用<br>&emsp; print(x)<br>&emsp; print(args)<br>fn() # 等价于fn(x=5)，x是keyword-only 但有了缺省值就又可以在传参时偷懒省略关键字参数写法<br>fn(5)  # 5 传给了 args<br>fn(x=6)<br>fn(1,2,3,x=10)  </li></ul><h2 id="可变参数和参数默认值-1"><a href="#可变参数和参数默认值-1" class="headerlink" title="可变参数和参数默认值"></a>可变参数和参数默认值</h2><ul><li>举例<br>def fn(y, *args, x=5):  # x 原来是位置参数，现在有默认值就是keyword-only参数<br>&emsp; print(‘x={}, y={}’.format(x, y))<br>&emsp; print(args)<br>fn()<br>fn(5)<br>fn(x=6) #<br>fn(1,2,3,x=10)<br>fn(y=17,2,3,x=10) #<br>fn(1,2,y=3,x=10) #<br>x 是 keyword-only参数  </li></ul><h2 id="可变参数和参数默认值-2"><a href="#可变参数和参数默认值-2" class="headerlink" title="可变参数和参数默认值"></a>可变参数和参数默认值</h2><ul><li>举例<br>def fn(x=5, **kwargs):<br>&emsp; print(‘x={}’.format(x))<br>&emsp; print(kwargs)<br>fn()<br>fn(5)<br>fn(x=6) #<br>fn(y=3,x=10)  # y=3匹配了kwargs<br>fn(3,y=10)  </li></ul><h2 id="函数参数-1"><a href="#函数参数-1" class="headerlink" title="函数参数"></a>函数参数</h2><ul><li>参数规则  <ul><li>参数列表参数一般顺序是，普通参数、缺省参数、可变位置参数、keyword-only参数（可带缺省值）、可变关键字参数<br>def fn(x, y, z=3, *arg, m=4, n, **kwargs):<br>&emsp; print(x,y,z,m,n)<br>&emsp; print(args)<br>&emsp; print(kwargs)  </li></ul></li><li>注意<ul><li>代码应该易读易懂，而不是为难别人</li><li>请按照书写习惯定义函数参数</li></ul></li></ul><h2 id="函数参数-2"><a href="#函数参数-2" class="headerlink" title="函数参数"></a>函数参数</h2><ul><li>参数规则举例  <ul><li>参数列表参数一般顺序是，普通参数、缺省参数、可变位置参数、keyword-only参数（可带缺省值）、可变关键字参数<br>def connect(host=’localhost’, port=’3306’, user=’admin’, password=’admin’, **kwargs):<br>&emsp; print(host, port)<br>&emsp; print(user, password)<br>&emsp; print(kwargs)<br>connect(db=’cmdb’)<br>connect(host=’192.168.1.123’, db=’cmdb’)<br>connect(host=’192.168.1.123’, db=’cmdb’, password=’mysql’)  </li></ul></li></ul><h2 id="参数解构"><a href="#参数解构" class="headerlink" title="参数解构"></a>参数解构</h2><ul><li>举例  <ul><li>加法函数<br>def add(x, y):<br>&emsp; return x+y<br>add(4, 5)<br>add((4,5))<br>t = (4, 5)<br>add(t[0], t[1])<br>add(*t) 或 add(*(4,5)) add(*[4,5]) add(*{4,6})  # 参数解构<br>add(*range(1,3))  </li></ul></li></ul><h2 id="参数解构-1"><a href="#参数解构-1" class="headerlink" title="参数解构"></a>参数解构</h2><ul><li>参数解构<ul><li>给函数提供实参的时候，可以在集合类型前使用*或者**，把集合类型的结构解开，提取出所有元素作为函数的<strong>实参</strong></li><li>非字典类型使用*解构成位置参数</li><li>字典类型使用**解构成关键字参数  </li><li>提取出来的元素数目要和参数的要求匹配，也要和参数的类型匹配<br>def add(x, y):<br>&emsp; return x+y<br>add(*(4,5)) add(*[4,5]) add(*{4,6})<br>d = {‘x’: 5, ‘y’: 6}<br>add(**d)  # 这里解构出来，就像是关键字参数作实参 x=5，y=6<br>add(*d.keys())  # 可能输出是 ‘yx’，key的顺序不可控<br>add(*d.values())<br>add(**{‘a’: 5, ‘b’: 6}) add(*{‘a’: 5, ‘b’: 6})  </li></ul></li></ul><h2 id="参数解构-2"><a href="#参数解构-2" class="headerlink" title="参数解构"></a>参数解构</h2><ul><li>参数解构和可变参数<ul><li>给函数提供<strong>实参</strong>的时候，可以在集合类型前使用*或者**，把集合类型的结构解开，提取出所有元素作为函数的实参<br>def add(*iterable):  # 这里 * 号是可变位置参数<br>&emsp; result = 0<br>for x in iterable:<br>&emsp; result += x<br>return result<br>add(1,2,3)<br>add(*[1,2,3])  # 这里 * 是参数解构<br>add(*range(10))  </li></ul></li></ul><h2 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h2><ul><li>编写一个函数，能够接受至少2个参数，返回最小值和最大值</li><li>编写一个函数，接受一个参数n，n为正整数，左右两种打印方式。要求数字必须对齐</li></ul><p><img src="https://raw.githubusercontent.com/herodanny/Image-Hosting/master/data/hanshulianxidayin.jpg" alt="hanshulianxidayin"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;第八章-Python函数、参数及参数解构&quot;&gt;&lt;a href=&quot;#第八章-Python函数、参数及参数解构&quot; class=&quot;headerlink&quot; title=&quot;第八章 - Python函数、参数及参数解构&quot;&gt;&lt;/a&gt;第八章 - Python函数、参数及参数解构&lt;/
      
    
    </summary>
    
      <category term="python-magedu" scheme="https://herodanny.github.io/categories/python-magedu/"/>
    
    
      <category term="python" scheme="https://herodanny.github.io/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>python全栈-magedu-2018-笔记14</title>
    <link href="https://herodanny.github.io/python-magedu-2018-notes14.html"/>
    <id>https://herodanny.github.io/python-magedu-2018-notes14.html</id>
    <published>2019-05-02T07:49:55.000Z</published>
    <updated>2019-05-19T12:35:55.360Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第七章-Python内建函数"><a href="#第七章-Python内建函数" class="headerlink" title="第七章 - Python内建函数"></a>第七章 - Python内建函数</h1><h2 id="内建函数"><a href="#内建函数" class="headerlink" title="内建函数"></a>内建函数</h2><ul><li>标识 id<ul><li>返回对象的唯一标识，CPython返回内存地址</li></ul></li><li>哈希 hash()<ul><li>返回一个对象的哈希值</li></ul></li><li>类型 type()<ul><li>返回对象的类型</li></ul></li><li>类型转换<ul><li>float() int() bin() hex() oct() bool() list() tuple() dict() set() complex() bytes() bytearray()</li></ul></li><li>输入 input([prompt])<ul><li>接收用户输入，返回一个字符串</li></ul></li><li>打印 print(*objects, sep=’ ‘, end=’\n’, file=sys.stdout, flush=False)<ul><li>打印输出，默认使用空格分割、换行结尾，输出到控制台</li></ul></li></ul><h2 id="内建函数-1"><a href="#内建函数-1" class="headerlink" title="内建函数"></a>内建函数</h2><ul><li>对象长度 len(s)<ul><li>返回一个集合类型的元素个数</li></ul></li><li>isinstance(obj, class_or_tuple)<ul><li>判断对象obj是否属于某种类型或者元组中列出的某个类型</li><li>isinstance(True, int)</li></ul></li><li>issubclass(cls, class_or_tuple)<ul><li>判断类型cls是否是某种类型的子类或元组中列出的某个类型的子类</li><li>issubclass(bool, int)</li></ul></li></ul><h2 id="内建函数-2"><a href="#内建函数-2" class="headerlink" title="内建函数"></a>内建函数</h2><ul><li>绝对值abs(x) x为数值</li><li>最大值max() 最小值min()<ul><li>返回可迭代对象中最大或最小值</li><li>返回多个参数中最大或最小值</li></ul></li><li>round(x) 四舍六入五取偶(是银行家算法)，round(-0.5)</li><li>pow(x , y) 等价于 x**y</li><li>range(stop) 从0开始到stop-1的可迭代对象；range(start, stop[, step])从start开始到stop-1结束步长为step的可迭代对象</li><li>divmod(x, y) 等价于 tuple (x//y, x%y)</li><li>sum(iterable[, start]) 对可迭代对象的所有数值元素求和<ul><li>sum(range(1,100,2))</li></ul></li></ul><h2 id="内建函数-3"><a href="#内建函数-3" class="headerlink" title="内建函数"></a>内建函数</h2><ul><li>chr(i) 给一个一定范围的整数返回对应的字符<ul><li>chr(97) chr(20013)</li></ul></li><li><p>ord(c) 返回字符对应的整数</p><ul><li>ord(‘a’) ord(‘中’)</li></ul></li><li><p>str() 、repr()、ascii() 后面说</p></li></ul><h2 id="内建函数-4"><a href="#内建函数-4" class="headerlink" title="内建函数"></a>内建函数</h2><ul><li>sorted(iterable[, key][, reverse]) 排序<ul><li>返回一个新的<strong>列表</strong>，默认升序</li><li>reverse是反转  </li></ul></li></ul><p>&emsp; sorted([1, 3, 5])<br>&emsp; sorted([1, 3, 5], reverse=True)<br>&emsp; sorted({‘c’:1, ‘b’:2, ‘a’:1})  # 返回的是key的列表<br>&emsp; sorted((100, 5)) # 返回的也是排好序的列表  </p><h2 id="内建函数-5"><a href="#内建函数-5" class="headerlink" title="内建函数"></a>内建函数</h2><ul><li>翻转 reversed(seq)<ul><li>返回一个翻转元素的迭代器</li></ul></li></ul><p>&emsp; list(reversed(“13579”))<br>&emsp; { reversed((2, 4)) } # 有几个元素？<br>&emsp; for x in reversed([‘c’,’b’,’a’]):<br>&emsp;&emsp; print(x)<br>&emsp; reversed(sorted({1, 5, 9}))  </p><h2 id="内建函数-6"><a href="#内建函数-6" class="headerlink" title="内建函数"></a>内建函数</h2><ul><li>枚举 enumerate(seq, start=0)<ul><li>迭代一个序列，返回索引数字和元素构成的二元组</li><li>start表示索引开始的数字，默认是0  </li></ul></li></ul><p>&emsp;&emsp; for x in enumerate([2,4,6,8]):<br>&emsp;&emsp;&emsp; print(x)  </p><p>&emsp;&emsp; for x in enumerate(“abcde”):<br>&emsp;&emsp;&emsp; print(x,end=” “)</p><h2 id="内建函数-7"><a href="#内建函数-7" class="headerlink" title="内建函数"></a>内建函数</h2><ul><li>迭代器和取元素 iter(iterable)、next(iterator[, default])<ul><li>iter将一个可迭代对象封装成一个迭代器</li><li>next对一个迭代器取下一个元素。如果全部元素都取过了，再次next会抛StopIteration异常</li></ul></li></ul><p>&emsp; it = iter(range(5))<br>&emsp; next(it)</p><p>&emsp; it = reversed([1,3,5])<br>&emsp; next(it)</p><h2 id="可迭代对象"><a href="#可迭代对象" class="headerlink" title="可迭代对象"></a>可迭代对象</h2><ul><li>可迭代对象<ul><li>能够通过迭代一次次返回<strong>不同的元素</strong>的对象。<ul><li>所谓相同，不是指值是否相同，而是元素在容器中是否是同一个，例如列表中值可以重复的，[‘a’,’a’]，虽然这个列表有2个元素，值一样，但是两个’a’是不同的元素</li></ul></li><li>可以迭代，但是未必有序，未必可索引</li><li>可迭代对象有：list、tuple、string、bytes、bytearray、range、set、dict、生成器(迭代器)等</li><li>可以使用成员操作符in、not in，in本质上就是在遍历对象</li></ul></li></ul><p>&emsp; 3 in range(10)<br>&emsp; 3 in (x for x in range(10))<br>&emsp; 3 in {x:y for x,y in zip(range(4),range(4,10))}  </p><h2 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h2><ul><li>迭代器<ul><li>特殊的对象，一定是可迭代对象，具备可迭代对象的特征</li><li>通过iter方法把一个可迭代对象封装成迭代器</li><li>通过next方法，迭代 迭代器对象</li><li>生成器对象，就是迭代器对象</li></ul></li></ul><p>&emsp; for x in iter(range(10)):<br>&emsp;&emsp; print(x)  </p><p>&emsp; range()可以看成类似生成器的可迭代对象，它是惰性求值的.<br>&emsp; 因为 next(range(10))，会报类型错误 TypeError: ‘range’ object is not an iterator.<br>&emsp; 一般生成器是迭代器，迭代器不一定是生成器。  </p><p>&emsp; g = (x for x in range(10))<br>&emsp; print(type(g))<br>&emsp; print(next(g))<br>&emsp; print(next(g))  </p><h2 id="内建函数-8"><a href="#内建函数-8" class="headerlink" title="内建函数"></a>内建函数</h2><ul><li>拉链函数zip(*iterables)<ul><li>像拉链一样，把多个可迭代对象合并在一起，返回一个迭代器</li><li>将每次从不同对象中取到的元素合并成一个元组</li></ul></li></ul><p>&emsp; list(zip(range(10),range(10)))<br>&emsp; list(zip(range(10),range(10),range(<strong>5</strong>),range(10)))</p><p>&emsp; dict(zip(range(10),range(10)))<br>&emsp; {str(x):y for x,y in zip(range(10),range(10))}</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;第七章-Python内建函数&quot;&gt;&lt;a href=&quot;#第七章-Python内建函数&quot; class=&quot;headerlink&quot; title=&quot;第七章 - Python内建函数&quot;&gt;&lt;/a&gt;第七章 - Python内建函数&lt;/h1&gt;&lt;h2 id=&quot;内建函数&quot;&gt;&lt;a href
      
    
    </summary>
    
      <category term="python-magedu" scheme="https://herodanny.github.io/categories/python-magedu/"/>
    
    
      <category term="python" scheme="https://herodanny.github.io/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>python全栈-magedu-2018-笔记13</title>
    <link href="https://herodanny.github.io/python-magedu-2018-notes13.html"/>
    <id>https://herodanny.github.io/python-magedu-2018-notes13.html</id>
    <published>2019-05-01T15:57:27.000Z</published>
    <updated>2019-05-19T12:34:40.955Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第六章-Python解析式、生成器"><a href="#第六章-Python解析式、生成器" class="headerlink" title="第六章 - Python解析式、生成器"></a>第六章 - Python解析式、生成器</h1><p>解析式、生成器 应该算是python特有的。用熟需要练习，可以大大简化写的代码的长度，原来写好几行，现在写一行就行了。  </p><h2 id="标准库datetime"><a href="#标准库datetime" class="headerlink" title="标准库datetime"></a>标准库datetime</h2><ul><li>datetime模块<ul><li>对日期、时间、时间戳的处理</li><li>datetime类<ul><li>类方法<ul><li>today() 返回本地时区当前时间的datetime对象</li><li><strong>now</strong>(tz=None) 返回当前时间的datetime对象，时间到微秒，如果tz为None，返回和today()一样</li><li>utcnow() 没有时区的当前时间</li><li>fromtimestamp(timestamp, tz=None) 从一个时间戳返回一个datetime对象</li></ul></li><li>datetime对象<ul><li>timestamp() 返回一个到微秒的时间戳。<ul><li>时间戳：格林威治时间1970年1月1日0点到现在的秒数</li></ul></li></ul></li></ul></li></ul></li></ul><h2 id="标准库datetime-1"><a href="#标准库datetime-1" class="headerlink" title="标准库datetime"></a>标准库datetime</h2><ul><li>datetime对象<ul><li>构造方法 datetime.datetime(2016, 12, 6, 16, 29, 43, 79043)</li><li>year、month、day、hour、minute、second、microsecond，取datetime对象的年月日时分秒及微秒</li><li>weekday() 返回星期的天，周一0，周日6</li><li>isoweekday() 返回星期的天，周一1，周日7</li><li>date() 返回日期date对象</li><li>time() 返回时间time对象</li><li>replace() 修改并返回新的时间</li><li>isocalendar() 返回一个三元组(年，周数，周的天)</li></ul></li></ul><h2 id="标准库datetime-2"><a href="#标准库datetime-2" class="headerlink" title="标准库datetime"></a>标准库datetime</h2><ul><li>日期格式化*<ul><li>类方法 strptime(date_string, format) ，返回datetime对象</li><li>对象方法 strftime(format) ，返回字符串</li><li>字符串format函数格式化</li></ul></li></ul><p>&emsp; import datetime<br>&emsp; dt = datetime.datetime.strptime(“21/11/06 16:30”, “%d/%m/%y %H:%M”)<br>&emsp; print(dt.strftime(“%Y-%m-%d %H:%M:%S”))<br>&emsp; print(“{0:%Y}/{0:%m}/{0:%d} {0:%H}::{0:%M}::{0:%S}”.format(dt))  </p><h2 id="标准库datetime-3"><a href="#标准库datetime-3" class="headerlink" title="标准库datetime"></a>标准库datetime</h2><ul><li>timedelta对象<ul><li>datetime2 = datetime1 + timedelta</li><li>datetime2 = datetime1 - timedelta</li><li>timedelta = datetime1 - datetime2</li><li>构造方法<ul><li>datetime.timedelta(days=0, seconds=0, microseconds=0, milliseconds=0,minutes=0, hours=0, weeks=0)</li><li>year = datetime.timedelta(days=365)</li></ul></li><li>total_seconds() 返回时间差的总秒数</li></ul></li></ul><h2 id="标准库time"><a href="#标准库time" class="headerlink" title="标准库time"></a>标准库time</h2><ul><li>time<ul><li>time.sleep(secs) 将调用线程挂起指定的秒数</li></ul></li></ul><h2 id="列表解析"><a href="#列表解析" class="headerlink" title="列表解析"></a>列表解析</h2><ul><li>举例<ul><li>生成一个列表，元素0~9，对每一个元素自增1后求平方返回新列表</li></ul></li></ul><h2 id="列表解析-1"><a href="#列表解析-1" class="headerlink" title="列表解析"></a>列表解析</h2><ul><li>举例<ul><li>生成一个列表，元素0~9，对每一个元素自增1后求平方返回新列表  </li></ul></li></ul><p>&emsp;&emsp; l1 = list(range(10))<br>&emsp;&emsp; l2 = []<br>&emsp;&emsp; for i in l1:<br>&emsp;&emsp; &emsp; l2.append((i+1)**2)<br>&emsp;&emsp; print(l2)  </p><ul><li>列表解析式  </li></ul><p>&emsp;&emsp; l1 = list(range(10))<br>&emsp;&emsp; l2 = [(i+1)**2 for i in l1]<br>&emsp;&emsp; print(l2)<br>&emsp;&emsp; print(type(l2))  </p><h2 id="列表解析-List-Comprehension"><a href="#列表解析-List-Comprehension" class="headerlink" title="列表解析 List Comprehension"></a>列表解析 List Comprehension</h2><ul><li><p>语法</p><ul><li>[返回值 for 元素 in 可迭代对象 if 条件]</li><li>使用中括号[]，内部是for循环，if条件语句可选</li><li>返回一个新的列表</li></ul></li><li><p>列表解析式是一种语法糖</p><ul><li>编译器会优化，不会因为简写而影响效率，反而因优化提高了效率</li><li>减少程序员工作量，减少出错</li><li>简化了代码，但可读性增强</li></ul></li></ul><h2 id="列表解析-2"><a href="#列表解析-2" class="headerlink" title="列表解析"></a>列表解析</h2><ul><li>举例<ul><li>获取10以内的偶数，比较执行效率  </li></ul></li></ul><p>&emsp;&emsp; even = []<br>&emsp;&emsp; for x in range(10):<br>&emsp;&emsp;&emsp;&emsp; if x % 2 == 0:<br>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp; even.append(x)  </p><p>&emsp;&emsp; even = [x for x in range(10) if x%2==0]  # range直接 step为2 也行跳过奇数</p><ul><li>思考<ul><li>有这样的赋值语句newlist = [print(i) for i in range(10)]，请问newlist的元素打印出来是什么？</li><li>获取20以内的偶数，如果数是3的倍数也打印[i for i in range(20) if i%2==0 elif i%3==0] 行吗？</li></ul></li></ul><h2 id="列表解析进阶"><a href="#列表解析进阶" class="headerlink" title="列表解析进阶"></a>列表解析进阶</h2><ul><li>[expr for item in iterable if cond1 if cond2]  </li><li>等价于<br>ret = []<br>for item in iterable:<br>&emsp; if cond1:<br>&emsp;&emsp; if cond2:<br>&emsp;&emsp;&emsp; ret.append(expr)  </li><li>举例<br>20以内，既能被2整除又能被3整除的数<br>[i for i in range(20) if i%2==0 and i%3==0]<br>[i for i in range(20) if i%2==0 if i%3==0]  </li></ul><h2 id="列表解析进阶-1"><a href="#列表解析进阶-1" class="headerlink" title="列表解析进阶"></a>列表解析进阶</h2><ul><li>[expr for i in iterable1 for j in iterable2 ]</li><li><p>等价于<br>ret = []<br>for i in iterable1:<br>&emsp; for j in iterable2:<br>&emsp;&emsp; ret.append(expr)  </p></li><li><p>举例<br>[(x, y) for x in ‘abcde’ for y in range(3)]<br>[[x, y] for x in ‘abcde’ for y in range(3)]<br>[{x: y} for x in ‘abcde’ for y in range(3)]  </p></li></ul><h2 id="列表解析进阶-2"><a href="#列表解析进阶-2" class="headerlink" title="列表解析进阶"></a>列表解析进阶</h2><ul><li>请问下面3种输出各是什么？为什么<br>[(i,j) for i in range(7) if i&gt;4 for j in range(20,25) if j&gt;23]<br>[(i,j) for i in range(7) for j in range(20,25) if i&gt;4 if j&gt;23]<br>[(i,j) for i in range(7) for j in range(20,25) if i&gt;4 and j&gt;23]<br>三条语句语义上是等价的。语句执行的顺序上有不同。效率也差不多。  </li></ul><h2 id="列表解析练习"><a href="#列表解析练习" class="headerlink" title="列表解析练习"></a>列表解析练习</h2><ul><li>练习（要求使用列表解析式完成）<ul><li>返回1-10平方的列表</li><li>有一个列表lst = [1,4,9,16,2,5,10,15]，生成一个新列表，要求新列表元素是lst相邻2项的和</li><li>打印九九乘法表</li><li>“0001.abadicddws” 是ID格式，要求ID格式是以点号分割，左边是4位从1开始的整数，右边是10位随机小写英文字母。请依次生成前100个ID的列表</li></ul></li></ul><h2 id="生成器表达式-Generator-expression"><a href="#生成器表达式-Generator-expression" class="headerlink" title="生成器表达式 Generator expression"></a>生成器表达式 Generator expression</h2><ul><li>语法<ul><li>(返回值 for 元素 in 可迭代对象 if 条件)</li><li>列表解析式的中括号换成小括号就行了</li><li>返回一个生成器</li></ul></li><li>和列表解析式的区别<ul><li>生成器表达式是 <strong>按需计算</strong>（或称<strong>惰性求值、延迟计算</strong>），需要的时候才计算值</li><li>列表解析式是立即返回值</li></ul></li><li>生成器 （ generator object ）<ul><li><strong>可迭代对象</strong></li><li><strong>迭代器</strong></li></ul></li></ul><h2 id="生成器表达式"><a href="#生成器表达式" class="headerlink" title="生成器表达式**"></a>生成器表达式**</h2><ul><li>举例<br>g = (“{:04}”.format(i) for i in range(1,11))<br><strong>next(g)</strong><br>for x in g:<br>&emsp; print(x)<br>print(‘<del>~</del><del>~</del>~~’)<br>for x in g:<br>&emsp; print(x)  </li><li><p>总结  </p><ul><li>延迟计算</li><li>返回迭代器，可以迭代</li><li>从前到后走完一遍后，不能回头</li></ul></li><li><p>对比列表<br>g = [“{:04}”.format(i) for i in range(1,11)]<br>for x in g:<br>&emsp; print(x)<br>print(‘<del>~</del><del>~</del>~~’)<br>for x in g:<br>&emsp; print(x)  </p></li><li>总结<ul><li>立即计算</li><li>返回的不是迭代器，返回可迭代对象列表</li><li>从前到后走完一遍后，可以重新回头迭代</li></ul></li></ul><h2 id="生成器表达式-1"><a href="#生成器表达式-1" class="headerlink" title="生成器表达式"></a>生成器表达式</h2><ul><li>习题<br>it = (print(“{}”.format(i+1)) for i in range(2))<br>first = next(it)<br>second = next(it)<br>val = first + second  <ul><li>val的值是什么？</li><li>val = first + second 语句之后能否再次next(it)？</li></ul></li></ul><h2 id="生成器表达式-2"><a href="#生成器表达式-2" class="headerlink" title="生成器表达式"></a>生成器表达式</h2><ul><li>习题<br>it = (x for x in range(10) if x % 2)<br>first = next(it)<br>second = next(it)<br>val = first + second  <ul><li>val的值是什么？  </li><li>val = first + second 语句之后能否再次next(it)？  </li></ul></li></ul><h2 id="生成器表达式-3"><a href="#生成器表达式-3" class="headerlink" title="生成器表达式"></a>生成器表达式</h2><ul><li>和列表解析式的对比<ul><li>计算方式<ul><li>生成器表达式延迟计算，列表解析式立即计算</li></ul></li><li>内存占用<ul><li>单从返回值本身来说，生成器表达式省内存，列表解析式返回新的列表</li><li>生成器没有数据，内存占用极少，但是使用的时候，虽然一个个返回数据，但是合起来占用的内存也差不多</li><li>列表解析式构造新的列表需要占用内存</li></ul></li><li>计算速度<ul><li>单看计算时间看，生成器表达式耗时非常短，列表解析式耗时长</li><li>但是生成器本身并没有返回任何值，只返回了一个生成器对象</li><li>列表解析式构造并返回了一个新的列表</li></ul></li></ul></li></ul><h2 id="集合解析式（推导式）"><a href="#集合解析式（推导式）" class="headerlink" title="集合解析式（推导式）"></a>集合解析式（推导式）</h2><ul><li>语法<ul><li>{返回值 for 元素 in 可迭代对象 if 条件}</li><li>列表解析式的中括号换成大括号{}就行了</li><li>立即返回一个集合</li></ul></li><li>用法<ul><li>{(x,x+1) for x in range(10)}</li><li>{[x] for x in range(10)} #</li></ul></li></ul><h2 id="字典解析式（推导式）"><a href="#字典解析式（推导式）" class="headerlink" title="字典解析式（推导式）"></a>字典解析式（推导式）</h2><ul><li>语法<ul><li>{返回值 for 元素 in 可迭代对象 if 条件}</li><li>列表解析式的中括号换成大括号{}就行了</li><li>使用key:value形式</li><li>立即返回一个字典</li></ul></li><li>用法<ul><li>{x:(x,x+1) for x in range(10)}</li><li>{x:[x,x+1] for x in range(10)}</li><li>{(x,):[x,x+1] for x in range(10)}</li><li>{[x]:[x,x+1] for x in range(10)} #</li><li>{chr(0x41+x):x**2 for x in range(10)}</li><li>{str(x):y for x in range(3) for y in range(4)} # 输出多少个元素？<br>输出：{‘0’:3, ‘1’:3, ‘2’:3}，有些k-v对去重了。</li></ul></li></ul><h2 id="字典解析式"><a href="#字典解析式" class="headerlink" title="字典解析式"></a>字典解析式</h2><ul><li>用法<ul><li>{str(x):y for x in range(3) for y in range(4)} # 输出多少个元素？</li><li>等价于<br>ret = {}<br>for x in range(3):<br>&emsp; for y in range(4):<br>&emsp;&emsp; ret[str(x)] = y  </li></ul></li></ul><p>解析式写法有：列表的、集合的、字典的。<br>元组的那个写法，变成了生成器表达式了。  </p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>Python2 引入列表解析式</li><li>Python2.4 引入生成器表达式</li><li><p>Python3 引入集合、字典解析式，并迁移到了2.7</p></li><li><p>一般来说，应该多应用解析式，简短、高效</p></li><li><p>如果一个解析式非常复杂，难以读懂，要考虑拆解成for循环</p></li><li><p>生成器和迭代器是不同的对象，但都是可迭代对象，都可以用 for 循环的。</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;第六章-Python解析式、生成器&quot;&gt;&lt;a href=&quot;#第六章-Python解析式、生成器&quot; class=&quot;headerlink&quot; title=&quot;第六章 - Python解析式、生成器&quot;&gt;&lt;/a&gt;第六章 - Python解析式、生成器&lt;/h1&gt;&lt;p&gt;解析式、生成
      
    
    </summary>
    
      <category term="python-magedu" scheme="https://herodanny.github.io/categories/python-magedu/"/>
    
    
      <category term="python" scheme="https://herodanny.github.io/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>python全栈-magedu-2018-笔记12</title>
    <link href="https://herodanny.github.io/python-magedu-2018-notes12.html"/>
    <id>https://herodanny.github.io/python-magedu-2018-notes12.html</id>
    <published>2019-04-30T14:14:41.000Z</published>
    <updated>2019-05-19T03:13:48.978Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第三章-Python-内置数据结构"><a href="#第三章-Python-内置数据结构" class="headerlink" title="第三章 - Python 内置数据结构"></a>第三章 - Python 内置数据结构</h1><h2 id="字典dict"><a href="#字典dict" class="headerlink" title="字典dict"></a>字典dict</h2><ul><li>key-value键值对的数据的集合</li><li><strong>可变的、无序的、key不重复</strong></li></ul><h2 id="字典dict定义-初始化"><a href="#字典dict定义-初始化" class="headerlink" title="字典dict定义 初始化"></a>字典dict定义 初始化</h2><ul><li>d = dict() 或者 <strong>d = {}</strong></li><li><strong>dict(**kwargs)</strong> 使用name=value对初始化一个字典</li><li>dict(iterable, **kwarg) 使用可迭代对象和name=value对构造字典，不过可迭代对象的元素必须是一个<strong>二元</strong>结构<ul><li>d = dict(((1,’a’),(2,’b’))) 或者 d = dict(([1,’a’],[2,’b’]))</li><li>**kwarg是表示在二元结构后面还是可以加k=v参数来初始化<br>d2 = dict(d, c=3)</li></ul></li><li>dict(mapping, **kwarg) 使用一个字典构建另一个字典</li><li><strong>d = {‘a’:10, ‘b’:20, ‘c’:None, ‘d’:[1,2,3]}</strong></li><li>类方法dict.fromkeys(iterable, value)<ul><li>d = dict.fromkeys(range(5))</li><li>d = dict.fromkeys(range(5),0)  </li></ul></li></ul><p>&emsp; (类方法就相当于java中的静态方法)，这里iterable可以是一元结构的列表<br>&emsp; d1 = dict.fromkeys(range(1, 11), [1, 2])<br>&emsp; 这样产生的字典中所有的value都是列表[1,2]的引用，如果append这个列表，所有的value都会被修改。</p><h2 id="字典元素的访问"><a href="#字典元素的访问" class="headerlink" title="字典元素的访问"></a>字典元素的访问</h2><ul><li>d[key]<ul><li>返回key对应的值value</li><li>key不存在抛出KeyError异常</li></ul></li><li>get(key[, default])<ul><li>返回key对应的值value</li><li>key不存在返回缺省值，如果没有设置缺省值就返回None</li></ul></li><li>setdefault(key[, default])<ul><li>返回key对应的值value</li><li>key不存在，添加kv对，value为default，并返回default，如果default没有设置，缺省为None</li></ul></li></ul><h2 id="字典增加和修改"><a href="#字典增加和修改" class="headerlink" title="字典增加和修改"></a>字典增加和修改</h2><ul><li>d[key] = value<ul><li>将key对应的值修改为value</li><li><strong>key不存在添加新的kv对</strong></li></ul></li><li>update([other]) -&gt; None<ul><li>使用另一个字典的kv对更新本字典</li><li>key不存在，就添加</li><li>key存在，覆盖已经存在的key对应的值</li><li>就地修改</li></ul></li></ul><p>&emsp; d.update(red=1)<br>&emsp; d.update(((‘red’,2),))<br>&emsp; d.update({‘red’:3})  </p><h2 id="字典删除"><a href="#字典删除" class="headerlink" title="字典删除"></a>字典删除</h2><ul><li>pop(key[, default])<ul><li>key存在，移除它，并返回它的value</li><li>key不存在，返回给定的default</li><li>default未设置，key不存在则抛出KeyError异常</li></ul></li><li>popitem()<ul><li>移除并返回一个任意的键值对</li><li>字典为empty，抛出KeyError异常</li></ul></li><li>clear()<ul><li>清空字典</li></ul></li></ul><h2 id="字典删除-1"><a href="#字典删除-1" class="headerlink" title="字典删除"></a>字典删除</h2><ul><li>del语句<br>a = True<br>b = [6]<br>d = {‘a’: 1, ‘b’: b, ‘c’: [1,3,5]}<br>del a<br>del d[‘c’] # 删除了一个对象[1,3,5]？<br>del b[0]<br>c = b<br>del c<br>del b<br>b = d[‘b’]<br>p del a[‘c’]  # 看着像删除了一个对象，本质上减少了一个对象的引用，del 实际上删除的是名称，而不是对象  </li></ul><h2 id="字典遍历"><a href="#字典遍历" class="headerlink" title="字典遍历"></a>字典遍历</h2><ul><li>for … in dict<ul><li>遍历key  </li></ul></li></ul><p>&emsp;&emsp; for k in d:<br>&emsp;&emsp;&emsp; print(k)  </p><p>&emsp;&emsp; for k in d.keys():<br>&emsp;&emsp;&emsp; print(k)  </p><h2 id="字典遍历-1"><a href="#字典遍历-1" class="headerlink" title="字典遍历"></a>字典遍历</h2><ul><li>for … in dict<ul><li>遍历value</li></ul></li></ul><p>&emsp;&emsp; for k in d:<br>&emsp;&emsp;&emsp; print(d[k])</p><p>&emsp;&emsp; for k in d.keys():<br>&emsp;&emsp;&emsp; print(d.get(k))</p><p>&emsp;&emsp; for v in d.values():<br>&emsp;&emsp;&emsp; print(v)</p><h2 id="字典遍历-2"><a href="#字典遍历-2" class="headerlink" title="字典遍历"></a>字典遍历</h2><ul><li>for … in dict<ul><li>遍历item，即k-v对</li></ul></li></ul><p>&emsp;&emsp; for item in d.items():<br>&emsp;&emsp;&emsp; print(item) # item是(k,v)元组，不推荐这种写法</p><p>&emsp;&emsp; for item in d.items():<br>&emsp;&emsp;&emsp; print(item[0], item[1])</p><p>&emsp;&emsp; for k,v in d.items():<br>&emsp;&emsp;&emsp; print(k, v) # 推荐这种写法</p><p>&emsp;&emsp; for k, _ in d.items():<br>&emsp;&emsp;&emsp; print(k)</p><p>&emsp;&emsp; for _ ,v in d.items():<br>&emsp;&emsp;&emsp; print(v)</p><h2 id="字典遍历-3"><a href="#字典遍历-3" class="headerlink" title="字典遍历"></a>字典遍历</h2><ul><li><p>总结</p><ul><li><p>Python3中，keys、values、items方法返回一个类似一个生成器的可迭代对象，不会把函数的返回结果复制到内存中 (可以把返回的 dict_items()、dict_keys()、dict_values() 想象成是帮你到字典中取数据)</p><ul><li>是 Dictionary view 对象</li><li>字典的entry的动态的视图，字典变化，视图将反映出这些变化</li></ul></li><li><p>Python2中，上面的方法会返回一个新的列表，占据新的内存空间。所以Python2建议使用iterkeys、itervalues、iteritems版本，返回一个迭代器，而不是一个copy</p></li></ul></li></ul><h2 id="字典遍历和移除"><a href="#字典遍历和移除" class="headerlink" title="字典遍历和移除"></a>字典遍历和移除</h2><ul><li>如何在遍历的时候移除元素  </li></ul><p>&emsp;&emsp; 错误的做法:<br>&emsp;&emsp; d = dict(a=1, b=2, c=’abc’)<br>&emsp;&emsp; for k,v in d.items():<br>&emsp;&emsp;&emsp;&emsp; d.pop(k) # RuntimeError: dictionary changed size during iteration<br>&emsp;&emsp; 用字典视图的对象迭代时，是不能修改字典的大小的<br>&emsp;&emsp; 另外在用for 迭代时，字典的大小是不允许改变的，即不允许增删元素。  </p><p>&emsp;&emsp; while len(d): # 相当于清空，不如直接clear()<br>&emsp;&emsp;&emsp;&emsp; print(d.popitem())</p><p>&emsp;&emsp; 正确的做法:<br>&emsp;&emsp; d = dict(a=1, b=2, c=’abc’)<br>&emsp;&emsp; keys = []<br>&emsp;&emsp; for k,v in d.items():<br>&emsp;&emsp;&emsp;&emsp; if isinstance(v, str):<br>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp; keys.append(k)<br>&emsp;&emsp; for k in keys:<br>&emsp;&emsp;&emsp;&emsp; d.pop(k)<br>&emsp;&emsp; print(d)</p><h2 id="字典的key"><a href="#字典的key" class="headerlink" title="字典的key"></a>字典的key</h2><ul><li>key的要求和set的元素要求一致<ul><li>set的元素可以就是看做key，set可以看做dict的简化版</li><li>hashable 可哈希才可以作为key，可以使用hash()测试，即key不可变的，key变了，通过哈希函数找到的值也就变了。</li><li>d = {1 : 0, 2.0 : 3, “abc” : None, (‘hello’, ‘world’, ‘python’) : “string”, b’abc’ : ‘135’}</li></ul></li></ul><h2 id="defaultdict"><a href="#defaultdict" class="headerlink" title="defaultdict"></a>defaultdict</h2><ul><li>collections.defaultdict([default_factory[, …]])<ul><li>第一个参数是default_factory，缺省是None，它提供一个初始化函数。<strong>当key不存在的时候，会调用这个工厂函数来生成key对应的value</strong></li></ul></li></ul><p>&emsp; import random<br>&emsp; d1 = {}<br>&emsp; for k in ‘abcdef’:<br>&emsp;&emsp; for i in range(random.randint(1,5)):<br>&emsp;&emsp;&emsp; if k not in d1.keys():<br>&emsp;&emsp;&emsp;&emsp; d1[k] = []<br>&emsp;&emsp;&emsp; d1[k].append(i)  </p><p>&emsp; print(d1)  </p><p><br></p><p>&emsp; from collections import defaultdict<br>&emsp; import random  </p><p>&emsp; d1 = defaultdict(list)<br>&emsp; for k in ‘abcdef’:<br>&emsp;&emsp; for i in range(random.randint(1,5)):<br>&emsp;&emsp;&emsp; d1[k].append(i)  </p><p>&emsp; print(d1)  </p><h2 id="OrderedDict"><a href="#OrderedDict" class="headerlink" title="OrderedDict"></a>OrderedDict</h2><ul><li>collections.OrderedDict([items])<ul><li>key并不是按照加入的顺序排列，可以使用OrderedDict记录顺序</li></ul></li></ul><p>&emsp; from collections import OrderedDict<br>&emsp; import random<br>&emsp; d = {‘banana’: 3, ‘apple’: 4, ‘pear’: 1, ‘orange’: 2}<br>&emsp; print(d)<br>&emsp; keys = list(d.keys())<br>&emsp; random.shuffle(keys)<br>&emsp; print(keys)<br>&emsp; od = OrderedDict()<br>&emsp; for key in keys:<br>&emsp;&emsp; od[key] = d[key]<br>&emsp; print(od)<br>&emsp; print(od.keys())  </p><h2 id="OrderedDict-1"><a href="#OrderedDict-1" class="headerlink" title="OrderedDict"></a>OrderedDict</h2><ul><li>有序字典可以记录元素插入的顺序，打印的时候也是按照这个顺序输出打印</li><li><p>3.6版本的Python的字典就是记录key插入的顺序（IPython不一定有效果）</p></li><li><p>应用场景：</p><ul><li>假如使用字典记录了N个产品，这些产品使用ID由小到大加入到字典中</li><li>除了使用字典检索的遍历，有时候需要取出ID，但是希望是按照输入的顺序，因为输入顺序是有序的</li><li>否则还需要重新把遍历到的值排序</li></ul></li></ul><h2 id="字典练习"><a href="#字典练习" class="headerlink" title="字典练习"></a>字典练习</h2><ul><li>用户输入一个数字<ul><li>打印每一位数字及其重复的次数</li></ul></li><li>数字重复统计<ul><li>随机产生100个整数</li><li>数字的范围[-1000, 1000]</li><li>升序输出所有不同的数字及其重复的次数</li></ul></li><li>字符串重复统计<ul><li>字符表’abcdefghijklmnopqrstuvwxyz’</li><li>随机挑选2个字母组成字符串，共挑选100个</li><li>降序输出所有不同的字符串及重复的次数</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;第三章-Python-内置数据结构&quot;&gt;&lt;a href=&quot;#第三章-Python-内置数据结构&quot; class=&quot;headerlink&quot; title=&quot;第三章 - Python 内置数据结构&quot;&gt;&lt;/a&gt;第三章 - Python 内置数据结构&lt;/h1&gt;&lt;h2 id=&quot;字
      
    
    </summary>
    
      <category term="python-magedu" scheme="https://herodanny.github.io/categories/python-magedu/"/>
    
    
      <category term="python" scheme="https://herodanny.github.io/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>python全栈-magedu-2018-笔记11</title>
    <link href="https://herodanny.github.io/python-magedu-2018-notes11.html"/>
    <id>https://herodanny.github.io/python-magedu-2018-notes11.html</id>
    <published>2019-04-29T15:16:55.000Z</published>
    <updated>2019-05-07T10:27:51.137Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第三章-Python-内置数据结构"><a href="#第三章-Python-内置数据结构" class="headerlink" title="第三章 - Python 内置数据结构"></a>第三章 - Python 内置数据结构</h1><h2 id="简单选择排序"><a href="#简单选择排序" class="headerlink" title="简单选择排序"></a>简单选择排序</h2><ul><li><p>简单选择排序</p><ul><li>属于选择排序</li><li>两两比较大小，找出极值（极大值或极小值）被放置在固定的位置，这个固定位置一般指的是某一端</li><li>结果分为升序和降序排列</li></ul></li><li><p>降序</p><ul><li>n个数从左至右，索引从0开始到n-1，两两依次比较，记录大值索引，此轮所有数比较完毕，将大数和索引0数交换，如果大数就是索引1，不交换。第二轮，从1开始比较，找到最大值，将它和索引1位置交换，如果它就在索引1位置则不交换。依次类推，每次左边都会固定下一个大数。</li></ul></li><li>升序<ul><li>和降序相反</li></ul></li></ul><h2 id="简单选择排序-1"><a href="#简单选择排序-1" class="headerlink" title="简单选择排序"></a>简单选择排序</h2><p><img src="https://raw.githubusercontent.com/herodanny/Image-Hosting/master/data/jiandanxuanzepaixu.jpg" alt="jiandanxuanzepaixu"></p><h2 id="简单选择排序代码实现（一）"><a href="#简单选择排序代码实现（一）" class="headerlink" title="简单选择排序代码实现（一）*"></a>简单选择排序代码实现（一）*</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">m_list = [</span><br><span class="line">    [<span class="number">1</span>, <span class="number">9</span>, <span class="number">8</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>],</span><br><span class="line">    [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>],</span><br><span class="line">    [<span class="number">9</span>, <span class="number">8</span>, <span class="number">7</span>, <span class="number">6</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>]</span><br><span class="line">]</span><br><span class="line">nums = m_list[<span class="number">1</span>]</span><br><span class="line">length = len(nums)</span><br><span class="line">print(nums)</span><br><span class="line"></span><br><span class="line">count_swap = <span class="number">0</span></span><br><span class="line">count_iter = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(length):</span><br><span class="line">    maxindex = i</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> range(i + <span class="number">1</span>, length):</span><br><span class="line">        count_iter += <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> nums[maxindex] &lt; nums[j]:</span><br><span class="line">            maxindex = j</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> i != maxindex:</span><br><span class="line">        tmp = nums[i]</span><br><span class="line">        nums[i] = nums[maxindex]</span><br><span class="line">        nums[maxindex] = tmp</span><br><span class="line">        count_swap += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">print(nums, count_swap, count_iter)</span><br></pre></td></tr></table></figure><h2 id="简单选择排序代码实现（二）"><a href="#简单选择排序代码实现（二）" class="headerlink" title="简单选择排序代码实现（二）"></a>简单选择排序代码实现（二）</h2><ul><li>优化实现<br>二元选择排序<br>同时固定左边最大值和右边最小值<br>优点：<br>减少迭代元素的次数  </li></ul><p>&emsp; 1、length//2 整除，通过几次运算就可以发现规律<br>&emsp; 2、由于使用了负索引，所以条件中要增加<br>&emsp; i == length + minindex  </p><p>&emsp; 还有没有优化的可能？  </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">count_swap = <span class="number">0</span></span><br><span class="line">count_iter = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 二元选择排序</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(length // <span class="number">2</span>):</span><br><span class="line">    maxindex = i</span><br><span class="line">    minindex = -i - <span class="number">1</span></span><br><span class="line">    minorigin = minindex</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> range(i + <span class="number">1</span>, length - i): <span class="comment"># 每次左右都要少比较一个</span></span><br><span class="line">    count_iter += <span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> nums[maxindex] &lt; nums[j]:</span><br><span class="line">        maxindex = j</span><br><span class="line">    <span class="keyword">if</span> nums[minindex] &gt; nums[-j - <span class="number">1</span>]:</span><br><span class="line">        minindex = -j - <span class="number">1</span></span><br><span class="line">        <span class="comment"># print(maxindex, minindex)</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> i != maxindex:</span><br><span class="line">        tmp = nums[i]</span><br><span class="line">        nums[i] = nums[maxindex]</span><br><span class="line">        nums[maxindex] = tmp</span><br><span class="line">        count_swap += <span class="number">1</span></span><br><span class="line">        <span class="comment"># 如果最小值被交换过，要更新索引</span></span><br><span class="line">        <span class="keyword">if</span> i == minindex <span class="keyword">or</span> i == length + minindex:</span><br><span class="line">            minindex = maxindex</span><br><span class="line">    <span class="keyword">if</span> minorigin != minindex:</span><br><span class="line">        tmp = nums[minorigin]</span><br><span class="line">        nums[minorigin] = nums[minindex]</span><br><span class="line">        nums[minindex] = tmp</span><br><span class="line">        count_swap += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">print(nums, count_swap, count_iter)</span><br></pre></td></tr></table></figure><h2 id="简单选择排序代码实现（二）-1"><a href="#简单选择排序代码实现（二）-1" class="headerlink" title="简单选择排序代码实现（二）"></a>简单选择排序代码实现（二）</h2><ul><li>改进实现<br>如果一轮比较后，极大值、极小值的值相等，说明比较的序列元素全部相等</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">m_list = [</span><br><span class="line">    [<span class="number">1</span>, <span class="number">9</span>, <span class="number">8</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>],</span><br><span class="line">    [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>],</span><br><span class="line">    [<span class="number">9</span>, <span class="number">8</span>, <span class="number">7</span>, <span class="number">6</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>],</span><br><span class="line">    [<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>]</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">nums = m_list[<span class="number">3</span>]</span><br><span class="line">length = len(nums)</span><br><span class="line">print(nums)</span><br><span class="line">count_swap = <span class="number">0</span></span><br><span class="line">count_iter = <span class="number">0</span></span><br><span class="line"><span class="comment"># 二元选择排序</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(length // <span class="number">2</span>):</span><br><span class="line">    maxindex = i</span><br><span class="line">    minindex = -i - <span class="number">1</span></span><br><span class="line">    minorigin = minindex</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> range(i + <span class="number">1</span>, length - i): <span class="comment"># 每次左右都要少比较一个</span></span><br><span class="line">    count_iter += <span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> nums[maxindex] &lt; nums[j]:</span><br><span class="line">        maxindex = j</span><br><span class="line">    <span class="keyword">if</span> nums[minindex] &gt; nums[-j - <span class="number">1</span>]:</span><br><span class="line">        minindex = -j - <span class="number">1</span></span><br><span class="line"><span class="comment"># print(maxindex, minindex)</span></span><br><span class="line"><span class="keyword">if</span> nums[maxindex] == nums[minindex]: <span class="comment"># 元素全相同</span></span><br><span class="line">    <span class="keyword">break</span></span><br><span class="line"><span class="keyword">if</span> i != maxindex:</span><br><span class="line">    tmp = nums[i]</span><br><span class="line">    nums[i] = nums[maxindex]</span><br><span class="line">    nums[maxindex] = tmp</span><br><span class="line">    count_swap += <span class="number">1</span></span><br><span class="line">    <span class="comment"># 如果最小值被交换过，要更新索引</span></span><br><span class="line">    <span class="keyword">if</span> i == minindex <span class="keyword">or</span> i == length + minindex:</span><br><span class="line">        minindex = maxindex</span><br><span class="line"><span class="keyword">if</span> minorigin != minindex:</span><br><span class="line">    tmp = nums[minorigin]</span><br><span class="line">    nums[minorigin] = nums[minindex]</span><br><span class="line">    nums[minindex] = tmp</span><br><span class="line">    count_swap += <span class="number">1</span></span><br><span class="line">print(nums, count_swap, count_iter)</span><br></pre></td></tr></table></figure><h2 id="简单选择排序代码实现（二"><a href="#简单选择排序代码实现（二" class="headerlink" title="简单选择排序代码实现（二)"></a>简单选择排序代码实现（二)</h2><ul><li>改进实现<br>[1, 1, 1, 1, 1, 1, 1, 1, 2] 这种情况，找到的最小值索引是-2，最大值索引8，上面的代码会交换2次，最小值两个1交换是无用功，所以，增加一个判断</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">m_list = [</span><br><span class="line">    [<span class="number">1</span>, <span class="number">9</span>, <span class="number">8</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>],</span><br><span class="line">    [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>],</span><br><span class="line">    [<span class="number">9</span>, <span class="number">8</span>, <span class="number">7</span>, <span class="number">6</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>],</span><br><span class="line">    [<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>],</span><br><span class="line">    [<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">nums = m_list[<span class="number">4</span>]</span><br><span class="line">length = len(nums)</span><br><span class="line">print(nums)</span><br><span class="line">count_swap = <span class="number">0</span></span><br><span class="line">count_iter = <span class="number">0</span></span><br><span class="line"><span class="comment"># 二元选择排序</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(length // <span class="number">2</span>):</span><br><span class="line">    maxindex = i</span><br><span class="line">    minindex = -i - <span class="number">1</span></span><br><span class="line">    minorigin = minindex</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> range(i + <span class="number">1</span>, length - i): <span class="comment"># 每次左右都要少比较一个</span></span><br><span class="line">        count_iter += <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> nums[maxindex] &lt; nums[j]:</span><br><span class="line">            maxindex = j</span><br><span class="line">        <span class="keyword">if</span> nums[minindex] &gt; nums[-j - <span class="number">1</span>]:</span><br><span class="line">            minindex = -j - <span class="number">1</span></span><br><span class="line">    </span><br><span class="line">    print(maxindex, minindex)</span><br><span class="line">    <span class="keyword">if</span> nums[maxindex] == nums[minindex]: <span class="comment"># 元素相同</span></span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">if</span> i != maxindex:</span><br><span class="line">        tmp = nums[i]</span><br><span class="line">        nums[i] = nums[maxindex]</span><br><span class="line">        nums[maxindex] = tmp</span><br><span class="line">        count_swap += <span class="number">1</span></span><br><span class="line">        <span class="comment"># 如果最小值被交换过，要更新索引</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> i == minindex <span class="keyword">or</span> i == length + minindex:</span><br><span class="line">            minindex = maxindex</span><br><span class="line">    <span class="comment"># 最小值索引不同，但值相同就没有必要交换了</span></span><br><span class="line">    <span class="keyword">if</span> minorigin != minindex <span class="keyword">and</span> nums[minorigin] != nums[minindex]:</span><br><span class="line">        tmp = nums[minorigin]</span><br><span class="line">        nums[minorigin] = nums[minindex]</span><br><span class="line">        nums[minindex] = tmp</span><br><span class="line">        count_swap += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">print(nums, count_swap, count_iter)</span><br></pre></td></tr></table></figure><h2 id="简单选择排序总结"><a href="#简单选择排序总结" class="headerlink" title="简单选择排序总结"></a>简单选择排序总结</h2><ul><li>简单选择排序需要数据一轮轮比较，并在每一轮中发现极值</li><li>没有办法知道当前轮是否已经达到排序要求，但是可以知道极值是否在目标索引位置上</li><li>遍历次数1,…,n-1之和n(n-1)/2</li><li>时间复杂度O(n2)</li><li>减少了交换次数，提高了效率，性能略好于冒泡法</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;第三章-Python-内置数据结构&quot;&gt;&lt;a href=&quot;#第三章-Python-内置数据结构&quot; class=&quot;headerlink&quot; title=&quot;第三章 - Python 内置数据结构&quot;&gt;&lt;/a&gt;第三章 - Python 内置数据结构&lt;/h1&gt;&lt;h2 id=&quot;简
      
    
    </summary>
    
      <category term="python-magedu" scheme="https://herodanny.github.io/categories/python-magedu/"/>
    
    
      <category term="python, Algorithm" scheme="https://herodanny.github.io/tags/python-Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>python全栈-magedu-2018-笔记10</title>
    <link href="https://herodanny.github.io/python-magedu-2018-notes10.html"/>
    <id>https://herodanny.github.io/python-magedu-2018-notes10.html</id>
    <published>2019-04-29T10:30:47.000Z</published>
    <updated>2019-04-29T10:31:53.914Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第三章-Python-内置数据结构"><a href="#第三章-Python-内置数据结构" class="headerlink" title="第三章 - Python 内置数据结构"></a>第三章 - Python 内置数据结构</h1><h2 id="集set"><a href="#集set" class="headerlink" title="集set"></a>集set</h2><ul><li>约定<ul><li>set 翻译为集合</li><li>collection 翻译为集合类型，是一个大概念</li></ul></li><li>set<ul><li><strong>可变的、无序的、不重复的</strong>元素的集合</li></ul></li></ul><h2 id="set定义-初始化"><a href="#set定义-初始化" class="headerlink" title="set定义 初始化"></a>set定义 初始化</h2><ul><li>set() -&gt; new empty set object</li><li>set(iterable) -&gt; new set object</li></ul><p>&emsp; s1 = set()<br>&emsp; s2 = set(range(5))<br>&emsp; s3 = set(list(range(10)))<br>&emsp; s4 = {} # dict<br>&emsp; s5 = {9,10,11} # set<br>&emsp; s6 = {(1,2),3,’a’}<br>&emsp; s7 = {[1],(1,),1} # unhashable type: ‘list’  </p><h2 id="set的元素"><a href="#set的元素" class="headerlink" title="set的元素"></a>set的元素</h2><ul><li>set的元素要求必须可以hash（因为set就是哈希表啊）</li><li>目前学过的不可hash的类型有list、set</li><li>元素不可以索引，因为无序</li><li>set可以迭代</li></ul><h2 id="set增加"><a href="#set增加" class="headerlink" title="set增加"></a>set增加</h2><ul><li><p>add(elem)</p><ul><li>增加一个元素到set中</li><li>如果元素存在，什么都不做</li></ul></li><li><p>update(*others)</p><ul><li>合并其他元素到set集合中来</li><li>参数others必须是可迭代对象</li><li>就地修改</li></ul></li></ul><h2 id="set删除"><a href="#set删除" class="headerlink" title="set删除"></a>set删除</h2><ul><li>remove(elem)<ul><li>从set中移除一个元素</li><li>元素不存在，抛出KeyError异常。为什么是KeyError？</li></ul></li><li>discard(elem)<ul><li>从set中移除一个元素</li><li>元素不存在，什么都不做</li></ul></li><li>pop() -&gt; item<ul><li>移除并返回任意的元素。为什么是任意元素？</li><li>空集返回KeyError异常</li><li>clear()</li><li>移除所有元素</li></ul></li></ul><h2 id="set修改、查询"><a href="#set修改、查询" class="headerlink" title="set修改、查询"></a>set修改、查询</h2><ul><li>修改<ul><li>要么删除，要么加入新的元素</li><li>为什么没有修改？</li></ul></li><li>查询<ul><li>非线性结构，无法索引</li></ul></li><li>遍历<ul><li>可以迭代所有元素</li></ul></li><li>成员运算符<ul><li>in 和 not in 判断元素是否在set中</li><li>效率呢？与索引访问列表的效率是差不多的，O(1)</li></ul></li></ul><h2 id="set成员运算符的比较"><a href="#set成员运算符的比较" class="headerlink" title="set成员运算符的比较"></a>set成员运算符的比较</h2><ul><li>list和set的比较</li><li>lst1 = list(range(100))</li><li>lst2 = list(range(1000000))</li><li>-1 in lst1、-1 in lst2 看看效率</li><li>set1 = set(range(100))</li><li>set2 = set(range(1000000))</li><li>-1 in set1、-1 in set2 看看效率  </li></ul><h2 id="set成员运算符的比较-1"><a href="#set成员运算符的比较-1" class="headerlink" title="set成员运算符的比较"></a>set成员运算符的比较</h2><p>%%timeit lst1=list(range(100))<br>a = -1 in lst1  </p><p>%%timeit lst1=list(range(1000000))<br>a = -1 in lst1  </p><p>%%timeit set1=set(range(100))<br>a = -1 in set1  </p><p>%%timeit set1=set(range(1000000))<br>a = -1 in set1  </p><p>set不管元素怎么增加遍历的效率都是一样的。  </p><h2 id="set和线性结构"><a href="#set和线性结构" class="headerlink" title="set和线性结构"></a>set和线性结构</h2><ul><li>线性结构的查询时间复杂度是O(n)，即随着数据规模的增大而增加耗时</li><li><p>set、dict等结构，内部使用hash值作为key，时间复杂度可以做到O(1)，查询时间和数据规模无关</p></li><li><p>可hash</p><ul><li>数值型int、float、complex</li><li>布尔型True、False</li><li>字符串string、bytes</li><li>tuple</li><li>None</li><li>以上都是不可变类型，成为可哈希类型，hashable</li></ul></li><li><p>set的元素必须是可hash的</p></li></ul><h2 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h2><ul><li>基本概念<ul><li>全集<ul><li>所有元素的集合。例如实数集，所有实数组成的集合就是全集</li></ul></li><li>子集subset和超集superset<ul><li>一个集合A所有元素都在另一个集合B内，A是B的子集，B是A的超集</li></ul></li><li>真子集和真超集<ul><li>A是B的子集，且A不等于B，A就是B的真子集，B是A的真超集</li></ul></li><li>并集：多个集合合并的结果</li><li>交集：多个集合的公共部分</li><li>差集：集合中除去和其他集合公共部分</li></ul></li></ul><h2 id="集合运算"><a href="#集合运算" class="headerlink" title="集合运算"></a>集合运算</h2><ul><li>并集<ul><li>将两个集合A和B的所有的元素合并到一起，组成的集合称作集合A与集合B的并集</li><li>union(*others)<ul><li>返回和多个集合合并后的新的集合</li></ul></li><li>| 运算符重载<ul><li>等同union</li></ul></li><li>update(*others)<ul><li>和多个集合合并，就地修改</li></ul></li><li>|=<ul><li>等同update</li></ul></li></ul></li></ul><p><img src="https://raw.githubusercontent.com/herodanny/Image-Hosting/master/data/bingji.jpg" alt="bingji"></p><h2 id="集合运算-1"><a href="#集合运算-1" class="headerlink" title="集合运算"></a>集合运算</h2><ul><li>交集<ul><li>集合A和B，由所有属于A且属于B的元素组成的集合</li><li>intersection(*others)<ul><li>返回和多个集合的交集</li></ul></li><li>&amp;<ul><li>等同intersection</li></ul></li><li>intersection_update(*others)<ul><li>获取和多个集合的交集，并就地修改</li></ul></li><li>&amp;=<ul><li>等同intersection_update</li></ul></li></ul></li></ul><p><img src="https://raw.githubusercontent.com/herodanny/Image-Hosting/master/data/jiaoji.jpg" alt="jiaoji"></p><h2 id="集合运算-2"><a href="#集合运算-2" class="headerlink" title="集合运算"></a>集合运算</h2><ul><li>差集<ul><li>集合A和B，由所有属于A且不属于B的元素组成的集合</li><li>difference(*others)<ul><li>返回和多个集合的差集</li></ul></li></ul></li><li>-<ul><li>等同difference</li></ul></li><li>difference_update(*others)<ul><li>获取和多个集合的差集并就地修改</li></ul></li><li>-=<ul><li>等同difference_update</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/herodanny/Image-Hosting/master/data/chaji.jpg" alt="chaji"></p><h2 id="集合运算-3"><a href="#集合运算-3" class="headerlink" title="集合运算"></a>集合运算</h2><ul><li>对称差集<ul><li>集合A和B，由所有不属于A和B的交集元素组成的集合，记作（A-B）∪（B-A）</li><li>symmetric_differece(other)<ul><li>返回和另一个集合的差集</li></ul></li><li>\^<ul><li>等同symmetric_differece</li></ul></li><li>symmetric_differece_update(other)<ul><li>获取和另一个集合的差集并就地修改</li></ul></li><li>\^=<ul><li>等同symmetric_differece_update</li></ul></li></ul></li></ul><p><img src="https://raw.githubusercontent.com/herodanny/Image-Hosting/master/data/duichenchaji.jpg" alt="duichenchaji"></p><h2 id="集合运算-4"><a href="#集合运算-4" class="headerlink" title="集合运算"></a>集合运算</h2><ul><li>issubset(other)、&lt;=<ul><li>判断当前集合是否是另一个集合的子集</li></ul></li><li>set1 &lt; set2<ul><li>判断set1是否是set2的真子集</li></ul></li><li>issuperset(other)、&gt;=<ul><li>判断当前集合是否是other的超集</li></ul></li><li>set1 &gt; set2<ul><li>判断set1是否是set的真超集</li></ul></li><li>isdisjoint(other)<ul><li>当前集合和另一个集合没有交集</li><li>没有交集，返回True</li></ul></li></ul><h2 id="集合应用"><a href="#集合应用" class="headerlink" title="集合应用"></a>集合应用</h2><ul><li>共同好友<ul><li>你的好友A、B、C，他的好友C、B、D，求共同好友<br>如果是推荐好友，用差集求，不用查库，在内存中集合运算是非常快的，而且往往用到Redis的  </li></ul></li><li>微信群提醒<ul><li>XXX与群里其他人都不是微信朋友关系</li></ul></li><li>权限判断<ul><li>有一个API，要求权限同时具备A、B、C才能访问，用户权限是B、C、D，判断用户是否能够访问该API</li><li>有一个API，要求权限具备A、B、C任意一项就可访问，用户权限是B、C、D，判断用户是否能够访问该API</li></ul></li><li>一个总任务列表，存储所有任务。一个完成的任务列表。找出为未完成的任务</li></ul><p>解决的方法都不是唯一的，下面仅供参考。  </p><h2 id="集合应用-1"><a href="#集合应用-1" class="headerlink" title="集合应用"></a>集合应用</h2><ul><li><p>共同好友</p><ul><li>你的好友A、B、C，他的好友C、B、D，求共同好友</li><li>交集问题：{‘A’, ‘B’, ‘C’}.intersection({‘B’, ‘C’, ‘D’})</li></ul></li><li><p>微信群提醒</p><ul><li>XXX与群里其他人都不是微信朋友关系</li><li>并集：userid in (A | B | C | …) == False，A、B、C等是微信好友的并集，用户ID不在这个并集中，说明他和任何人都不是朋友</li></ul></li></ul><h2 id="集合应用-2"><a href="#集合应用-2" class="headerlink" title="集合应用"></a>集合应用</h2><ul><li>权限判断<ul><li>有一个API，要求权限同时具备A、B、C才能访问，用户权限是B、C、D，判断用户是否能够访问该API<ul><li>API集合A，权限集合P</li><li>A - P = {} ，A-P为空集，说明P包含A</li><li>A.issubset(P) 也行，A是P的子集也行</li><li>A &amp; P = A 也行</li></ul></li><li>有一个API，要求权限具备A、B、C任意一项就可访问，用户权限是B、C、D，判断用户是否能够访问该API<ul><li>API集合A，权限集合P</li><li>A &amp; P != {} 就可以</li><li>A.isdisjoint(P) == False 表示有交集</li></ul></li></ul></li></ul><h2 id="集合应用-3"><a href="#集合应用-3" class="headerlink" title="集合应用"></a>集合应用</h2><ul><li>一个总任务列表，存储所有任务。一个已完成的任务列表。找出为未完成的任务<ul><li>业务中，任务ID一般不可以重复</li><li>所有任务ID放到一个set中，假设为ALL</li><li>所有已完成的任务ID放到一个set中，假设为COMPLETED，它是ALL的子集</li><li>ALL - COMPLETED = UNCOMPLETED</li></ul></li></ul><h2 id="集合练习"><a href="#集合练习" class="headerlink" title="集合练习"></a>集合练习</h2><ul><li>随机产生2组各10个数字的列表，如下要求：<ul><li>每个数字取值范围[10,20]</li><li>统计20个数字中，一共有多少个不同的数字？</li><li>2组中，不重复的数字有几个？分别是什么？</li><li>2组中，重复的数字有几个？分别是什么？</li></ul></li></ul><h2 id="集合练习-1"><a href="#集合练习-1" class="headerlink" title="集合练习"></a>集合练习</h2><ul><li>随机产生2组各10个数字的列表，如下要求：<ul><li>每个数字取值范围[10,20]</li><li>统计20个数字中，一共有多少个不同的数字？</li><li>2组比较，不重复的数字有几个？分别是什么？</li><li>2组比较，重复的数字有几个？分别是什么？  </li></ul></li></ul><p>&emsp; a = [1, 9, 7, 5, 6, 7, 8, 8, 2, 6]<br>&emsp; b = [1, 9, 0, 5, 6, 4, 8, 3, 2, 3]<br>&emsp; s1 = set(a)<br>&emsp; s2 = set(b)<br>&emsp; print(s1)<br>&emsp; print(s2)<br>&emsp; print(s1.union(s2))<br>&emsp; print(s1.symmetric_difference(s2))<br>&emsp; print(s1.intersection(s2))  </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;第三章-Python-内置数据结构&quot;&gt;&lt;a href=&quot;#第三章-Python-内置数据结构&quot; class=&quot;headerlink&quot; title=&quot;第三章 - Python 内置数据结构&quot;&gt;&lt;/a&gt;第三章 - Python 内置数据结构&lt;/h1&gt;&lt;h2 id=&quot;集
      
    
    </summary>
    
      <category term="python-magedu" scheme="https://herodanny.github.io/categories/python-magedu/"/>
    
    
      <category term="python" scheme="https://herodanny.github.io/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>python全栈-magedu-2018-笔记9</title>
    <link href="https://herodanny.github.io/python-magedu-2018-notes9.html"/>
    <id>https://herodanny.github.io/python-magedu-2018-notes9.html</id>
    <published>2019-04-28T06:33:09.000Z</published>
    <updated>2019-05-19T12:30:46.949Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第五章-Python-封装和结构"><a href="#第五章-Python-封装和结构" class="headerlink" title="第五章 - Python 封装和结构"></a>第五章 - Python 封装和结构</h1><h2 id="封装和解构"><a href="#封装和解构" class="headerlink" title="封装和解构"></a>封装和解构</h2><ul><li>封装<ul><li>将多个值使用逗号分割，组合在一起</li><li>本质上，返回一个元组，只是省掉了小括号</li><li>python特有语法，被很多语言学习和借鉴  </li></ul></li></ul><p>&emsp;&emsp; t1 = (1,2) # 定义为元组<br>&emsp;&emsp; t2 = 1,2 # 将1和2封装成元组，一般都这么写<br>&emsp;&emsp; type(t1)<br>&emsp;&emsp; type(t2)  </p><h2 id="封装和解构-1"><a href="#封装和解构-1" class="headerlink" title="封装和解构"></a>封装和解构</h2><ul><li>举例  </li></ul><p>&emsp;&emsp; a = 4<br>&emsp;&emsp; b = 5  </p><p>&emsp;&emsp; <strong>temp = a</strong><br>&emsp;&emsp; <strong>a = b</strong><br>&emsp;&emsp; <strong>b = temp</strong>  </p><p>&emsp;&emsp; 等价于<br>&emsp;&emsp; <strong>a, b = b, a</strong>  </p><p>&emsp;&emsp; 上句中，等号右边使用了封装，而左边就使用了解构</p><h2 id="解构"><a href="#解构" class="headerlink" title="解构"></a>解构</h2><ul><li>把线性结构的元素解开，并顺序的赋给其它变量</li><li><p>左边接纳的变量数要和右边解开的元素个数一致</p></li><li><p>举例  </p></li></ul><p>&emsp;&emsp; lst = [3, 5]<br>&emsp;&emsp; first, second = lst<br>&emsp;&emsp; print(first, second)  </p><h2 id="解构-1"><a href="#解构-1" class="headerlink" title="解构"></a>解构</h2><p>a,b = 1,2<br>a,b = (1,2)<br>a,b = [1,2]<br>a,b = [10,20]<br>a,b = {10,20}<br>a,b = {‘a’:10,’b’:20} # 非线性结构也可以解构，a为a是key值，b为b<br>a,b = {10,20,30}<br>a,*b = {10,20,30}  # a为1，b为[20,30]，*是匹配任意多个元素，因为解构时元素不确定，所以用列表<br>[a,b] = (1,2)<br>[a,b] = 10,20<br>(a,b) = {30,40}  </p><h2 id="Python3的解构"><a href="#Python3的解构" class="headerlink" title="Python3的解构"></a>Python3的解构</h2><ul><li>使用 *变量名 接收，但不能单独使用</li><li>被 *变量名 收集后组成一个列表</li><li>举例  </li></ul><p>&emsp;&emsp; lst = list(range(1, 101, 2))<br>&emsp;&emsp; head, *mid, tail = lst<br>&emsp;&emsp; *lst2 = lst<br>&emsp;&emsp; *body, tail = lst<br>&emsp;&emsp; head, *tail = lst<br>&emsp;&emsp; head, *m1, *m2, tail = lst<br>&emsp;&emsp; head, *mid, tail = “abcdefghijklmn”<br>&emsp;&emsp; type(mid)</p><h2 id="丢弃变量"><a href="#丢弃变量" class="headerlink" title="丢弃变量"></a>丢弃变量</h2><ul><li>这是一个惯例，是一个不成文的约定，不是标准</li><li>如果不关心一个变量，就可以定义改变量的名字为_</li><li>_是一个合法的标识符，也可以作为一个有效的变量使用，但是定义成下划线就是希望不要被使用，除非你明确的知道这个数据需要使用  </li><li>举例</li></ul><p>&emsp;&emsp; lst = [9,8,7,20]<br>&emsp;&emsp; first, *second = lst<br>&emsp;&emsp; head, *_, tail = lst<br>&emsp;&emsp; print(head)<br>&emsp;&emsp; print(tail)<br>&emsp;&emsp; _是合法的标识符，看到下划线就知道这个变量就是不想被使用<br>&emsp;&emsp; print(_)</p><h2 id="丢弃变量-1"><a href="#丢弃变量-1" class="headerlink" title="丢弃变量"></a>丢弃变量</h2><ul><li>举例  </li></ul><p>&emsp;&emsp; lst = [9,8,7,20]<br>&emsp;&emsp; first, *second = lst<br>&emsp;&emsp; _ , *_, tail = lst<br>&emsp;&emsp; print(_)<br>&emsp;&emsp; print(tail)<br>&emsp;&emsp; print(_)</p><h2 id="丢弃变量-2"><a href="#丢弃变量-2" class="headerlink" title="丢弃变量"></a>丢弃变量</h2><ul><li><p>总结</p><ul><li>_ 这个变量本身无任何语义，没有任何可读性，所以不是用来给人使用的</li><li>Python中很多库，都使用这个变量，使用十分广泛。请不要在不明确变量作用域的情况下，使用 _ 导致和库中 _ 冲突</li></ul></li><li><p>练习</p><ul><li>lst = list(range(10)) # 这样一个列表，取出第二个、第四个、倒数第二个</li></ul></li></ul><h2 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h2><ul><li>练习<ul><li>从lst = [1,(2,3,4),5]中，提取4出来</li><li>环境变量JAVA_HOME=/usr/bin，返回环境变量名和路径</li><li>对列表[1, 9, 8, 5, 6, 7, 4, 3, 2]使用冒泡法排序，要求使用封装和解构来交互数据</li></ul></li></ul><h2 id="练习-1"><a href="#练习-1" class="headerlink" title="练习"></a>练习</h2><ul><li>练习<ul><li>从lst = [1,(2,3,4),5]中，提取4出来  </li></ul></li></ul><p>&emsp;&emsp; lst = [1,(2,3,4),5]<br>&emsp;&emsp; a,(b,c,d),e = lst<br>&emsp;&emsp; print(a,b,c,d,e)  </p><p>&emsp;&emsp; _, (*_, val), *_ = lst<br>&emsp;&emsp; print(val)  </p><p>&emsp;&emsp; _, [*_, val], *_ = lst<br>&emsp;&emsp; print(val)  </p><h2 id="练习-2"><a href="#练习-2" class="headerlink" title="练习"></a>练习</h2><ul><li><p>练习</p><ul><li>环境变量JAVA_HOME=/usr/bin，返回变量名和路径<br>key, _ , val = “JAVA_HOME=/usr/bin”.partition(‘=’)<br>print(key)<br>print(val)  </li></ul></li><li><p>总结：</p><ul><li>解构，是Python提供的很好的功能，可以方便的提取复杂数据结构的值</li><li>配合 _ 的使用，会更加便利</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;第五章-Python-封装和结构&quot;&gt;&lt;a href=&quot;#第五章-Python-封装和结构&quot; class=&quot;headerlink&quot; title=&quot;第五章 - Python 封装和结构&quot;&gt;&lt;/a&gt;第五章 - Python 封装和结构&lt;/h1&gt;&lt;h2 id=&quot;封装和解构
      
    
    </summary>
    
      <category term="python-magedu" scheme="https://herodanny.github.io/categories/python-magedu/"/>
    
    
      <category term="python" scheme="https://herodanny.github.io/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>python全栈-magedu-2018-笔记8</title>
    <link href="https://herodanny.github.io/python-magedu-2018-notes8.html"/>
    <id>https://herodanny.github.io/python-magedu-2018-notes8.html</id>
    <published>2019-04-28T02:34:30.000Z</published>
    <updated>2019-04-28T02:35:41.363Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第四章-IPython-使用"><a href="#第四章-IPython-使用" class="headerlink" title="第四章 - IPython 使用"></a>第四章 - IPython 使用</h1><h2 id="帮助"><a href="#帮助" class="headerlink" title="帮助"></a>帮助</h2><ul><li>?<ul><li>Ipython的概述和简介</li></ul></li><li>help(name)<ul><li>查询指定名称的帮助，是python帮助</li></ul></li><li>obj?<ul><li>列出obj对象的详细信息</li></ul></li><li>obj??<ul><li>列出更加详细的信息</li></ul></li></ul><h2 id="特殊变量"><a href="#特殊变量" class="headerlink" title="特殊变量"></a>特殊变量</h2><ul><li>_ 表示前一次输出</li><li>__ 表示倒数第二次输出</li><li>___ 表示倒数第三次输出</li><li>_dh 目录历史</li><li>_oh 输出历史</li></ul><h2 id="shell命令"><a href="#shell命令" class="headerlink" title="shell命令"></a>shell命令</h2><ul><li>!command 执行shell命令<ul><li>!ls -l</li><li>!touch test.txt</li><li>files = !ls -l | grep py</li></ul></li></ul><h2 id="魔术方法"><a href="#魔术方法" class="headerlink" title="魔术方法"></a>魔术方法</h2><ul><li>使用%百分号开头的，IPython内置的特殊方法<ul><li>%magic 格式<ul><li>% 开头是line magic</li><li>%% 开头是 cell magic，notebook的cell</li></ul></li><li>%alias 定义一个系统命令的别名<ul><li>alias ll ls -l</li></ul></li><li>%timeit statement<ul><li>-n 一个循环loop执行语句多少次</li><li>-r 循环执行多少次loop，取最好的结果</li></ul></li><li>%%timeit setup_code<br>code…..</li></ul></li></ul><h2 id="魔术方法-1"><a href="#魔术方法-1" class="headerlink" title="魔术方法"></a>魔术方法</h2><ul><li>%cd 改变当前工作目录，cd可以认为是%cd的链接。路径历史在_dh中查看</li><li>%pwd、pwd 显示当前工作目录</li><li>%ls 、ls 返回文件列表</li><li>注意：%pwd这种是魔术方法，是IPython的内部实现，和操作系统无关。而!pwd 就要依赖当前操作系统的shell提供的命令执行，默认windows不支持pwd命令</li><li>%%js、%%javascript 在cell中运行js脚本<br>%%js<br>alert(‘a’ + 1)  </li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;第四章-IPython-使用&quot;&gt;&lt;a href=&quot;#第四章-IPython-使用&quot; class=&quot;headerlink&quot; title=&quot;第四章 - IPython 使用&quot;&gt;&lt;/a&gt;第四章 - IPython 使用&lt;/h1&gt;&lt;h2 id=&quot;帮助&quot;&gt;&lt;a href=&quot;
      
    
    </summary>
    
      <category term="python-magedu" scheme="https://herodanny.github.io/categories/python-magedu/"/>
    
    
      <category term="python" scheme="https://herodanny.github.io/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>python全栈-magedu-2018-笔记7</title>
    <link href="https://herodanny.github.io/python-magedu-2018-notes7.html"/>
    <id>https://herodanny.github.io/python-magedu-2018-notes7.html</id>
    <published>2019-04-27T15:40:52.000Z</published>
    <updated>2019-05-11T02:49:25.410Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第三章-Python-内置数据结构"><a href="#第三章-Python-内置数据结构" class="headerlink" title="第三章 - Python 内置数据结构"></a>第三章 - Python 内置数据结构</h1><h2 id="线性结构"><a href="#线性结构" class="headerlink" title="线性结构"></a>线性结构</h2><ul><li><p>线性结构</p><ul><li>可迭代 for … in</li><li>len()可以获取长度</li><li>通过下标可以访问</li><li>可以切片</li></ul></li><li><p>学过的线性结构</p><ul><li>列表、元组、字符串、bytes、bytearray</li></ul></li></ul><h2 id="切片"><a href="#切片" class="headerlink" title="切片"></a>切片</h2><ul><li>切片<ul><li>通过索引区间访问线性结构的一段数据</li><li>sequence[start:stop] 表示返回[start, stop)区间的子序列</li><li>支持负索引</li><li>start为0，可以省略</li><li>stop为末尾，可以省略</li><li>超过上界（右边界），就取到末尾；超过下界（左边界），取到开头</li><li>start一定要在stop的左边</li><li>[:] 表示从头至尾，全部元素被取出，等效于copy()方法</li></ul></li></ul><h2 id="切片-1"><a href="#切片-1" class="headerlink" title="切片"></a>切片</h2><ul><li><p>切片举例<br>‘<a href="http://www.github.com&#39;[4:10]" target="_blank" rel="noopener">www.github.com&#39;[4:10]</a><br>‘<a href="http://www.github.com&#39;[:10]" target="_blank" rel="noopener">www.github.com&#39;[:10]</a><br>‘<a href="http://www.github.com&#39;[4:]" target="_blank" rel="noopener">www.github.com&#39;[4:]</a><br>‘<a href="http://www.github.com&#39;[:]" target="_blank" rel="noopener">www.github.com&#39;[:]</a><br>‘<a href="http://www.github.com&#39;[:-1]" target="_blank" rel="noopener">www.github.com&#39;[:-1]</a><br>‘<a href="http://www.github.com&#39;[4:-4]" target="_blank" rel="noopener">www.github.com&#39;[4:-4]</a><br>‘<a href="http://www.github.com&#39;[4:50]" target="_blank" rel="noopener">www.github.com&#39;[4:50]</a><br>b’<a href="http://www.github.com&#39;[-40:10]" target="_blank" rel="noopener">www.github.com&#39;[-40:10]</a><br>bytearray(b’<a href="http://www.github.com&#39;)[-4:10]" target="_blank" rel="noopener">www.github.com&#39;)[-4:10]</a><br>tuple(‘<a href="http://www.github.com&#39;)[-10:10]" target="_blank" rel="noopener">www.github.com&#39;)[-10:10]</a><br>list(‘<a href="http://www.github.com&#39;)[-10:-4]" target="_blank" rel="noopener">www.github.com&#39;)[-10:-4]</a>  </p></li><li><p>步长切片</p><ul><li>[start:stop:step]  </li><li>step为步长，可以正、负整数，默认是1  </li><li>step要和start:stop同向，否则返回空序列<br>‘<a href="http://www.github.com&#39;[4:10:2]" target="_blank" rel="noopener">www.github.com&#39;[4:10:2]</a><br>list(‘<a href="http://www.github.com&#39;)[4:10:-2]" target="_blank" rel="noopener">www.github.com&#39;)[4:10:-2]</a><br>tuple(‘<a href="http://www.github.com&#39;)[-10:-4:2]" target="_blank" rel="noopener">www.github.com&#39;)[-10:-4:2]</a><br>b’<a href="http://www.github.com&#39;[-4:-10:2]" target="_blank" rel="noopener">www.github.com&#39;[-4:-10:2]</a><br>bytearray(b’<a href="http://www.github.com&#39;)[-4:-10:-2]" target="_blank" rel="noopener">www.github.com&#39;)[-4:-10:-2]</a>  </li></ul></li><li><p>切片可以赋值<br>arr = [ ‘C’, ‘python’, ‘js’, ‘css’, ‘html’, ‘node’]<br>arr[2:4] = [‘pc’,’wd’]<br>arr  # [‘C’, ‘python’, ‘pc’, ‘wd’, ‘html’, ‘node’]  </p></li><li><p>切片可以插入和删除元素<br>arr = [‘C’, ‘python’, ‘js’, ‘css’, ‘html’, ‘node’]<br>arr[1:1] = [‘pc’,’wd’]  # [1:1]表示在1开始查找，但没有查找，所以是在索引1添加元素<br>arr  # [‘C’, ‘pc’, ‘wd’, ‘python’, ‘js’, ‘css’, ‘html’, ‘node’]<br>arr[2:3] = []  # 删除索引2的元素<br>arr  # [‘C’, ‘pc’, ‘python’, ‘js’, ‘css’, ‘html’, ‘node’]  </p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;第三章-Python-内置数据结构&quot;&gt;&lt;a href=&quot;#第三章-Python-内置数据结构&quot; class=&quot;headerlink&quot; title=&quot;第三章 - Python 内置数据结构&quot;&gt;&lt;/a&gt;第三章 - Python 内置数据结构&lt;/h1&gt;&lt;h2 id=&quot;线
      
    
    </summary>
    
      <category term="python-magedu" scheme="https://herodanny.github.io/categories/python-magedu/"/>
    
    
      <category term="python" scheme="https://herodanny.github.io/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>python全栈-magedu-2018-笔记6</title>
    <link href="https://herodanny.github.io/python-magedu-2018-notes6.html"/>
    <id>https://herodanny.github.io/python-magedu-2018-notes6.html</id>
    <published>2019-04-27T09:25:01.000Z</published>
    <updated>2019-04-27T09:26:34.423Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第三章-Python-内置数据结构"><a href="#第三章-Python-内置数据结构" class="headerlink" title="第三章 - Python 内置数据结构"></a>第三章 - Python 内置数据结构</h1><h2 id="bytes、bytearray"><a href="#bytes、bytearray" class="headerlink" title="bytes、bytearray"></a>bytes、bytearray</h2><ul><li>Python3引入两个新类型<ul><li>bytes<ul><li><strong>不可变</strong>字节序列</li></ul></li><li>bytearray<ul><li>字节数组</li><li><strong>可变</strong></li></ul></li></ul></li></ul><h2 id="bytes、bytearray-1"><a href="#bytes、bytearray-1" class="headerlink" title="bytes、bytearray"></a>bytes、bytearray</h2><ul><li><p>字符串与bytes</p><ul><li>字符串是字符组成的有序序列，字符可以使用编码来理解</li><li>bytes是字节组成的有序的<strong>不可变</strong>序列</li><li>bytearray是字节组成的有序的<strong>可变</strong>序列</li></ul></li><li><p>编码与解码</p><ul><li>字符串按照不同的字符集编码encode返回字节序列bytes<ul><li>encode(encoding=’utf-8’, errors=’strict’) -&gt; bytes</li></ul></li><li>字节序列按照不同的字符集解码decode返回字符串<ul><li>bytes.decode(encoding=”utf-8”, errors=”strict”) -&gt; str</li><li>bytearray.decode(encoding=”utf-8”, errors=”strict”) -&gt; str</li></ul></li></ul></li></ul><h2 id="bytes定义"><a href="#bytes定义" class="headerlink" title="bytes定义"></a>bytes定义</h2><ul><li>定义<ul><li>bytes() 空bytes</li><li>bytes(int) 指定长度的bytes，被0填充</li><li>bytes(iterable_of_ints) -&gt; bytes [0,255]的int组成的可迭代对象</li><li>bytes(string, encoding[, errors]) -&gt; bytes 等价于string.encode()</li><li>bytes(bytes_or_buffer) -&gt; immutable copy of bytes_or_buffer 从一个字节序列或者buffer复制出 (是浅拷贝)  <ul><li>一个新的不可变的bytes对象</li></ul></li><li>使用b前缀定义<ul><li>只允许基本ASCII使用字符形式b’abc9’</li><li>使用16进制表示b”\x41\x61”<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">a = bytes(range(<span class="number">15</span>))</span><br><span class="line">a</span><br><span class="line"><span class="string">b'\x00\x01\x02\x03\x04\x05\x06\x07\x08\t\n\x0b\x0c\r\x0e'</span></span><br><span class="line"><span class="comment"># 看ASCII表，9 是\t，10是\n，13是\r。前面那些 00 01 02 03，</span></span><br><span class="line"><span class="comment"># 也有自己的意思，但是没办法用字符表示出来，所以就用它的十六进制表示法表示出来。</span></span><br><span class="line"><span class="comment"># 类似当看到返回或自己写的是 b'hello' 其实应该是 \x68\x65\x6c\x6c\x6f </span></span><br><span class="line"><span class="comment"># 这样一串，只不过ipython等工具，把他优化成便于人类理解的形式。</span></span><br></pre></td></tr></table></figure></li></ul></li></ul></li></ul><h2 id="bytes操作"><a href="#bytes操作" class="headerlink" title="bytes操作"></a>bytes操作</h2><ul><li><p>和str类型类似，都是不可变类型，所以方法很多都一样。只不过bytes的方法，输入是bytes，输出是bytes<br>&emsp; b’abcdef’.replace(b’f’,b’k’)<br>&emsp; b’abc’.find(b’b’)</p></li><li><p>类方法 bytes.fromhex(string)</p><ul><li>string必须是2个字符的16进制的形式，’6162 6a 6b’，空格将被忽略<br>&emsp; bytes.fromhex(‘6162 09 6a 6b00’)<br>&emsp; 输出：b’ab\tjk\x00’ # 即a:61 b:63 \t:09 j:6a k=6b 00:\x00  </li></ul></li><li><p>hex()</p><ul><li>返回16进制表示的字符串<br>&emsp; ‘abc’.encode().hex()</li></ul></li><li><p>索引<br>&emsp; b’abcdef’[2] 返回该字节对应的数，int类型</p></li></ul><h2 id="bytearray定义"><a href="#bytearray定义" class="headerlink" title="bytearray定义"></a>bytearray定义</h2><ul><li><p>定义</p><ul><li>bytearray() 空bytearray</li><li>bytearray(int) 指定字节的bytearray，被0填充</li><li>bytearray(iterable_of_ints) -&gt; bytearray [0,255]的int组成的可迭代对象</li><li>bytearray(string, encoding[, errors]) -&gt; bytearray 近似string.encode()，不过返回可变对象</li><li><p>bytearray(bytes_or_buffer) 从一个字节序列或者buffer复制出一个新的可变的bytearray对象 （有时也有从bytes转list对象）</p></li><li><p>注意，b前缀定义的类型是bytes类型</p></li></ul></li></ul><h2 id="bytearray操作"><a href="#bytearray操作" class="headerlink" title="bytearray操作"></a>bytearray操作</h2><ul><li>和bytes类型的方法相同<ul><li>bytearray(b’abcdef’).replace(b’f’,b’k’)</li><li>bytearray(b’abc’).find(b’b’)</li></ul></li><li>类方法 bytearray.fromhex(string)<ul><li>string必须是2个字符的16进制的形式，’6162 6a 6b’，空格将被忽略<br>bytearray.fromhex(‘6162 09 6a 6b00’)</li></ul></li><li>hex()<ul><li>返回16进制表示的字符串<br>bytearray(‘abc’.encode()).hex()  </li></ul></li><li>索引<br>bytearray(b’abcdef’)[2] 返回该字节对应的数，int类型</li></ul><h2 id="bytearray操作-1"><a href="#bytearray操作-1" class="headerlink" title="bytearray操作"></a>bytearray操作</h2><ul><li>append(int) 尾部追加一个元素</li><li>insert(index, int) 在指定索引位置插入元素</li><li>extend(iterable_of_ints) 将一个可迭代的整数集合追加到当前bytearray</li><li>pop(index=-1) 从指定索引上移除元素，默认从尾部移除</li><li>remove(value) 找到第一个value移除，找不到抛ValueError异常</li><li>注意：上述方法若需要使用int类型，值在[0, 255]</li><li>clear() 清空bytearray</li><li>reverse() 翻转bytearray，就地修改</li></ul><p>&emsp;&emsp; b = bytearray()<br>&emsp;&emsp; b.append(97)<br>&emsp;&emsp; b.append(99)<br>&emsp;&emsp; b.insert(1,98)<br>&emsp;&emsp; b.extend([65,66,67])<br>&emsp;&emsp; b.remove(66)<br>&emsp;&emsp; b.pop()<br>&emsp;&emsp; b.reverse()<br>&emsp;&emsp; b.clear()  </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;第三章-Python-内置数据结构&quot;&gt;&lt;a href=&quot;#第三章-Python-内置数据结构&quot; class=&quot;headerlink&quot; title=&quot;第三章 - Python 内置数据结构&quot;&gt;&lt;/a&gt;第三章 - Python 内置数据结构&lt;/h1&gt;&lt;h2 id=&quot;b
      
    
    </summary>
    
      <category term="python-magedu" scheme="https://herodanny.github.io/categories/python-magedu/"/>
    
    
      <category term="python" scheme="https://herodanny.github.io/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>python全栈-magedu-2018-笔记5</title>
    <link href="https://herodanny.github.io/python-magedu-2018-notes5.html"/>
    <id>https://herodanny.github.io/python-magedu-2018-notes5.html</id>
    <published>2019-04-26T13:09:12.000Z</published>
    <updated>2019-04-27T01:51:20.389Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第三章-Python-内置数据结构"><a href="#第三章-Python-内置数据结构" class="headerlink" title="第三章 - Python 内置数据结构"></a>第三章 - Python 内置数据结构</h1><h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><ul><li>一个个字符组成的有序的序列，是字符的集合。</li><li>python中一个字符也是str类型。</li><li>使用单引号、双引号、三引号引住的字符序列</li><li>字符串是<strong>不可变</strong>对象</li><li>Python3起，字符串就是Unicode类型</li></ul><h2 id="字符串定义-初始化"><a href="#字符串定义-初始化" class="headerlink" title="字符串定义 初始化"></a>字符串定义 初始化</h2><ul><li>举例  </li></ul><p>&emsp;&emsp; s1 = ‘string’<br>&emsp;&emsp; s2 = “string2”<br>&emsp;&emsp; s3 = ‘’’this’s a “String” ‘’’<br>&emsp;&emsp; s4 = ‘hello \n herodanny.github.io’<br>&emsp;&emsp; s5 = r”hello \n herodanny.github.io”<br>&emsp;&emsp; s6 = ‘c:\windows\nt’<br>&emsp;&emsp; s7 = R”c:\windows\nt”<br>&emsp;&emsp; s8 = ‘c:\windows\\nt’<br>&emsp;&emsp; sql = “””select * from user where name=’tom’ “””  </p><h2 id="字符串元素访问——下标"><a href="#字符串元素访问——下标" class="headerlink" title="字符串元素访问——下标"></a>字符串元素访问——下标</h2><ul><li>字符串支持使用索引访问  </li></ul><p>&emsp;&emsp; sql = “select * from user where name=’tom’”<br>&emsp;&emsp; sql[4] # 字符串’c’<br>&emsp;&emsp; sql[4] = ‘o’  </p><ul><li><p>有序的字符集合，字符序列<br>&emsp;&emsp; for c in sql:<br>&emsp;&emsp;&emsp; print(c)<br>&emsp;&emsp;&emsp; print(type(c)) # 什么类型？  </p></li><li><p>可迭代  </p></li></ul><p>&emsp;&emsp; lst = list(sql)</p><h2 id="字符串join连接"><a href="#字符串join连接" class="headerlink" title="字符串join连接*"></a>字符串join连接*</h2><ul><li>“string”.join(iterable) -&gt; str<ul><li>将可迭代对象连接起来，使用string作为分隔符</li><li>可迭代对象本身元素都是字符串</li><li>返回一个新字符串</li></ul></li></ul><p>&emsp;&emsp; lst = [‘1’,’2’,’3’]<br>&emsp;&emsp; print(“\””.join(lst)) # 分隔符是双引号<br>&emsp;&emsp; print(“ “.join(lst))<br>&emsp;&emsp; print(“\n”.join(lst))<br>&emsp;&emsp; lst = [‘1’,[‘a’,’b’],’3’] # 复杂结构列表<br>&emsp;&emsp; print(“ “.join(lst))  # TypeError: sequence item 1: expected str instance, list found  </p><h2 id="字符串-连接"><a href="#字符串-连接" class="headerlink" title="字符串+连接"></a>字符串+连接</h2><ul><li>+ -&gt; str<ul><li>将2个字符串连接在一起</li><li>返回一个新字符串</li></ul></li></ul><h2 id="字符串分割"><a href="#字符串分割" class="headerlink" title="字符串分割"></a>字符串分割</h2><ul><li><p>分割字符串的方法分为2类</p><ul><li><p>split系</p><ul><li>将字符串按照分隔符分割成若干字符串，并返回列表</li></ul></li><li><p>partition系</p><ul><li>将字符串按照分隔符分割成2段，返回这2段和分隔符的元组</li></ul></li></ul></li></ul><h2 id="字符串分割-1"><a href="#字符串分割-1" class="headerlink" title="字符串分割*"></a>字符串分割*</h2><ul><li>split(sep=None, maxsplit=-1) -&gt; list of strings<ul><li>从左至右</li><li>sep 指定分割字符串，缺省的情况下空白字符串作为分隔符</li><li>maxsplit 指定分割的次数，-1 表示遍历整个字符串</li></ul></li></ul><p>&emsp;&emsp; s1 = “I’m \ta super student.”<br>&emsp;&emsp; s1.split()<br>&emsp;&emsp; s1.split(‘s’)<br>&emsp;&emsp; s1.split(‘super’)<br>&emsp;&emsp; s1.split(‘super ‘)<br>&emsp;&emsp; s1.split(‘ ‘)<br>&emsp;&emsp; s1.split(‘ ‘,maxsplit=2)<br>&emsp;&emsp; s1.split(‘\t’,maxsplit=2)  </p><h2 id="字符串分割-2"><a href="#字符串分割-2" class="headerlink" title="字符串分割"></a>字符串分割</h2><ul><li>rsplit(sep=None, maxsplit=-1) -&gt; list of strings<ul><li>从右向左</li><li>sep 指定分割字符串，缺省的情况下空白字符串作为分隔符</li><li>maxsplit 指定分割的次数，-1 表示遍历整个字符串</li></ul></li></ul><p>&emsp;&emsp; s1 = “I’m \ta super student.”<br>&emsp;&emsp; s1.rsplit()<br>&emsp;&emsp; s1.rsplit(‘s’)<br>&emsp;&emsp; s1.rsplit(‘super’)<br>&emsp;&emsp; s1.rsplit(‘super ‘)<br>&emsp;&emsp; s1.rsplit(‘ ‘)<br>&emsp;&emsp; s1.rsplit(‘ ‘,maxsplit=2)<br>&emsp;&emsp; s1.rsplit(‘\t’,maxsplit=2)  </p><h2 id="字符串分割-3"><a href="#字符串分割-3" class="headerlink" title="字符串分割"></a>字符串分割</h2><ul><li>splitlines([keepends]) -&gt; list of strings<ul><li>按照行来切分字符串</li><li>keepends 指的是是否保留行分隔符</li><li>行分隔符包括\n、\r\n、\r等</li></ul></li></ul><p>&emsp;&emsp; ‘ab c\n\nde fg\rkl\r\n’.splitlines()<br>&emsp;&emsp; ‘ab c\n\nde fg\rkl\r\n’.splitlines(True)<br>&emsp;&emsp; s1 = ‘’’I’m a super student.<br>&emsp;&emsp; You’re a super teacher.’’’<br>&emsp;&emsp; print(s1)<br>&emsp;&emsp; print(s1.splitlines())<br>&emsp;&emsp; print(s1.splitlines(True))</p><h2 id="字符串分割-4"><a href="#字符串分割-4" class="headerlink" title="字符串分割*"></a>字符串分割*</h2><ul><li>partition(sep) -&gt; (head, sep, tail)<ul><li>从左至右，遇到分隔符就把字符串分割成两部分，返回头、分隔符、尾三部分的三<strong>元组</strong>；如果没有找到分隔符，就返回头、2个空元素的三<strong>元组</strong></li><li>sep 分割字符串，必须指定</li></ul></li></ul><p>&emsp;&emsp; s1 = “I’m a super student.”<br>&emsp;&emsp; s1.partition(‘s’)<br>&emsp;&emsp; s1.partition(‘stu’)<br>&emsp;&emsp; s1.partition(‘’)  # ValueError: empty separator<br>&emsp;&emsp; s1.partition(‘abc’)  </p><ul><li>rpartition(sep) -&gt; (head, sep, tail)<ul><li>从右至左，遇到分隔符就把字符串分割成两部分，返回头、分隔符、尾三部分的三元组；如果没有找到分隔符，就返回2个空元素和尾的三元组</li></ul></li></ul><h2 id="字符串大小写"><a href="#字符串大小写" class="headerlink" title="字符串大小写"></a>字符串大小写</h2><ul><li><p>upper()</p><ul><li>全大写</li></ul></li><li><p>lower()</p><ul><li>全小写</li></ul></li><li><p>大小写，做判断的时候用</p></li><li><p>swapcase()</p><ul><li>交互大小写</li></ul></li></ul><h2 id="字符串排版"><a href="#字符串排版" class="headerlink" title="字符串排版"></a>字符串排版</h2><ul><li>title() -&gt; str<ul><li>标题的每个单词都大写</li></ul></li><li>capitalize() -&gt; str<ul><li>首个单词大写</li></ul></li><li>center(width[, fillchar]) -&gt; str<ul><li>width 打印宽度</li><li>fillchar 填充的字符</li></ul></li><li>zfill(width) -&gt; str<ul><li>width 打印宽度，居右，左边用0填充</li></ul></li><li>ljust(width[, fillchar]) -&gt; str 左对齐</li><li>rjust(width[, fillchar]) -&gt; str 右对齐</li><li>中文用的少，了解一下</li></ul><h2 id="字符串修改"><a href="#字符串修改" class="headerlink" title="字符串修改*"></a>字符串修改*</h2><ul><li>replace(old, new[, count]) -&gt; str<ul><li>字符串中找到匹配替换为新子串，返回新字符串</li><li>count表示替换几次，不指定就是全部替换</li></ul></li></ul><p>&emsp;&emsp; ‘<a href="https://www.cnblogs.com&#39;.replace(&#39;w&#39;,&#39;p&#39;)" target="_blank" rel="noopener">https://www.cnblogs.com&#39;.replace(&#39;w&#39;,&#39;p&#39;)</a><br>&emsp;&emsp; ‘<a href="https://www.cnblogs.com&#39;.replace(&#39;w&#39;,&#39;p&#39;,2)" target="_blank" rel="noopener">https://www.cnblogs.com&#39;.replace(&#39;w&#39;,&#39;p&#39;,2)</a><br>&emsp;&emsp; ‘<a href="https://www.cnblogs.com&#39;.replace(&#39;w&#39;,&#39;p&#39;,3)" target="_blank" rel="noopener">https://www.cnblogs.com&#39;.replace(&#39;w&#39;,&#39;p&#39;,3)</a><br>&emsp;&emsp; ‘<a href="https://www.cnblogs.com&#39;.replace(&#39;ww&#39;,&#39;p&#39;,2)" target="_blank" rel="noopener">https://www.cnblogs.com&#39;.replace(&#39;ww&#39;,&#39;p&#39;,2)</a><br>&emsp;&emsp; ‘<a href="https://www.cnblogs.com&#39;.replace(&#39;www&#39;,&#39;python&#39;,2)" target="_blank" rel="noopener">https://www.cnblogs.com&#39;.replace(&#39;www&#39;,&#39;python&#39;,2)</a>  </p><h2 id="字符串修改-1"><a href="#字符串修改-1" class="headerlink" title="字符串修改*"></a>字符串修改*</h2><ul><li>strip([chars]) -&gt; str<ul><li>从字符串两端去除指定的字符集chars中的所有字符</li><li>如果chars没有指定，去除两端的空白字符</li></ul></li></ul><p>&emsp;&emsp; s = “\r \n \t Hello Python \n \t”<br>&emsp;&emsp; s.strip()<br>&emsp;&emsp; s = “ I am very very very sorry “<br>&emsp;&emsp; s.strip(‘Iy’)<br>&emsp;&emsp; s.strip(‘Iy ‘)  </p><ul><li>lstrip([chars]) -&gt; str  <ul><li>从左开始  </li></ul></li><li>rstrip([chars]) -&gt; str  <ul><li>从右开始  </li></ul></li></ul><h2 id="字符串查找"><a href="#字符串查找" class="headerlink" title="字符串查找*"></a>字符串查找*</h2><ul><li>find(sub[, start[, end]]) -&gt; int<ul><li>在指定的区间[start, end)，从左至右，查找子串sub。找到返回索引，没找到返回-1</li></ul></li><li>rfind(sub[, start[, end]]) -&gt; int<ul><li>在指定的区间[start, end)，从右至左，查找子串sub。找到返回索引，没找到返回-1</li></ul></li></ul><p>&emsp;&emsp; s = “I am very very very sorry”<br>&emsp;&emsp; s.find(‘very’)<br>&emsp;&emsp; s.find(‘very’, 5)<br>&emsp;&emsp; s.find(‘very’, 6, 13)<br>&emsp;&emsp; s.rfind(‘very’, 10)<br>&emsp;&emsp; s.rfind(‘very’, 10, 15)<br>&emsp;&emsp; s.rfind(‘very’,-10,-1)  </p><h2 id="字符串查找-1"><a href="#字符串查找-1" class="headerlink" title="字符串查找*"></a>字符串查找*</h2><p>与 find 的区别就是抛出异常  </p><ul><li>index(sub[, start[, end]]) -&gt; int<ul><li>在指定的区间[start, end)，从左至右，查找子串sub。找到返回索引，没找到抛出异常ValueError</li></ul></li><li>rindex(sub[, start[, end]]) -&gt; int<ul><li>在指定的区间[start, end)，从左至右，查找子串sub。找到返回索引，没找到抛出异常ValueError</li></ul></li></ul><p>&emsp;&emsp; s = “I am very very very sorry”<br>&emsp;&emsp; s.index(‘very’)<br>&emsp;&emsp; s.index(‘very’, 5)<br>&emsp;&emsp; s.index(‘very’, 6, 13)<br>&emsp;&emsp; s.rindex(‘very’, 10)<br>&emsp;&emsp; s.rindex(‘very’, 10, 15)<br>&emsp;&emsp; s.rindex(‘very’,-10,-1)  </p><h2 id="字符串查找-2"><a href="#字符串查找-2" class="headerlink" title="字符串查找"></a>字符串查找</h2><ul><li><p>时间复杂度</p><ul><li>index和count方法都是O(n)</li><li>随着列表数据规模的增大，而效率下降</li></ul></li><li><p>len(string)</p><ul><li>返回字符串的长度，即字符的个数，O(1)</li></ul></li></ul><h2 id="字符串查找-3"><a href="#字符串查找-3" class="headerlink" title="字符串查找"></a>字符串查找</h2><ul><li>count(sub[, start[, end]]) -&gt; int<ul><li>在指定的区间[start, end)，从左至右，统计子串sub出现的次数</li></ul></li></ul><p>&emsp;&emsp; s = “I am very very very sorry”<br>&emsp;&emsp; s.count(‘very’)<br>&emsp;&emsp; s.count(‘very’, 5)<br>&emsp;&emsp; s.count(‘very’, 10, 14)</p><h2 id="字符串判断"><a href="#字符串判断" class="headerlink" title="字符串判断*"></a>字符串判断*</h2><ul><li>endswith(suffix[, start[, end]]) -&gt; bool<ul><li>在指定的区间[start, end)，字符串是否是suffix结尾</li></ul></li><li>startswith(prefix[, start[, end]]) -&gt; bool<ul><li>在指定的区间[start, end)，字符串是否是prefix开头</li></ul></li></ul><p>&emsp;&emsp; s = “I am very very very sorry”<br>&emsp;&emsp; s.startswith(‘very’)<br>&emsp;&emsp; s.startswith(‘very’, 5)<br>&emsp;&emsp; s.startswith(‘very’, 5, 9)<br>&emsp;&emsp; s.endswith(‘very’, 5, 9)<br>&emsp;&emsp; s.endswith(‘sorry’, 5)<br>&emsp;&emsp; s.endswith(‘sorry’, 5, -1)<br>&emsp;&emsp; s.endswith(‘sorry’, 5, 100)  </p><h2 id="字符串判断-is系列"><a href="#字符串判断-is系列" class="headerlink" title="字符串判断 is系列"></a>字符串判断 is系列</h2><ul><li><p>isalnum() -&gt; bool 是否是字母和数字组成</p><ul><li>isalpha() 是否是字母</li></ul></li><li><p>isdecimal() 是否只包含十进制数字</p><ul><li>isdigit() 是否全部数字(0~9)</li></ul></li><li><p>isidentifier() 是不是字母和下划线开头，其他都是字母、数字、下划线</p><ul><li>islower() 是否都是小写</li><li>isupper() 是否全部大写</li><li>isspace() 是否只包含空白字符</li></ul></li></ul><h2 id="字符串格式化"><a href="#字符串格式化" class="headerlink" title="字符串格式化"></a>字符串格式化</h2><ul><li><p>字符串的格式化是一种拼接字符串输出样式的手段，更灵活方便</p><ul><li>join 拼接只能使用分隔符，且要求被拼接的是可迭代对象</li><li>+ 拼接字符串还算方便，但是非字符串需要先转换为字符串才能拼接</li></ul></li><li><p>在2.5版本之前，只能使用printf style风格的print输出</p><ul><li><p>printf-style formatting，来自于C语言的printf函数</p></li><li><p>格式要求</p><ul><li>占位符：使用%和格式字符组成，例如%s、%d等<ul><li>s调用str()，r会调用repr()。所有对象都可以被这两个转换。</li></ul></li><li>占位符中还可以插入修饰字符，例如%03d表示打印3个位置，不够前面补零</li><li>format % values，格式字符串和被格式的值之间使用%分隔</li><li>values只能是一个对象，或是一个和格式字符串占位符数目相等的元组</li></ul></li></ul></li></ul><h2 id="字符串格式化-1"><a href="#字符串格式化-1" class="headerlink" title="字符串格式化"></a>字符串格式化</h2><ul><li>printf-style formatting 举例</li></ul><p>&emsp;&emsp; “I am %03d” % (20,)<br>&emsp;&emsp; ‘I like %s.’ % ‘Python’<br>&emsp;&emsp; ‘%3.2f%% , 0x%x, 0X%02X’ % (89.7654, 10, 15)<br>&emsp;&emsp; “I am %-5d” % (20,)<br>&emsp;&emsp; 3 是显示的最小总宽度，2 是小数点后的位数(如果可用的话)<br>&emsp;&emsp; - 号表示左对齐，默认是有对齐.</p><h2 id="字符串格式化-2"><a href="#字符串格式化-2" class="headerlink" title="字符串格式化***"></a>字符串格式化***</h2><ul><li><p>format函数格式字符串语法——Python鼓励使用</p><ul><li><p>“{} {xxx}”.format(*args, **kwargs) -&gt; str</p></li><li><p>args是位置参数，是一个元组</p></li><li><p>kwargs是关键字参数，是一个字典</p></li><li><p>花括号表示占位符</p></li><li><p>{}表示按照顺序匹配位置参数，{n}表示取位置参数索引为n的值</p></li><li><p>{xxx}表示在关键字参数中搜索名称一致的</p></li><li><p> {{}} 表示打印花括号</p></li></ul></li></ul><h2 id="字符串格式化-3"><a href="#字符串格式化-3" class="headerlink" title="字符串格式化***"></a>字符串格式化***</h2><ul><li><p>位置参数<br>“{}:{}”.format(‘192.168.1.100’,8888)，这就是按照位置顺序用位置参数替换前面的格式字符串的占位符中</p></li><li><p>关键字参数或命名参数<br>“{server} {1}:{0}”.format(8888, ‘192.168.1.100’, server=’Web Server Info : ‘) ，位置参数按照序号匹配，关键字参数按照名词匹配</p></li><li><p>访问元素<br>“{0[0]}.{0[1]}”.format((‘github’,’com’))</p></li><li><p>对象属性访问<br>from collections import namedtuple<br>Point = namedtuple(‘Point’,’x y’)<br>p = Point(4,5)<br>“{{{0.x},{0.y}}}“.format(p)  </p></li><li><p>有了这些字符串格式化方法，字符串拼接可以丢弃了。</p></li></ul><h2 id="字符串格式化-4"><a href="#字符串格式化-4" class="headerlink" title="字符串格式化***"></a>字符串格式化***</h2><ul><li><p>对齐<br>‘{0}*{1}={2:&lt;2}’.format(3,2,2*3)<br>‘{0}*{1}={2:&lt;02}’.format(3,2,2*3)<br>‘{0}*{1}={2:&gt;02}’.format(3,2,2*3)<br>‘{:^30}’.format(‘centered’)<br>‘{:*^30}’.format(‘centered’)  </p></li><li><p>进制<br>“int: {0:d}; hex: {0:x}; oct: {0:o}; bin: {0:b}”.format(42)<br>“int: {0:d}; hex: {0:#x}; oct: {0:#o}; bin: {0:#b}”.format(42)<br>octets = [192, 168, 0, 1]<br>‘{:02X}{:02X}{:02X}{:02X}’.format(<em>octets)<br>\</em> 是参数解构，分解为4个元素  </p></li></ul><h2 id="字符串格式化-5"><a href="#字符串格式化-5" class="headerlink" title="字符串格式化***"></a>字符串格式化***</h2><p><strong>请使用format函数格式化字符串</strong></p><h2 id="字符串练习"><a href="#字符串练习" class="headerlink" title="字符串练习"></a>字符串练习</h2><ul><li>用户输入一个数字<ul><li>判断是几位数</li><li>打印每一位数字及其重复的次数</li><li>依次打印每一位数字，顺序个、十、百、千、万…位</li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">num = <span class="string">""</span> <span class="comment"># 这里不写，下面的num也不会出错，在python作用域是能访问到的，但是不写不好</span></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    num  = input(<span class="string">"Please input a interger: "</span>).strip()</span><br><span class="line">    <span class="keyword">if</span> num.isdigit():</span><br><span class="line">        num = int(num) <span class="comment"># 把前导0也删除，或 lstrip('0')</span></span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        print(<span class="string">"Bad number."</span>)</span><br><span class="line"></span><br><span class="line">count [<span class="number">0</span>] * <span class="number">10</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">    count[i] = num.count(str(i))</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">    <span class="keyword">if</span> count[i]:</span><br><span class="line">        print(i, count[i])</span><br><span class="line">lst = list(num)</span><br><span class="line">lst.reverse()</span><br><span class="line">print(lst)</span><br></pre></td></tr></table></figure><ul><li>输入5个数字，打印每个数字的位数，将这些数字排序打印，要求升序打印<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">lst = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">5</span>):</span><br><span class="line">    m = input(<span class="string">"&gt;&gt;&gt;"</span>).strip().lstrip(<span class="string">"0"</span>)</span><br><span class="line">    print(<span class="string">"这是&#123;&#125;位数"</span>.format(len(m)))</span><br><span class="line"></span><br><span class="line">    lst.append(int(m))</span><br><span class="line"><span class="comment"># print(sorted(lst))</span></span><br><span class="line">lst.sort()</span><br><span class="line">print(lst)</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;第三章-Python-内置数据结构&quot;&gt;&lt;a href=&quot;#第三章-Python-内置数据结构&quot; class=&quot;headerlink&quot; title=&quot;第三章 - Python 内置数据结构&quot;&gt;&lt;/a&gt;第三章 - Python 内置数据结构&lt;/h1&gt;&lt;h2 id=&quot;字
      
    
    </summary>
    
      <category term="python-magedu" scheme="https://herodanny.github.io/categories/python-magedu/"/>
    
    
      <category term="python" scheme="https://herodanny.github.io/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>python全栈-magedu-2018-笔记4</title>
    <link href="https://herodanny.github.io/python-magedu-2018-notes4.html"/>
    <id>https://herodanny.github.io/python-magedu-2018-notes4.html</id>
    <published>2019-04-25T06:04:39.000Z</published>
    <updated>2019-05-10T15:17:00.088Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第三章-Python-内置数据结构"><a href="#第三章-Python-内置数据结构" class="headerlink" title="第三章 - Python 内置数据结构"></a>第三章 - Python 内置数据结构</h1><h2 id="元组tuple"><a href="#元组tuple" class="headerlink" title="元组tuple"></a>元组tuple</h2><ul><li>一个有序的元素组成的集合<ul><li>使用小括号 ( ) 表示</li><li>元组是<strong>不可变</strong>对象</li></ul></li></ul><h2 id="元组的定义-初始化"><a href="#元组的定义-初始化" class="headerlink" title="元组的定义 初始化"></a>元组的定义 初始化</h2><ul><li>定义<ul><li>tuple() -&gt; empty tuple</li><li>tuple(iterable) -&gt; tuple initialized from iterable’s item</li></ul></li></ul><p>&emsp;&emsp; t = tuple() # 工厂方法，空元组是不能插入的<br>&emsp;&emsp; t = ()<br>&emsp;&emsp; t = tuple(range(1,7,2)) # iteratable<br>&emsp;&emsp; t = (2,4,6,3,4,2)<br>&emsp;&emsp; t = (1,) # 一个元素元组的定义，注意有个逗号<br>&emsp;&emsp; t = (1,)*5<br>&emsp;&emsp; t = (1,2,3) * 6<br>&emsp;&emsp; 元组就像个只读列表，好处就是比列表占用空间少。<br>&emsp;&emsp; t1 = (1, [2, 3], 4)<br>&emsp;&emsp; t1[1][0] = 10</p><h2 id="元组元素的访问"><a href="#元组元素的访问" class="headerlink" title="元组元素的访问"></a>元组元素的访问</h2><ul><li>支持索引（下标）</li><li>正索引：从左至右，从0开始，为列表中每一个元素编号</li><li>负索引：从右至左，从-1开始</li><li><p>正负索引不可以超界，否则引发异常IndexError</p></li><li><p>元组通过索引访问</p><ul><li>tuple[index] ，index就是索引，使用中括号访问</li></ul></li></ul><p>&emsp;&emsp; t[1]<br>&emsp;&emsp; t[-2]<br>&emsp;&emsp; t[1] = 5  </p><h2 id="元组查询"><a href="#元组查询" class="headerlink" title="元组查询"></a>元组查询</h2><ul><li><p>index(value,[start,[stop]])</p><ul><li>通过值value，从指定区间查找列表内的元素是否匹配</li><li>匹配第一个就立即返回索引</li><li>匹配不到，抛出异常ValueError</li></ul></li><li><p>count(value)</p><ul><li>返回列表中匹配value的次数</li></ul></li><li><p>时间复杂度</p><ul><li>index和count方法都是O(n)</li><li>随着列表数据规模的增大，而效率下降</li></ul></li><li><p>len(tuple)</p><ul><li>返回元素的个数</li></ul></li></ul><h2 id="元组其它操作"><a href="#元组其它操作" class="headerlink" title="元组其它操作"></a>元组其它操作</h2><ul><li>元组是只读的，所以增、改、删方法都没有</li></ul><h2 id="命名元组namedtuple"><a href="#命名元组namedtuple" class="headerlink" title="命名元组namedtuple"></a>命名元组namedtuple</h2><ul><li>帮助文档中，查阅namedtuple，有使用例程</li><li>namedtuple(typename, field_names, verbose=False, rename=False)<ul><li>命名元组，返回一个元组的子类，并定义了字段</li><li>field_names可以是空白符或逗号分割的字段的字符串，可以是字段的列表</li></ul></li></ul><p>&emsp;&emsp; from collections import namedtuple<br>&emsp;&emsp; Point = namedtuple(‘_Point’,[‘x’,’y’]) # Point为返回的类<br>&emsp;&emsp; p = Point(11, 22)  </p><p>&emsp;&emsp; Student = namedtuple(‘Student’, ‘name age’)<br>&emsp;&emsp; tom = Student(‘tom’, 20)<br>&emsp;&emsp; jerry = Student(‘jerry’, 18)<br>&emsp;&emsp; tom.name  </p><h2 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h2><ul><li>依次接收用户输入的3个数，排序后打印<ul><li><ol><li>转换int后，判断大小排序。使用分支结构完成</li></ol></li><li><ol start="2"><li>使用max函数</li></ol></li><li><ol start="3"><li>使用列表的sort方法</li></ol></li><li><ol start="4"><li>冒泡法</li></ol></li></ul></li></ul><h2 id="冒泡法"><a href="#冒泡法" class="headerlink" title="冒泡法"></a>冒泡法</h2><ul><li><p>冒泡法</p><ul><li>属于交换排序</li><li>两两比较大小，交换位置。如同水泡咕嘟咕嘟往上冒</li><li>结果分为升序和降序排列</li></ul></li><li><p>升序</p><ul><li>n个数从左至右，编号从0开始到n-1，索引0和1的值比较，如果索引0大，则交换两者位置，如果索引1大，则不交换。继续比较索引1和2的值，将大值放在右侧。直至n-2和n-1比较完，第一轮比较完成。第二轮从索引0比较到n-2，因为最右侧n-1位置上已经是最大值了。依次类推，每一轮都会减少最右侧的不参与比较，直至剩下最后2个数比较。</li></ul></li><li><p>降序</p><ul><li>和升序相反</li></ul></li></ul><h2 id="冒泡法-1"><a href="#冒泡法-1" class="headerlink" title="冒泡法"></a>冒泡法</h2><p><img src="https://raw.githubusercontent.com/herodanny/Image-Hosting/master/data/maopaopaixu1.jpg" alt="maopaopaixu1"><br><img src="https://raw.githubusercontent.com/herodanny/Image-Hosting/master/data/maopaopaixu2.jpg" alt="maopaopaixu2">  </p><h2 id="冒泡法代码实现（一）"><a href="#冒泡法代码实现（一）" class="headerlink" title="冒泡法代码实现（一）"></a>冒泡法代码实现（一）</h2><ul><li>简单冒泡实现  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">num_list = [</span><br><span class="line">    [<span class="number">1</span>, <span class="number">9</span>, <span class="number">8</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">4</span>, <span class="number">3</span> ,<span class="number">2</span>],</span><br><span class="line">    [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">9</span>, <span class="number">8</span>]</span><br><span class="line">]</span><br><span class="line">nums = num_list[<span class="number">1</span>]</span><br><span class="line">print(nums)</span><br><span class="line">length = len(nums)</span><br><span class="line">count_swap = <span class="number">0</span></span><br><span class="line">count = <span class="number">0</span></span><br><span class="line"><span class="comment"># bubble_sort</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(length<span class="number">-1</span>):  <span class="comment"># 要比较n-1趟</span></span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> range(length-i<span class="number">-1</span>):  <span class="comment"># 每趟要比较的次数</span></span><br><span class="line">        count += <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> nums[j] &gt; nums[j+<span class="number">1</span>]:</span><br><span class="line">            tmp = nums[j]</span><br><span class="line">            nums[j] = nums[j+<span class="number">1</span>]</span><br><span class="line">            nums[j+<span class="number">1</span>] = tmp</span><br><span class="line">            count_swap += <span class="number">1</span></span><br><span class="line">print(nums, count_swap, count)</span><br></pre></td></tr></table></figure></li></ul><h2 id="冒泡法代码实现（二）"><a href="#冒泡法代码实现（二）" class="headerlink" title="冒泡法代码实现（二）"></a>冒泡法代码实现（二）</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">num_list = [</span><br><span class="line">            [<span class="number">1</span>, <span class="number">9</span>, <span class="number">8</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">4</span>, <span class="number">3</span> ,<span class="number">2</span>],</span><br><span class="line">            [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>],</span><br><span class="line">            [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">9</span>, <span class="number">8</span>]</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">nums = num_list[<span class="number">2</span>]</span><br><span class="line">print(nums)</span><br><span class="line">length = len(nums)</span><br><span class="line">count_swap = <span class="number">0</span></span><br><span class="line">count = <span class="number">0</span></span><br><span class="line"><span class="comment"># bubble_sort</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(length<span class="number">-1</span>):  <span class="comment"># 要比较n-1趟</span></span><br><span class="line">    flag = <span class="literal">False</span></span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> range(length-i<span class="number">-1</span>):  <span class="comment"># 每趟要比较的次数</span></span><br><span class="line">        count += <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> nums[j] &gt; nums[j+<span class="number">1</span>]:</span><br><span class="line">            tmp = nums[j]</span><br><span class="line">            nums[j] = nums[j+<span class="number">1</span>]</span><br><span class="line">            nums[j+<span class="number">1</span>] = tmp</span><br><span class="line">            flag = <span class="literal">True</span> <span class="comment"># swapped</span></span><br><span class="line">            count_swap += <span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> flag:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">print(nums, count_swap, count)</span><br></pre></td></tr></table></figure><h2 id="冒泡法总结"><a href="#冒泡法总结" class="headerlink" title="冒泡法总结"></a>冒泡法总结</h2><ul><li>冒泡法需要数据一轮轮比较</li><li>可以设定一个标记判断此轮是否有数据交换发生，如果没有发生交换，可以结束排序，如果发生交换，继续下一轮排序</li><li>最差的排序情况是，初始顺序与目标顺序完全相反，遍历次数1,…,n-1之和n(n-1)/2</li><li>最好的排序情况是，初始顺序与目标顺序完全相同，遍历次数n-1</li><li>时间复杂度O(n2)</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;第三章-Python-内置数据结构&quot;&gt;&lt;a href=&quot;#第三章-Python-内置数据结构&quot; class=&quot;headerlink&quot; title=&quot;第三章 - Python 内置数据结构&quot;&gt;&lt;/a&gt;第三章 - Python 内置数据结构&lt;/h1&gt;&lt;h2 id=&quot;元
      
    
    </summary>
    
      <category term="python-magedu" scheme="https://herodanny.github.io/categories/python-magedu/"/>
    
    
      <category term="python" scheme="https://herodanny.github.io/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>python全栈-magedu-2018-笔记3</title>
    <link href="https://herodanny.github.io/python-magedu-2018-notes3.html"/>
    <id>https://herodanny.github.io/python-magedu-2018-notes3.html</id>
    <published>2019-04-24T13:00:30.000Z</published>
    <updated>2019-05-11T03:46:33.162Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第三章-Python-内置数据结构"><a href="#第三章-Python-内置数据结构" class="headerlink" title="第三章 - Python 内置数据结构"></a>第三章 - Python 内置数据结构</h1><h2 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h2><ul><li><p>数值型</p><ul><li>int、float、complex、bool  </li></ul></li><li><p>序列对象</p><ul><li>字符串 str</li><li>列表 list</li><li>tuple</li></ul></li><li><p>键值对</p><ul><li>集合set</li><li>字典dict</li></ul></li></ul><h2 id="数值型"><a href="#数值型" class="headerlink" title="数值型"></a>数值型</h2><ul><li><p>数值型</p><ul><li>int、float、complex、bool都是class，1、5.0、2+3j都是对象即实例</li><li>int：python3的int就是长整型，且没有大小限制，受限于内存区域的大小</li><li>float：有整数部分和小数部分组成。支持十进制和科学计数法表示。只有双精度型。</li><li>complex：有实数和虚数部分组成，实数和虚数部分都是浮点数，3+4.2J</li><li>bool：int的子类，仅有2个实例True、False对应1和0，可以和整数直接运算</li></ul></li><li><p>类型转换（built-in）</p><ul><li>int(x) 返回一个整数 ，int是与类型名相同的内置转换函数，如果字符串不合法抛出异常</li><li>float(x) 返回一个浮点数</li><li>complex(x)、complex(x,y) 返回一个复数</li><li>bool(x) 返回布尔值，前面讲过False等价的对象</li></ul></li></ul><h2 id="数字的处理函数"><a href="#数字的处理函数" class="headerlink" title="数字的处理函数"></a>数字的处理函数</h2><ul><li>round()，四舍五入？六入四舍五取偶</li><li>math模块、floor()地板、天花板ceil()</li><li>int() 、//</li><li>举例：<br>&emsp; import math<br>&emsp; print(math.floor(2.5), math.floor(-2.5))<br>&emsp; print(math.ceil(2.5), math.ceil(-2.5))  </li></ul><p>&emsp; 以下打印什么结果？说明什么<br>&emsp; print(int(-3.6), int(-2.5), int(-1.4))<br>&emsp; print(int(3.6), int(2.5), int(1.4))<br>&emsp; print(7//2, 7//-2, -7//2, -(7//2))<br>&emsp; print(2//3, -2//3, -1//3)<br>&emsp; print(round(2.5), round(2.5001), round(2.6))<br>&emsp; print(round(3.5), round(3.5001), round(3.6), round(3.3))<br>&emsp; print(round(-2.5), round(-2.5001), round(-2.6))<br>&emsp; print(round(-3.5), round(-3.5001), round(-3.6), round(-3.3))  </p><ul><li>round()，四舍六入五取偶</li><li>floor()向下取整、ceil()向上取整</li><li>int() 取整数部分</li><li><p>// 整除且向下取整</p></li><li><p>min()</p></li><li>max()</li><li>pow(x,y) 等于 x**y</li><li><p>math.sqrt()</p></li><li><p>进制函数，返回值是字符串</p><ul><li>bin()</li><li>oct()</li><li>hex()</li></ul></li><li><p>math.pi π</p></li><li>math.e 自如常数</li></ul><h2 id="类型判断"><a href="#类型判断" class="headerlink" title="类型判断"></a>类型判断</h2><ul><li>type(obj) ，返回类型，而不是字符串  </li><li>isinstance(obj, class_or_tuple)，返回布尔值  </li><li><p>举例：  </p><ul><li>type(a)</li><li>type(‘abc’)</li><li>type(123)</li><li>isinstance(6, str)、type(6) == str</li><li>isinstance(6, (str, bool, int))</li></ul></li><li><p>type(1+True)  # bool型是int的子类</p></li><li>type(1+True+2.0) # 是什么？隐式转换 # 都是数值类型，往高精度转</li></ul><h2 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h2><ul><li>一个队列，一个排列整齐的队伍</li><li>列表内的个体称作元素，由若干元素组成列表</li><li>元素可以是任意对象（数字、字符串、对象、列表等）</li><li>列表内元素有顺序，可以使用索引</li><li>线性的数据结构</li><li>使用 [ ] 表示</li><li>列表是<strong>可变</strong>的</li><li>列表list、链表、queue、stack的差异</li></ul><h2 id="列表list定义-初始化"><a href="#列表list定义-初始化" class="headerlink" title="列表list定义 初始化"></a>列表list定义 初始化</h2><p>赋值即定义，这也是静态语言和动态语言的区别。  </p><ul><li>list() -&gt; new empty list</li><li>list(iterable) -&gt; new list initialized from iterable’s items</li><li>列表不能一开始就定义大小</li></ul><p>&emsp;&emsp; lst = list()<br>&emsp;&emsp; lst = []<br>&emsp;&emsp; lst = [2, 6, 9, ‘ab’]<br>&emsp;&emsp; lst = list(range(5))  </p><h2 id="列表索引访问"><a href="#列表索引访问" class="headerlink" title="列表索引访问"></a>列表索引访问</h2><ul><li>索引，也叫下标</li><li>正索引：从左至右，从0开始，为列表中每一个元素编号</li><li>负索引：从右至左，从-1开始</li><li>正负索引不可以超界，否则引发异常IndexError</li><li>为了理解方便，可以认为列表是从左至右排列的，左边是头部，右边是尾部，左边是下界，右边是上界</li><li>列表通过索引访问<ul><li>list[index] ，index就是索引，使用中括号访问</li></ul></li></ul><h2 id="列表查询"><a href="#列表查询" class="headerlink" title="列表查询"></a>列表查询</h2><ul><li><p>index(value,[start,[stop]])</p><ul><li>通过值value，从指定区间查找列表内的元素是否匹配</li><li>匹配第一个就立即返回索引</li><li>匹配不到，抛出异常ValueError</li></ul></li><li><p>count(value)</p><ul><li>返回列表中匹配value的次数</li></ul></li><li><p>时间复杂度</p><ul><li>index和count方法都是O(n)</li><li>随着列表数据规模的增大，而效率下降</li></ul></li><li><p>如何返回列表元素的个数？如何遍历？如何设计高效？</p><ul><li>len() # 是序列共有的函数，不是list类的方法函数</li></ul></li></ul><h2 id="如何查帮助"><a href="#如何查帮助" class="headerlink" title="如何查帮助"></a>如何查帮助</h2><ul><li><p>官方帮助文档</p><ul><li>搜索关键字</li></ul></li><li><p>IPython中</p><ul><li>help(keyword)</li><li>keyword可以是变量、对象、类名、函数名、方法名</li></ul></li></ul><h2 id="列表元素修改"><a href="#列表元素修改" class="headerlink" title="列表元素修改"></a>列表元素修改</h2><ul><li>索引访问修改<ul><li>list[index] = value</li><li>索引不要超界</li></ul></li></ul><h2 id="列表增加、插入元素"><a href="#列表增加、插入元素" class="headerlink" title="列表增加、插入元素"></a>列表增加、插入元素</h2><ul><li><p>append(object) -&gt; None</p><ul><li>列表尾部追加元素，返回None</li><li>返回None就意味着没有新的列表产生，就地修改</li><li>时间复杂度是O(1)，因为直接可以索引到结尾添加</li></ul></li><li><p>insert(index, object) -&gt; None</p><ul><li>在指定的索引index处插入元素object</li><li>返回None就意味着没有新的列表产生，就地修改</li><li>时间复杂度是O(n)，因为会调整内存布局</li><li>索引能超上下界吗？</li><li>超越上界，尾部追加</li><li>超越下界，头部追加</li></ul></li></ul><h2 id="列表增加、插入元素-1"><a href="#列表增加、插入元素-1" class="headerlink" title="列表增加、插入元素"></a>列表增加、插入元素</h2><ul><li><p>extend(iteratable) -&gt; None</p><ul><li>将可迭代对象的元素追加进来，返回None</li><li>就地修改</li></ul></li><li><p>+ -&gt; list</p><ul><li>连接操作，将两个列表连接起来</li><li>产生新的列表，原列表不变</li><li>本质上调用的是<strong>add</strong>()方法</li></ul></li><li><p>* -&gt; list</p><ul><li>重复操作，将本列表元素重复n次，返回新的列表</li></ul></li></ul><h2 id="列表-重复的坑"><a href="#列表-重复的坑" class="headerlink" title="列表 *重复的坑"></a>列表 *重复的坑</h2><ul><li>* -&gt; list  <ul><li>重复操作，将本列表元素重复n次，返回新的列表  </li></ul></li></ul><p>&emsp;&emsp; x = [[1,2,3]]*3<br>&emsp;&emsp; print(x)<br>&emsp;&emsp; x[0][1] = 20<br>&emsp;&emsp; print(x)  </p><p>&emsp;&emsp; y = [1]*5<br>&emsp;&emsp; y[0] = 6<br>&emsp;&emsp; y[1] = 7<br>&emsp;&emsp; print(y)<br>&emsp;&emsp; 上面代码运行结果是什么？为什么？</p><h2 id="列表删除元素"><a href="#列表删除元素" class="headerlink" title="列表删除元素"></a>列表删除元素</h2><ul><li><p>remove(value) -&gt; None</p><ul><li>从左至右查找第一个匹配value的值，移除该元素，返回None</li><li>就地修改</li><li>效率？</li></ul></li><li><p>pop([index]) -&gt; item</p><ul><li>不指定索引index，就从列表尾部弹出一个元素</li><li>指定索引index，就从索引处弹出一个元素，索引超界抛出IndexError错误</li><li>效率？指定索引的的时间复杂度？不指定索引呢？</li></ul></li><li><p>clear() -&gt; None</p><ul><li>清除列表所有元素，剩下一个空列表（一批元素不要，可能会引起垃圾回收gc）</li></ul></li></ul><h2 id="列表其它操作"><a href="#列表其它操作" class="headerlink" title="列表其它操作"></a>列表其它操作</h2><ul><li><p>reverse() -&gt; None</p><ul><li>将列表元素<strong>反转</strong>，返回None</li><li>就地修改</li></ul></li><li><p>sort(key=None, reverse=False) -&gt; None</p><ul><li>只写一个参数，匹配的是第一个参数，要匹配第二个参数，要指明参数名字，这么写 lst.sort(reverse=True) </li><li>对列表元素进行<strong>排序</strong>，就地修改，默认升序</li><li>reverse为True，反转，降序</li><li>key一个函数，指定key如何排序<ul><li>lst.sort(key=functionname)</li></ul></li></ul></li><li><p>in</p><ul><li>[3,4] in [1, 2, [3,4]]</li><li>for x in [1,2,3,4]</li></ul></li><li><p>not in</p></li></ul><h2 id="列表复制"><a href="#列表复制" class="headerlink" title="列表复制"></a>列表复制</h2><ul><li>先看一段代码  </li></ul><p>&emsp;&emsp; lst0 = list(range(4))<br>&emsp;&emsp; lst2 = list(range(4))<br>&emsp;&emsp; print(lst0 == lst2)<br>&emsp;&emsp; lst1 = lst0<br>&emsp;&emsp; lst1[2] = 10<br>&emsp;&emsp; print(lst0)  </p><p>&emsp;&emsp; lst0 == lst2相等吗？为什么？lst0里面存的是什么？<br>&emsp;&emsp; == 比较的是对象的内容 (True)<br>&emsp;&emsp; is 比较的是对象的地址 (False) 即 id(lst0) == id(lst2)<br>&emsp;&emsp; 这里虽然都是创建 list(range(4)) 这个对象，解释器并没有优化为只创建一个  </p><p>&emsp;&emsp; 请问lst0的索引为2的元素的值是什么？<br>&emsp;&emsp; 请问lst1 = lst0这个过程中有没有复制过程？  </p><h2 id="列表复制-1"><a href="#列表复制-1" class="headerlink" title="列表复制"></a>列表复制</h2><ul><li>copy() -&gt; List<ul><li>shadow copy返回一个新的列表</li></ul></li></ul><p>&emsp;&emsp; lst0 = list(range(4))<br>&emsp;&emsp; lst5 = lst0.copy()<br>&emsp;&emsp; id(lst0) 和 id(lst5) 是不同的 ，与 lst5=lst0 还是不一样的<br>&emsp;&emsp; copy是把原列表的item复制到一个片新内存，创建一个新列表<br>&emsp;&emsp; print(lst5 == lst0)<br>&emsp;&emsp; lst5[2] = 10<br>&emsp;&emsp; print(lst5 == lst0)<br>&emsp;&emsp; lst0和lst5一样吗？  </p><ul><li>对比前面程序的差别  </li></ul><p>&emsp;&emsp; lst0 = [1, [2, 3, 4], 5]<br>&emsp;&emsp; lst5 = lst0.copy()<br>&emsp;&emsp; lst5 == lst0<br>&emsp;&emsp; lst5[2] = 10<br>&emsp;&emsp; lst5 == lst0<br>&emsp;&emsp; lst5[2] = 5<br>&emsp;&emsp; lst5[1][1] = 20<br>&emsp;&emsp; lst5 == lst0<br>&emsp;&emsp; list中间元素是个复杂元素，所以copy时只拷贝了它的引用，即它的地址。所以在一边修改之后，另一边也一同修改了。  </p><h2 id="列表复制-2"><a href="#列表复制-2" class="headerlink" title="列表复制"></a>列表复制</h2><ul><li><p>shadow copy</p><ul><li>影子拷贝，也叫浅拷贝，遇到引用类型，只是复制了一个引用而已</li></ul></li><li><p>深拷贝</p><ul><li>copy模块提供了deepcopy  </li></ul></li></ul><p>&emsp;&emsp;&emsp;&emsp; import copy<br>&emsp;&emsp;&emsp;&emsp; lst0 = [1, [2, 3, 4], 5]<br>&emsp;&emsp;&emsp;&emsp; lst5 = copy.deepcopy(lst0)<br>&emsp;&emsp;&emsp;&emsp; lst5[1][1] = 20<br>&emsp;&emsp;&emsp;&emsp; lst5 == lst0  </p><h2 id="随机数"><a href="#随机数" class="headerlink" title="随机数"></a>随机数</h2><ul><li>random模块</li><li>randint(a, b) 返回[a, b]之间的整数</li><li>choice(seq) 从非空序列的元素中随机挑选一个元素，比如random.choice(range(10))，从0到9中随机挑选一个整数。random.choice([1,3,5,7])</li><li>randrange ([start,] stop [,step]) 从指定范围内，按指定基数递增的集合中获取一个随机数，基数缺省值为1。 random.randrange(1,7,2)</li><li>random.shuffle(list) -&gt;None 就地打乱列表元素</li><li>sample(population, k) 从样本空间或总体（序列或者集合类型）中随机取出k个不同的元素，返回一个新的列表<ul><li>random.sample([‘a’, ‘b’, ‘c’, ‘d’], 2)</li><li>random.sample([‘a’, ‘a’], 2) 会返回什么结果</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;第三章-Python-内置数据结构&quot;&gt;&lt;a href=&quot;#第三章-Python-内置数据结构&quot; class=&quot;headerlink&quot; title=&quot;第三章 - Python 内置数据结构&quot;&gt;&lt;/a&gt;第三章 - Python 内置数据结构&lt;/h1&gt;&lt;h2 id=&quot;分
      
    
    </summary>
    
      <category term="python-magedu" scheme="https://herodanny.github.io/categories/python-magedu/"/>
    
    
      <category term="python" scheme="https://herodanny.github.io/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>python全栈-magedu-2018-笔记2</title>
    <link href="https://herodanny.github.io/python-magedu-2018-notes2.html"/>
    <id>https://herodanny.github.io/python-magedu-2018-notes2.html</id>
    <published>2019-04-20T15:48:58.000Z</published>
    <updated>2019-04-25T07:32:01.809Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第二章-Python-基础语法"><a href="#第二章-Python-基础语法" class="headerlink" title="第二章 - Python 基础语法"></a>第二章 - Python 基础语法</h1><h2 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h2><ul><li><p>注释 —— # 标注的文本</p></li><li><p>数字</p><ul><li>整数，不区分long和int<ul><li>进制0xa、0o10、0b10</li><li>bool，2个值True、False</li></ul></li><li>浮点数<ul><li>1.2、3.1415、-0.12，1.46e9等价于1.46*109</li></ul></li><li>复数，1+2j</li></ul></li><li><p>字符串</p><ul><li>使用 ‘ “ 单双引号引用的字符的序列</li><li>‘’’和””” 单双三引号，可以跨行、可以在其中自由的使用单双引号</li><li>在字符串前面加上r或者R前缀，表示该字符串不做特殊的处理</li></ul></li><li><p>转义序列</p><ul><li><code>\\ \t \r \n \&#39; \&quot;</code></li><li>前缀r，把里面的所有字符当普通字符对待</li></ul></li><li><p>缩进</p><ul><li>未使用C等语言的花括号，而是采用缩进的方式表示层次关系</li><li>约定使用4个空格缩进</li></ul></li><li><p>续行</p><ul><li>在行尾使用 \</li><li>如果使用各种括号，认为括号内是一个整体，内部跨行不用 \</li></ul></li><li><p>标识符</p><ol><li>一个名字，用来指代一个值</li><li>只能字母、下划线和数字</li><li>只能以字母或下划线开头</li><li>不能是python的关键字，例如def、class就不能作为标识符</li><li>Python是大小写敏感的</li></ol></li><li><p>约定：  </p><ul><li>不允许使用中文  </li><li>不允许使用歧义单词，例如class_  </li><li>在python中不要随便使用下划线开头的表示符  </li></ul></li><li><p>常量</p><ul><li>一旦赋值就不能改变值的标识符</li><li>python中无法定义常量</li></ul></li><li><p>字面常量</p><ul><li>一个单独的量，例如 12、”abc” 、’2341356514.03e-9’</li></ul></li><li><p>变量</p><ul><li>赋值后，可以改变值的标识符</li></ul></li></ul><h2 id="Python的语言类型"><a href="#Python的语言类型" class="headerlink" title="Python的语言类型"></a>Python的语言类型</h2><ul><li><p>Python是动态语言、强类型语言</p></li><li><p>静态编译语言</p><ul><li>实现声明变量类型，类型不能再改变</li><li>编译时检查</li></ul></li><li><p>动态编译语言</p><ul><li>不用事先声明类型，随时可以赋值为其他类型</li><li>编程时不知道是什么类型，很难推断</li></ul></li><li><p>强类型语言</p><ul><li>不同类型之间操作，必须先强制类型转换为同一类型。print(‘a’+1)</li></ul></li><li><p>弱类型语言</p><ul><li>不同类型间可以操作，自动隐式转换，JavaScript中console.log(1+’a’)</li></ul></li></ul><h2 id="运算符-Operator"><a href="#运算符-Operator" class="headerlink" title="运算符 Operator"></a>运算符 Operator</h2><ul><li><p>算数运算符</p><ul><li>+ - * / % **</li><li>自然除/结果是浮点数，整除//。注：2.x中/和//都是整除</li></ul></li><li><p>位运算符</p><ul><li>&amp; | ~ ^ &lt;&lt; &gt;&gt;</li><li>常用方式：乘除2的倍数，32 // 4相当于 32 &gt;&gt; 2</li><li>12，0xc，0o14，0b1100<ul><li>~12等于多少，为什么</li></ul></li></ul></li></ul><h2 id="原码、反码、补码，负数表示法"><a href="#原码、反码、补码，负数表示法" class="headerlink" title="原码、反码、补码，负数表示法"></a>原码、反码、补码，负数表示法</h2><ul><li><p>原码</p><ul><li>5 =&gt; 0b101，1 =&gt; 0b1 ，-1 =&gt; -0b1， bin(-1)</li></ul></li><li><p>反码</p><ul><li>正数的反码与原码相同；负数的反码符号位不变其余按位取反</li></ul></li><li><p>补码</p><ul><li>正数的补码与原码相同；负数的补码符号位不变其余按位取反后+1<br>有符号数才用补码表示</li></ul></li><li><p>负数表示法</p><ul><li>数字电路的CPU中的运算器实现了加法器，但是没有减法器，减法是转换成加法</li><li>负数在计算机中使用补码存储，-1的补码为1111 1111</li><li>5-1 =&gt; 5+(-1)直觉上是0b101-0b1，其实计算机中是0b101+0b11111111，溢出位舍弃</li><li>~12为什么是-13？</li><li>10^9 等于？ 10^-9等于？为什么</li></ul></li></ul><p>&#160;&#160;&#160;&#160;  5 的补码 0000 0101<br>&#160;&#160;&#160;&#160;  -1 的原码 1000 0001<br>&#160;&#160;&#160;&#160;  -1 的补码 1111 1111  (0xff)<br>&#160;&#160;&#160;&#160;  5-1得 0000 0100</p><p>&#160;&#160;&#160;&#160; 12 的补码  0000 1100<br>&#160;&#160;&#160;&#160; ~12 是 1111 0011<br>&#160;&#160;&#160;&#160; 怎么从补码得到原码？<br>&#160;&#160;&#160;&#160; 与得到补码是一样的，最高位不变，其他位取反加一，即补码的补码就是原码<br>&#160;&#160;&#160;&#160; 1000 1101 (即-13)</p><ul><li><p>比较运算符</p><ul><li>== != &gt; &lt; &gt;= &lt;=</li><li>返回一个bool值</li><li>1 &lt; ‘1’ &#160; 报错 &#160;&#160;&#160;&#160;&#160; 1 == ‘1’ &#160; False</li><li>== 是可以不同类型比较的，除非 大于、小于等做类型重载，不然是不能比较的</li><li>链式比较操作符<ul><li>4&gt;3&gt;2  &#160;&#160;&#160;&#160;&#160;  4&gt;mynumber&gt;=1</li></ul></li></ul></li><li><p>逻辑运算符</p><ul><li>与或非 and or not</li><li>短路运算符<ul><li>and 如果第一个表达式为False，后面就没有必要计算了，这个逻辑表达式一定是False</li><li>or 如果第一个表达式True，后面没有必要计算了，这个逻辑表达式一定是True</li></ul></li></ul></li><li><p>赋值运算符</p><ul><li>a = min(3,5)</li><li>+= -= *= /= %= 等</li><li>x = y = z = 10<ul><li>尽量少用连等，因为如果右边是个引用就麻烦了</li></ul></li></ul></li><li><p>成员运算符</p><ul><li>in、not in</li></ul></li><li><p>身份运算符</p><ul><li>is 、is not</li></ul></li></ul><h2 id="运算符优先级（由高到低）"><a href="#运算符优先级（由高到低）" class="headerlink" title="运算符优先级（由高到低）"></a>运算符优先级（由高到低）</h2><table><thead><tr><th style="text-align:left">运算符</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left">‘expr’</td><td style="text-align:left">字符串转换</td></tr><tr><td style="text-align:left">{key:expr}</td><td style="text-align:left">字典</td></tr><tr><td style="text-align:left">[expr1, expr2, …]</td><td style="text-align:left">列表</td></tr><tr><td style="text-align:left">(expr1, expr2, …)</td><td style="text-align:left">元组</td></tr><tr><td style="text-align:left">function(expr, …)</td><td style="text-align:left">函数调用</td></tr><tr><td style="text-align:left">x[index:index]</td><td style="text-align:left">切片</td></tr><tr><td style="text-align:left">x[index]</td><td style="text-align:left">下标索引值</td></tr><tr><td style="text-align:left">x.attribute</td><td style="text-align:left">属性引用</td></tr><tr><td style="text-align:left">~x</td><td style="text-align:left">按位取反</td></tr><tr><td style="text-align:left">+x, -x</td><td style="text-align:left">正，负</td></tr><tr><td style="text-align:left">x ** y</td><td style="text-align:left">幂</td></tr><tr><td style="text-align:left">x * y,  x / y,  x % y</td><td style="text-align:left">乘法,除,取模</td></tr><tr><td style="text-align:left">x + y, x - y</td><td style="text-align:left">加，减</td></tr><tr><td style="text-align:left">x &lt;&lt; y, x &gt;&gt; y</td><td style="text-align:left">移位</td></tr><tr><td style="text-align:left">x &amp; y</td><td style="text-align:left">按位与</td></tr><tr><td style="text-align:left">x ^ y</td><td style="text-align:left">按位异或</td></tr><tr><td style="text-align:left">x \</td><td style="text-align:left">y</td><td>按位或</td></tr><tr><td style="text-align:left">x &lt; y, x &lt;= y , x == y, x != y, x &gt;= y, x &gt; y</td><td style="text-align:left">比较</td></tr><tr><td style="text-align:left">x is y , x is not y</td><td style="text-align:left">等同测试</td></tr><tr><td style="text-align:left">x in y, x not in y</td><td style="text-align:left">成员测试</td></tr><tr><td style="text-align:left">not x</td><td style="text-align:left">逻辑否</td></tr><tr><td style="text-align:left">x and y</td><td style="text-align:left">逻辑与</td></tr><tr><td style="text-align:left">x or y</td><td style="text-align:left">逻辑或</td></tr><tr><td style="text-align:left">lambda arg, … : expr</td><td style="text-align:left">Lambda 匿名函数</td></tr></tbody></table><ul><li><p>算数运算符 &gt; 位运算符 &gt; 身份运算符 &gt; 成员运算符 &gt; 逻辑运算符 &gt; 赋值运算符</p><ul><li>位运算符也可以看成算术运算</li></ul></li><li><p>记不住，用括号</p></li><li><p>长表达式，多用括号，易懂、易读</p></li></ul><h2 id="表达式-Expression"><a href="#表达式-Expression" class="headerlink" title="表达式 Expression"></a>表达式 Expression</h2><ul><li>由数字、符号、括号、变量等的组合<ul><li>算数表达式</li><li>逻辑表达式</li><li>赋值表达式<ul><li>Python中，赋值即定义，如果一个变量已经定义，赋值相当于重新定义</li></ul></li></ul></li></ul><h2 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h2><ul><li><p>变量无须事先声明，也不需要指定类型</p><ul><li>动态语言的特性</li></ul></li><li><p>编程中一般无须关心变量的存亡，也不用关心内存的管理</p></li><li><p>python使用引用计数记录所有对象的引用数</p><ul><li>当对象引用数变为0，它就可以被 垃圾回收GC</li><li>计数增加：<ul><li>赋值给其它变量就增加引用计数，例如x=3;y=x</li></ul></li><li>计数减少：<ul><li>函数运行结束时，局部变量就会被自动销毁，对象引用计数减少</li><li>变量被赋值给其它对象。例如x=3;y=x;x=4</li></ul></li></ul></li><li><p>有关性能的时候，就需要考虑变量的引用问题，但是该释放内存，还是尽量不释放内存，看需求</p></li></ul><h2 id="程序控制"><a href="#程序控制" class="headerlink" title="程序控制"></a>程序控制</h2><ul><li><p>顺序</p><ul><li>按照先后顺序一条条执行</li><li>例如，先洗手，再吃饭，再洗碗</li></ul></li><li><p>分支</p><ul><li>根据不同的情况判断，条件满足执行某条件下的语句</li><li>例如，先洗手，如果饭没有做好，玩游戏，如果饭做好了，就吃饭，如果饭都没有做，叫外卖</li></ul></li><li><p>循环</p><ul><li>条件满足就反复执行，不满足就不执行或不再执行</li><li>例如，先洗手，看饭好了没有，没有好，一会来看一次是否好了，一会儿来看一次，直到饭好了，才可是吃饭。这里循环的条件是饭没有好，饭没有好，就循环的来看饭好了没有</li></ul></li></ul><h2 id="单分支结构"><a href="#单分支结构" class="headerlink" title="单分支结构"></a>单分支结构</h2><ul><li><p>if语句</p><ul><li>if condition:<ul><li>代码块</li></ul></li><li>condition必须是一个bool类型，这个地方有一个隐式转换bool(condition)</li><li>if 1&lt;2:<br>   &#160;&#160;&#160;&#160;print(‘1 less than 2’)</li></ul></li><li><p>代码块</p><ul><li>类似于if语句的冒号后面的就是一个语句块</li><li>在if、for、def、class等</li></ul></li></ul><h2 id="真值表"><a href="#真值表" class="headerlink" title="真值表"></a>真值表</h2><table><thead><tr><th style="text-align:left">对象/常量</th><th style="text-align:left">值</th></tr></thead><tbody><tr><td style="text-align:left">“”</td><td style="text-align:left">假</td></tr><tr><td style="text-align:left">“string”</td><td style="text-align:left">真</td></tr><tr><td style="text-align:left">0</td><td style="text-align:left">假</td></tr><tr><td style="text-align:left">&gt;=1</td><td style="text-align:left">真</td></tr><tr><td style="text-align:left">&lt;=-1</td><td style="text-align:left">真</td></tr><tr><td style="text-align:left">()空元组</td><td style="text-align:left">假</td></tr><tr><td style="text-align:left">[]空列表</td><td style="text-align:left">假</td></tr><tr><td style="text-align:left">{}空字典</td><td style="text-align:left">假</td></tr><tr><td style="text-align:left">None</td><td style="text-align:left">假</td></tr></tbody></table><ul><li>False等价布尔值，相当于bool(value)<ul><li>空集合<ul><li>空字符串</li><li>空字典</li><li>空列表</li><li>空元祖</li></ul></li><li>None对象</li><li>0</li></ul></li></ul><h2 id="多分支结构"><a href="#多分支结构" class="headerlink" title="多分支结构"></a>多分支结构</h2><ul><li><p>if…elif…else语句<br>&#160;&#160;&#160;&#160;if condition1:<br>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;代码块1<br>&#160;&#160;&#160;&#160;elif condition2:<br>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;代码块2<br>&#160;&#160;&#160;&#160;elif condition3:<br>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;代码块3<br>&#160;&#160;&#160;&#160;……<br>&#160;&#160;&#160;&#160;else:<br>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;代码块  </p></li><li><p>举例<br>&#160;&#160;&#160;&#160;a = 5<br>&#160;&#160;&#160;&#160;if a&lt;0:<br>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;print(‘negative’)<br>&#160;&#160;&#160;&#160;elif a==0:<br>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;print(‘zero’)<br>&#160;&#160;&#160;&#160;else:<br>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;print(‘positive’)  </p></li></ul><h2 id="分支嵌套"><a href="#分支嵌套" class="headerlink" title="分支嵌套"></a>分支嵌套</h2><ul><li><p>举例<br>&#160;&#160;&#160;&#160;score = 80<br>&#160;&#160;&#160;&#160;&#160;if score&lt;0:<br>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;print(‘wrong’)<br>&#160;&#160;&#160;&#160;else:<br>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if score==0:<br>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;print(‘egg’)<br>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;elif score &lt;= 100:<br>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;print(‘right’)<br>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;else:<br>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;print(‘too big’)  </p></li><li><p>嵌套结构，可以是分支、循环的嵌套</p></li><li><p>可以互相嵌套多层</p></li><li><p>练习：给定一个不超过5位的正整数，判断其有几位  </p><ul><li>使用 input 函数，input返回的是字符串</li><li>如果位数多的话可以用折半</li><li>num = 8<br>if (num /= 10) == 0: &#160;&#160;&#160;&#160; 为什么这里报错<br>&#160;&#160;&#160;&#160;print(‘1位数’)</li></ul></li></ul><h2 id="循环——while语句"><a href="#循环——while语句" class="headerlink" title="循环——while语句"></a>循环——while语句</h2><ul><li><p>语法<br>&#160;&#160;&#160;&#160;while condition:<br>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;block  </p><ul><li>当条件满足即condition为True，进入循环体，执行block</li></ul></li><li><p>举例<br>&#160;&#160;&#160;&#160;flag=10<br>&#160;&#160;&#160;&#160;while flag:<br>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;print(flag)<br>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;flag -= 1  </p><ul><li>执行结果是什么？为什么？</li><li>如果flag=-10可以吗？如何改造？</li></ul></li></ul><h2 id="循环——for语句"><a href="#循环——for语句" class="headerlink" title="循环——for语句*"></a>循环——for语句*</h2><ul><li><p>语法</p><ul><li>for element in iteratable:<br>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;block</li><li>当可迭代对象中有元素可以迭代，进入循环体，执行block</li></ul></li><li><p>range函数  </p></li><li><p>举例：打印1~10<br>&#160;&#160;&#160;&#160;for i in range(10):<br>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;print(i+1)  </p><ul><li>执行结果是什么？为什么？</li><li>如果想倒序打印呢</li></ul></li></ul><h2 id="循环-continue语句"><a href="#循环-continue语句" class="headerlink" title="循环 continue语句"></a>循环 continue语句</h2><ul><li><p>中断当前循环的当次执行，继续下一次循环</p></li><li><p>举例：计算10以内的偶数（for循环）<br>&#160;&#160;&#160;&#160;for i in range(10):<br>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if not i%2:  &#160;&#160;&#160;&#160; # i%2==0这么写也行<br>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;print(i)  </p></li><li>还有其它的实现吗？</li></ul><p>&#160;&#160;&#160;&#160;for i in range(0,10,2):<br>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;print(i)  </p><p>&#160;&#160;&#160;&#160;for i in range(0,10):<br>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if i &amp; 1: &#160;&#160;&#160;&#160;# 或用 i%2  表示奇数就continue<br>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;continue<br>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;print(i)  </p><h2 id="循环-break语句"><a href="#循环-break语句" class="headerlink" title="循环 break语句"></a>循环 break语句</h2><ul><li>终止当前循环</li><li>举例：计算1000以内的被7整除的前20个数（for循环）<br>&#160;&#160;&#160;&#160;count = 0<br>&#160;&#160;&#160;&#160;for i in range(0,1000,7):<br>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;print(i)<br>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;count += 1<br>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;if count &gt;= 20:<br>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;break</li></ul><h2 id="循环-continue、break语句"><a href="#循环-continue、break语句" class="headerlink" title="循环 continue、break语句"></a>循环 continue、break语句</h2><ul><li><p>总结</p><ul><li>continue和break是循环的控制语句，只影响当前循环，包括while、for循环</li><li>如果循环嵌套， continue和break也只影响语句所在的那一层循环</li><li>continue和break 不是跳出语句块，所以 if cond: break 不是跳出if，而是终止if外的break所在的循环</li></ul></li><li><p>练习：<br>给定一个不超过5位的正整数，判断该数的位数，依次打印出个位、十位、百位、千位、万位的数字  </p></li></ul><h2 id="循环-else子句"><a href="#循环-else子句" class="headerlink" title="循环 else子句"></a>循环 else子句</h2><ul><li><p>语法<br>&#160;&#160;&#160;&#160;while condition:<br>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;block<br>&#160;&#160;&#160;&#160;else:<br>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;block<br>&#160;&#160;&#160;&#160;for element in iteratable:<br>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;block<br>&#160;&#160;&#160;&#160;else:<br>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;block  </p></li><li><p>如果循环正常的执行结束，就执行else子句；如果使用break终止，else子句不会执行</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;第二章-Python-基础语法&quot;&gt;&lt;a href=&quot;#第二章-Python-基础语法&quot; class=&quot;headerlink&quot; title=&quot;第二章 - Python 基础语法&quot;&gt;&lt;/a&gt;第二章 - Python 基础语法&lt;/h1&gt;&lt;h2 id=&quot;基本语法&quot;&gt;&lt;a 
      
    
    </summary>
    
      <category term="python-magedu" scheme="https://herodanny.github.io/categories/python-magedu/"/>
    
    
      <category term="python" scheme="https://herodanny.github.io/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>python全栈-magedu-2018-笔记1</title>
    <link href="https://herodanny.github.io/python-magedu-2018-notes1.html"/>
    <id>https://herodanny.github.io/python-magedu-2018-notes1.html</id>
    <published>2019-04-19T12:16:49.000Z</published>
    <updated>2019-05-20T12:56:02.625Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第一章-Python概述、环境搭建"><a href="#第一章-Python概述、环境搭建" class="headerlink" title="第一章 - Python概述、环境搭建"></a>第一章 - Python概述、环境搭建</h1><h2 id="操作系统准备"><a href="#操作系统准备" class="headerlink" title="操作系统准备"></a>操作系统准备</h2><p>准备Linux最小系统即可。 </p><p>如果在虚拟机中克隆，MAC地址会变。 这里使用CentOS 6.5+ </p><h2 id="p-2-x和3-x区别"><a href="#p-2-x和3-x区别" class="headerlink" title="p 2.x和3.x区别"></a>p 2.x和3.x区别</h2><ul><li>语句函数化，例如print(1,2)打印出1 2，但是2.x中意思是print语句打印元组，3.x中意思是函数的2个参数</li><li>整除，例如1/2和1//2，3.x版本中/为自然除</li><li>3.x中raw_input重命名为input，不再使用raw_input</li><li>round函数，在3.x中i.5的取整变为距离最近的偶数</li><li>字符串统一使用Unicode</li><li>异常的捕获、抛出的语法改变</li></ul><h2 id="开发环境——Pyenv"><a href="#开发环境——Pyenv" class="headerlink" title="开发环境——Pyenv"></a>开发环境——Pyenv</h2><ul><li>Python多版本管理工具<ul><li>管理Python解释器</li><li>管理Python版本</li><li>管理Python的虚拟环境</li></ul></li><li>官网 <a href="https://github.com/pyenv/pyenv" target="_blank" rel="noopener">https://github.com/pyenv/pyenv</a></li></ul><h2 id="Pyenv-安装"><a href="#Pyenv-安装" class="headerlink" title="Pyenv 安装"></a>Pyenv 安装</h2><ul><li>参照安装文档</li><li>pyenv的安装</li><li>python多版本安装</li><li>pyenv之global、shell、local的设置</li><li>pyenv的虚拟环境</li><li>更新：$ pyenv update</li></ul><ol><li>安装git </li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install git -y</span><br></pre></td></tr></table></figure><ol start="2"><li>安装Python编译依赖 </li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum -y install gcc make patch gdbm-devel openssl-devel sqlite-devel  readline-devel zlib-devel bzip2-devel</span><br></pre></td></tr></table></figure><ol start="3"><li>创建用户python </li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">useradd python </span><br><span class="line">passwd python</span><br></pre></td></tr></table></figure><ol start="4"><li>使用python用户登录后安装Pyenv </li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -L https://github.com/pyenv/pyenv-installer/raw/master/bin/pyenv-installer | bash</span><br></pre></td></tr></table></figure><p>下载的 pyenv-installer 是一个shell脚本。<br>注意： </p><ol><li>在 <a href="https://github.com/pyenv/pyenv-installer" target="_blank" rel="noopener">https://github.com/pyenv/pyenv-installer</a> 有安装文档<br><a href="https://www.jianshu.com/p/9bba0216c042" target="_blank" rel="noopener">Mac下pyenv与pyenv-virtualenv的安装和使用</a>  </li><li><p>如果curl出现 curl: (35) SSL connect error ，是nss版本低的问题，更新它。 可能需要配置一个有较新包的yum源 </p><pre><code>[updates] name=CentOS-Updates baseurl=https://mirrors.aliyun.com/centos/6.9/os/x86_64 gpgcheck=0 </code></pre></li></ol><p>然后更新nss<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum update nss</span><br></pre></td></tr></table></figure></p><ol start="5"><li>在python用户的~/.bash_profile中追加 </li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> PATH=<span class="string">"/home/python/.pyenv/bin:<span class="variable">$PATH</span>"</span> </span><br><span class="line"><span class="built_in">eval</span> <span class="string">"<span class="variable">$(pyenv init -)</span>"</span> </span><br><span class="line"><span class="built_in">eval</span> <span class="string">"<span class="variable">$(pyenv virtualenv-init -)</span>"</span> </span><br><span class="line"><span class="built_in">source</span> ~/.bash_profile</span><br></pre></td></tr></table></figure><p>这样当用户启动的时候，会执行用户的 .bash_profile 中的脚本，就会启动pyenv。 安装好的pyenv 就在~/.pyenv中 </p><h2 id="Pyenv-使用"><a href="#Pyenv-使用" class="headerlink" title="Pyenv 使用"></a>Pyenv 使用</h2><p>python 版本及path路径<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">python --version </span><br><span class="line">python -V </span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$PATH</span></span><br></pre></td></tr></table></figure></p><p>可以看到当前系统Python路径 </p><p>pyenv 命令<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pyenv</span><br><span class="line">pyenv <span class="built_in">help</span> install</span><br></pre></td></tr></table></figure></p><p>列出所有可用版本<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pyenv install --list</span><br></pre></td></tr></table></figure></p><p>安装指定版本<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pyenv install 3.5.3 -v <span class="comment"># 加 -v 可以看详细过程 verbose</span></span><br><span class="line">pyenv versions</span><br></pre></td></tr></table></figure></p><p>会从python官网下载安装压缩包到 /tmp 目录，很慢，为了提速，可选用cache方法。</p><p>使用缓存方式安装<br>在~/.pyenv目录下，新建cache目录，放入下载好的待安装版本的文件。  </p><p>不确定要哪一个文件，把下载的3个文件都放进去。一般放 ‘tar.xz’ 包。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ scp ~/Downloads/Python-3.5.3.tar.xz herodanny@10.211.55.6:~/.pyenv/cache</span><br></pre></td></tr></table></figure></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pyenv install 3.5.3 -v</span><br><span class="line"><span class="comment"># 编译安装下载的源文件</span></span><br></pre></td></tr></table></figure><p>安装后的python文件夹在 .pyenv/versions 下。<br>cache文件夹里有下载的压缩包。  </p><p>pyenv 的 python版本控制<br>version 显示当前的python版本 versions 显示所有可用的python版本，和当前版本。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pyenv version</span><br><span class="line">pyenv versions</span><br></pre></td></tr></table></figure></p><ul><li><p>global 全局设置<br><code>pyenv global 3.5.3</code> 可以看到所有受pyenv控制的窗口中都是3.5.3的python版本了。 这里用global是作用于非root用户python用户上，如果是root用户安装，请不要使用global，否则影响太大。比如，这里使用的CentOS6.5就是Python2.6，使用了global就成了3.x，会带来很不好的影响。 <code>pyenv global system</code> 回到原来系统版本。  </p></li><li><p>shell 会话设置<br>影响只作用于当前会话 <code>pyenv shell 3.5.3</code><br>是会话级的，一旦断开sessionid也变了，也不好用。  </p></li><li><p>local 本地设置<br>使用pyenv local设置从当前工作目录开始向下递归都继承这个设置。  </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pyenv <span class="built_in">local</span> 3.5.3</span><br><span class="line">python -V</span><br><span class="line"><span class="comment"># 可能还是显示原来的版本，用pyenv version，要在虚拟环境中python -V 才会显示新的版本</span></span><br></pre></td></tr></table></figure></li></ul><p>也可以使用 anaconda，特别是 pyenv 不支持windows，pyenv 是自己下源码编，某些情况下可能不如 anaconda 直接编好的二进制分发。其实直接用 pycharm 就可以在 windows 或 linux 下创建虚拟环境。  </p><h2 id="Virtualenv-虚拟环境设置"><a href="#Virtualenv-虚拟环境设置" class="headerlink" title="Virtualenv 虚拟环境设置"></a>Virtualenv 虚拟环境设置</h2><p>为什么要使用虚拟环境？ 因为刚才使用的Python环境都是一个公共的空间，如果多个项目使用不同Python版本开发，或者使用不同的Python版本部署运行，或者使用同样的版本开发的但不同项目使用了不同版本的库，等等这些问题都会带来冲突。最好的解决办法就是每一个项目独立运行自己的“独立小环境”中。  </p><p>使用插件，在plugins/pyenv-virtualenv中<br><code>pyenv virtualenv 3.5.3 mag353</code><br>使用python3.5.3版本创建出一个独立的虚拟空间 mag353。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ pyenv versions</span><br><span class="line">* system (<span class="built_in">set</span> by /home/python/.pyenv/version)</span><br><span class="line">3.5.3</span><br><span class="line">3.5.3/envs/mag353</span><br><span class="line">mag353</span><br></pre></td></tr></table></figure><p>可以在版本列表中存在，就和3.5.3是一样的，就是一个版本了。以后只要使用这个虚拟版本，包就会按照到这些对应的目录下去，而不是使用3.5.3。<br>可以看到真实的虚拟环境是下 envs/ 目录下。<br>.pyenv/versions/ 下是软链接。  </p><p>在需要设置python版本的文件夹路径下<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pyenv <span class="built_in">local</span> mag353</span><br><span class="line">pyenv versions</span><br></pre></td></tr></table></figure></p><p>怎么会起作用的，是利用了当前目录下隐藏文件.python-version和在 .bash_profile 中添加的那几指令。</p><p>现在可以对python进行版本的管理，包的管理。</p><h2 id="pip-包管理器"><a href="#pip-包管理器" class="headerlink" title="pip 包管理器"></a>pip 包管理器</h2><ul><li>pip install xxx yyy</li><li>pip list</li><li>pip search keyword 或者 pypi</li><li>pip help install</li><li>pip install redis ipython</li><li>pip install jupyter</li><li>pip -V</li><li>pip freeze 命令查看虚拟环境中安装了哪些包</li><li>pip freeze &gt; requirement</li><li>pip install -r requirement</li></ul><p><a href="https://blog.csdn.net/mrwxh/article/details/80344907" target="_blank" rel="noopener">pip list 和 pip freeze</a></p><p>pip 是Python的包管理工具，3.x的版本直接带了，可以直接使用。 和yun一样为了使用国内镜像，如下配置。<br><code>mkdir ~/.pip</code><br>配置文件在 ~/.pip/pip.conf  </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[global]</span><br><span class="line">index-url=https://mirrors.aliyun.com/pypi/simple/</span><br><span class="line">trusted-host=mirrors.aliyun.com</span><br></pre></td></tr></table></figure><h2 id="安装-ipython"><a href="#安装-ipython" class="headerlink" title="安装 ipython"></a>安装 ipython</h2><p>ipython 是增强的交互式 Python 命令行工具，增强的Python Shell，自动补全、自动缩进、支持shell，增加了很多函数<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pip install ipython  </span><br><span class="line">ipython</span><br></pre></td></tr></table></figure></p><p>ipython中提供了魔术方法，在代码(包括注释)最上面输入 %%timeit 可以测试运行时间。<br><a href="https://supergis.gitbooks.io/git_notebook/content/doc/jupyter_magics.html" target="_blank" rel="noopener">https://supergis.gitbooks.io/git_notebook/content/doc/jupyter_magics.html</a>  </p><h2 id="安装-Jupyter"><a href="#安装-Jupyter" class="headerlink" title="安装 Jupyter"></a>安装 Jupyter</h2><p>Jupyter 是基于WEB的交互式笔记本，其中可以非常方便的使用Python。<br>独立的交互式笔记本，后台使用Ipython。<br>安装Jupyter，也会安装ipython的。  </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">pip/pip3 install jupyter</span><br><span class="line">jupyter notebook <span class="built_in">help</span></span><br><span class="line">jupyter notebook password <span class="comment"># 设置下浏览器访问时的密码</span></span><br><span class="line">jupyter notebook --ip=0.0.0.0 --no-browser</span><br><span class="line">ss -tanl</span><br></pre></td></tr></table></figure><p>浏览器不能访问是服务器端防火墙问题。  </p><p><a href="https://blog.csdn.net/QimaoRyan/article/details/76022038" target="_blank" rel="noopener">Jupyter Notebook基本操作</a><br><a href="https://jupyter-notebook.readthedocs.io/en/latest/index.html" target="_blank" rel="noopener">https://jupyter-notebook.readthedocs.io/en/latest/index.html</a><br><a href="https://blog.csdn.net/hao5335156/article/details/80691401" target="_blank" rel="noopener">在服务器上配置jupyter设置远程登录</a><br><a href="https://www.cnblogs.com/wushaogui/p/8797841.html" target="_blank" rel="noopener">Jupyter开发环境搭建</a>  </p><p>快捷键：shift + enter(运行)、ctrl + enter(运行)、dd(删除一行)、m(用mardkown)。<br>在 jupyter 中也是可以运行 js 代码的。第一行先输入 %%js。<br>_ 表示上次输出的结果。可使用 print(<em>) 看看。<br>在python中</em>也表示不关心的变量。</p><h2 id="导出包"><a href="#导出包" class="headerlink" title="导出包"></a>导出包</h2><p>虚拟环境的好处就在于和其他项目运行环境隔离。每一个独立的环境都可以使用pip命令导出已经安装的包，在另一个环境中安装这些包。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">(mag353) [python@node web]$ pip freeze &gt; requirement</span><br><span class="line">(mag353) [python@node web]$ mkdir ~/magedu/projects/pro1</span><br><span class="line">(mag353) [python@node web]$ <span class="built_in">cd</span> ~/magedu/projects/pro1</span><br><span class="line">[python@node pro1]$ pyenv install --list</span><br><span class="line">[python@node pro1]$ pyenv install 3.6.4</span><br><span class="line">[python@node pro1]$ pyenv virtualenv 3.6.4 mag364</span><br><span class="line">[python@node pro1]$ pyenv <span class="built_in">local</span> mag364</span><br><span class="line">(mag364) [python@node pro1]$ mv ../web/requirement ./</span><br><span class="line">(mag364) [python@node pro1]$ pip install -r requirement</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;第一章-Python概述、环境搭建&quot;&gt;&lt;a href=&quot;#第一章-Python概述、环境搭建&quot; class=&quot;headerlink&quot; title=&quot;第一章 - Python概述、环境搭建&quot;&gt;&lt;/a&gt;第一章 - Python概述、环境搭建&lt;/h1&gt;&lt;h2 id=&quot;操
      
    
    </summary>
    
      <category term="python-magedu" scheme="https://herodanny.github.io/categories/python-magedu/"/>
    
    
      <category term="python" scheme="https://herodanny.github.io/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>用VsCode写Markdown</title>
    <link href="https://herodanny.github.io/vscode-write-markdown.html"/>
    <id>https://herodanny.github.io/vscode-write-markdown.html</id>
    <published>2019-04-18T07:47:28.000Z</published>
    <updated>2019-04-18T12:52:19.651Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Markdown-基本语法"><a href="#Markdown-基本语法" class="headerlink" title="Markdown 基本语法"></a>Markdown 基本语法</h1><h2 id="段落"><a href="#段落" class="headerlink" title="段落"></a>段落</h2><p>非常自然，一行文字就是一个段落。</p><p>比如：</p><pre><code>这是一个段落</code></pre><p>会被解释成：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>这是一个段落。<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><p>如果你需要另起一段，请在两个段落之间隔一个空行。</p><pre><code>这是一个段落。这是另一个段落。</code></pre><p>会被解释成</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>这是一个段落<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>这是另一个段落<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><p>不隔一个空行的换行行为，在一些编辑器中被解释为换行，即插入一个<br>标签。对与另外一些编辑器，会被解释为插入一个空格。对于后者，若要插入换行标签，请在当前一行的结尾打两个空格。(vscode 就是后者，typora 普通模式是前者，源码模式和 vscode 一样是后者)</p><p>没用空一行，在结尾打两个空格的换行，还在一个段落中。</p><h2 id="粗体、斜体"><a href="#粗体、斜体" class="headerlink" title="粗体、斜体"></a>粗体、斜体</h2><p>可以使用星号*或下划线_指定粗体或者斜体。</p><pre><code>*这是斜体*_这也是斜体_**这是粗体*****这是粗体+斜体***</code></pre><p>会被解释成</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">em</span>&gt;</span>这是斜体<span class="tag">&lt;/<span class="name">em</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">em</span>&gt;</span>这也是斜体<span class="tag">&lt;/<span class="name">em</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">strong</span>&gt;</span>这是粗体<span class="tag">&lt;/<span class="name">strong</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">strong</span>&gt;</span><span class="tag">&lt;<span class="name">em</span>&gt;</span>这是粗体+斜体<span class="tag">&lt;/<span class="name">strong</span>&gt;</span><span class="tag">&lt;/<span class="name">em</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="删除线"><a href="#删除线" class="headerlink" title="删除线"></a>删除线</h2><p>一部分编辑器支持删除线，它不是经典 markdown 中的要素。用波浪线~定义删除线。</p><pre><code>~~就像这样~~</code></pre><p>会被解释成</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">strike</span>&gt;</span>就像这样<span class="tag">&lt;/<span class="name">strike</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="标题"><a href="#标题" class="headerlink" title="标题"></a>标题</h2><p>markdown 总支持 1~6 六级标题，通过在一行之前加上不同数量的井号来表示。</p><pre><code># 这是 H1 ### 这是 H2 ##### 这是 H3 ###...###### 这是 H6 ######</code></pre><p>行尾可以加上任意数量的井号字符，这些字符不会算作标题内容。通常会加上相等数量的字符以保持对称。</p><p>此外，H1 和 H2 也可以采用在文本下方添加底线来实现，比如：</p><pre><code>这是 H1=======这是 H2-------</code></pre><h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><p>通过在行首加上大于号&gt;来添加引用格式。</p><pre><code>&gt; This is a blockquote with two paragraphs. Lorem ipsum dolor sit amet,consectetuer adipiscing elit. Aliquam hendrerit mi posuere lectus.Vestibulum enim wisi, viverra nec, fringilla in, laoreet vitae, risus.&gt; Donec sit amet nisl. Aliquam semper ipsum sit amet velit. Suspendisseid sem consectetuer libero luctus adipiscing.</code></pre><blockquote><p>This is a blockquote with two paragraphs. Lorem ipsum dolor sit amet,<br>consectetuer adipiscing elit. Aliquam hendrerit mi posuere lectus.<br>Vestibulum enim wisi, viverra nec, fringilla in, laoreet vitae, risus.</p></blockquote><blockquote><p>Donec sit amet nisl. Aliquam semper ipsum sit amet velit. Suspendisse<br>id sem consectetuer libero luctus adipiscing.</p></blockquote><p>引用可以嵌套：</p><pre><code>&gt; This is the first level of quoting.&gt;&gt; &gt; This is nested blockquote.&gt;&gt; Back to the first level.</code></pre><blockquote><p>This is the first level of quoting.</p><blockquote><p>This is nested blockquote.</p></blockquote><p>Back to the first level.</p></blockquote><p>也可以嵌套其他格式：</p><pre><code>&gt; ## 这是一个标题。&gt;&gt; 1.   这是第一行列表项。&gt; 2.   这是第二行列表项。&gt;&gt; 给出一些例子代码：&gt;&gt;     return shell_exec(&quot;echo $input | $markdown_script&quot;);</code></pre><blockquote><h2 id="这是一个标题。"><a href="#这是一个标题。" class="headerlink" title="这是一个标题。"></a>这是一个标题。</h2><ol><li>这是第一行列表项。</li><li>这是第二行列表项。</li></ol><p>给出一些例子代码：</p><pre><code>return shell_exec(&quot;echo $input | $markdown_script&quot;);</code></pre></blockquote><h2 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h2><p>无序列表使用星号、加号或是减号作为列表标记：</p><pre><code>*   Red*   Green*   Blue</code></pre><ul><li>Red</li><li>Green</li><li>Blue</li></ul><p>等同于</p><pre><code>+   Red+   Green+   Blue</code></pre><p>和</p><pre><code>-   Red-   Green-   Blue</code></pre><p>有序列表则使用数字接着一个英文句点：  </p><pre><code>1.  Bird2.  McHale3.  Parish</code></pre><ol><li>Bird</li><li>McHale</li><li>Parish</li></ol><h2 id="内敛代码"><a href="#内敛代码" class="headerlink" title="内敛代码"></a>内敛代码</h2><p>用反引号 ` 来标记内联代码，它们会解释成 <code>&lt;code&gt;</code> 标签。如果代码的内容中有反引号，请用两个反引号包裹。</p><h2 id="代码区域"><a href="#代码区域" class="headerlink" title="代码区域"></a>代码区域</h2><p>有两种方式标记代码区域，原生风格是行首缩进四个空格。</p><p>这是一个普通段落：</p><pre><code>这是一个代码区块。</code></pre><p>会被解释成</p><pre><code>&lt;p&gt;这是一个普通段落：&lt;/p&gt;&lt;pre&gt;&lt;code&gt;这是一个代码区块。&lt;/code&gt;&lt;/pre&gt;</code></pre><h2 id="分隔线"><a href="#分隔线" class="headerlink" title="分隔线"></a>分隔线</h2><p>你可以在一行中用三个以上的星号、减号、底线来建立一个分隔线，行内不能有其他东西。你也可以在星号或是减号中间插入空格。下面每种写法都可以建立分隔线：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">* </span><span class="bullet">* *</span></span><br><span class="line"><span class="emphasis">***</span></span><br><span class="line"><span class="strong">*****</span></span><br><span class="line"><span class="bullet">- </span>- -</span><br><span class="line">---------------------------------------</span><br></pre></td></tr></table></figure><h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><pre><code>[an example](http://example.com/)[an example](http://example.com/ &quot;Optional Title&quot;)</code></pre><p>会被解释为</p><pre><code>&lt;a href=&apos;http://example.com/&apos;&gt;an example&lt;/a&gt;&lt;a href=&apos;http://example.com/&apos; title=&quot;Optional Title&quot;&gt;an example&lt;/a&gt;</code></pre><p>除了上面的行内式，也可以使用参考式：</p><pre><code>[an example][id]</code></pre><p>然后在任意空白位置定义：</p><pre><code>[id]: http://example.com/ &quot;Optional Title&quot;</code></pre><h2 id="图像"><a href="#图像" class="headerlink" title="图像"></a>图像</h2><pre><code>![Alt text](/path/to/img.jpg)![Alt text](/path/to/img.jpg &quot;Optional Title&quot;)</code></pre><p>会被解释为</p><pre><code>&lt;img src=&apos;/path/to/img.jpg&apos; alt=&apos;Alt text&apos; /&gt;&lt;img src=&apos;/path/to/img.jpg&apos; alt=&apos;Alt text&apos; title=&apos;Optional Title&apos; /&gt;</code></pre><p>同样，图像也有类似的参考式语法。</p><h2 id="自动链接"><a href="#自动链接" class="headerlink" title="自动链接"></a>自动链接</h2><p>如果链接的地址和名字重复，可以用尖括号语法将其简化。</p><pre><code>&lt;http://example.com/&gt;</code></pre><p>就相当于</p><pre><code>[http://example.com/](http://example.com/)</code></pre><p>切记，大多数编辑器都会自动将符合url规则的东西视为链接，并且解释成链接。很多时候作者由于疏忽等缘故，链接和后面的中文之间缺少空格，导致链接不正常。所以我建议，链接要么加上尖括号，要么两端加上空格。</p><h2 id="转义"><a href="#转义" class="headerlink" title="转义"></a>转义</h2><p>markdown支持在以下字符前面插入反斜杠</p><pre><code>\   反斜线`   反引号*   星号_   底线{}  花括号[]  方括号()  括弧#   井字号+   加号-   减号.   英文句点!   惊叹号</code></pre><h2 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h2><pre><code>| Item     | Value |  Qty  || :------- | ----: | :---: || Computer | $1600 |   5   || Phone    |   $12 |  12   || Pipe     |    $1 |  234  |</code></pre><p>会被解释成</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">table</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">thead</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">th</span> <span class="attr">align</span>=<span class="string">"left"</span>&gt;</span>Item<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">th</span> <span class="attr">align</span>=<span class="string">"right"</span>&gt;</span>Value<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">th</span> <span class="attr">align</span>=<span class="string">"center"</span>&gt;</span>Qty<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">thead</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">tbody</span>&gt;</span><span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">td</span> <span class="attr">align</span>=<span class="string">"left"</span>&gt;</span>Computer<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">td</span> <span class="attr">align</span>=<span class="string">"right"</span>&gt;</span>$1600<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">td</span> <span class="attr">align</span>=<span class="string">"center"</span>&gt;</span>5<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">td</span> <span class="attr">align</span>=<span class="string">"left"</span>&gt;</span>Phone<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">td</span> <span class="attr">align</span>=<span class="string">"right"</span>&gt;</span>$12<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">td</span> <span class="attr">align</span>=<span class="string">"center"</span>&gt;</span>12<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">td</span> <span class="attr">align</span>=<span class="string">"left"</span>&gt;</span>Pipe<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">td</span> <span class="attr">align</span>=<span class="string">"right"</span>&gt;</span>$1<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">td</span> <span class="attr">align</span>=<span class="string">"center"</span>&gt;</span>234<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tbody</span>&gt;</span><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br></pre></td></tr></table></figure><p>要注意第二行的冒号决定了居左居右还是居中，如果你不加冒号，默认是居左的。</p><p>另外可以把第一行去掉，做成没有表头的表格，但第二行始终是要有的。</p><h2 id="内联-HTML"><a href="#内联-HTML" class="headerlink" title="内联 HTML"></a>内联 HTML</h2><p>markdown 的语法简洁，但有其局限性，所以特意保留了内联html这种方式。任何html标签及其内容，都会原样输出到结果中。也就是说，标签中的星号等作为markdown结构的符号，以及构成html标签和实体的符号，都不会做任何转义。</p><h2 id="vscode-markdown-扩展"><a href="#vscode-markdown-扩展" class="headerlink" title="vscode markdown 扩展"></a>vscode markdown 扩展</h2><p>Markdown All in One<br>Markdown Shortcuts</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Markdown-基本语法&quot;&gt;&lt;a href=&quot;#Markdown-基本语法&quot; class=&quot;headerlink&quot; title=&quot;Markdown 基本语法&quot;&gt;&lt;/a&gt;Markdown 基本语法&lt;/h1&gt;&lt;h2 id=&quot;段落&quot;&gt;&lt;a href=&quot;#段落&quot; cla
      
    
    </summary>
    
      <category term="before-development" scheme="https://herodanny.github.io/categories/before-development/"/>
    
    
      <category term="markdown" scheme="https://herodanny.github.io/tags/markdown/"/>
    
  </entry>
  
  <entry>
    <title>my blog test</title>
    <link href="https://herodanny.github.io/my-blog-test.html"/>
    <id>https://herodanny.github.io/my-blog-test.html</id>
    <published>2019-04-13T03:59:37.000Z</published>
    <updated>2019-04-15T10:05:00.642Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Anima"><a href="#Anima" class="headerlink" title="Anima"></a>Anima</h1><!--<p align="center">    <a href="https://github.com/biezhi/anima/wiki"><img src="screenshot/cover.png" width="623"/></a></p>--><p><code>Anima</code> allows you to query database like <code>SQL</code> and <code>Stream</code>.<br>a simple DSL syntax, supports multiple databases, integrates well with Java8,<br>supports multiple relational mappings, and is a database manipulation tool.</p><p><strong><a href="https://github.com/biezhi/anima/wiki" target="_blank" rel="noopener">Document</a></strong></p><p><a href="https://travis-ci.org/biezhi/anima" target="_blank" rel="noopener"><img src="https://travis-ci.org/biezhi/anima.svg?branch=master" alt="Travis Build"></a><br><a href="https://mvnrepository.com/artifact/io.github.biezhi/anima" target="_blank" rel="noopener"><img src="https://img.shields.io/maven-central/v/io.github.biezhi/anima.svg" alt></a></p><a id="more"></a><h2 id="Feature"><a href="#Feature" class="headerlink" title="Feature"></a>Feature</h2><ul><li>Simple DSL </li><li>H2、MySQL、SQLite、PostgreSQL、Oracle、SqlServer </li><li>Paging support </li><li>Flexible configuration </li><li>Connection pool support</li><li>Support <code>LocalDate</code>、<code>LocalDateTime</code></li><li>Support lambda expression</li><li>Relationship (<code>hasOne</code>、<code>hasMany</code>、<code>belongsTo</code>)</li><li>SQL performance statistics</li><li>Based Java8</li></ul><h1 id="Usage"><a href="#Usage" class="headerlink" title="Usage"></a>Usage</h1><p><strong>Latest snapshot version</strong></p><blockquote><p>If you want to prioritize new features or some BUG fixes you can use it, you need to specify the snapshot repository in <code>pom.xml</code></p></blockquote><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">repository</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">id</span>&gt;</span>snapshots-repo<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url</span>&gt;</span>https://oss.sonatype.org/content/repositories/snapshots<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">releases</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">enabled</span>&gt;</span>false<span class="tag">&lt;/<span class="name">enabled</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">releases</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">snapshots</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">enabled</span>&gt;</span>true<span class="tag">&lt;/<span class="name">enabled</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">snapshots</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">repository</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.github.biezhi<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>anima<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.2.4-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>Here’s the <code>RELEASE</code> version.</p><p><strong>As Gradle</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">compile <span class="string">'io.github.biezhi:anima:0.2.3'</span></span><br></pre></td></tr></table></figure><p><strong>As Maven</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.github.biezhi<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>anima<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.2.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>📒 Although <code>Anima</code> can also be used by adding a jar package, we do not recommend doing this.</p></blockquote><h2 id="Examples"><a href="#Examples" class="headerlink" title="Examples"></a>Examples</h2><p><strong>Open Connection</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// MySQL</span></span><br><span class="line">Anima.open(<span class="string">"jdbc:mysql://127.0.0.1:3306/demo"</span>, <span class="string">"root"</span>, <span class="string">"123456"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// SQLite</span></span><br><span class="line">Anima.open(<span class="string">"jdbc:sqlite:./demo.db"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// H2</span></span><br><span class="line">Anima.open(<span class="string">"jdbc:h2:file:~/demo;FILE_LOCK=FS;PAGE_SIZE=1024;CACHE_SIZE=8192"</span>, <span class="string">"sa"</span>, <span class="string">""</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// DataSource</span></span><br><span class="line">DruidDataSource dataSource = <span class="keyword">new</span> DruidDataSource();</span><br><span class="line">dataSource.setDriverClassName(<span class="string">"com.mysql.jdbc.Driver"</span>);</span><br><span class="line">dataSource.setUrl(blade.environment().getOrNull(<span class="string">"jdbc.url"</span>));</span><br><span class="line">dataSource.setUsername(blade.environment().getOrNull(<span class="string">"jdbc.username"</span>));</span><br><span class="line">dataSource.setPassword(blade.environment().getOrNull(<span class="string">"jdbc.password"</span>));</span><br><span class="line">Anima.open(dataSource);</span><br></pre></td></tr></table></figure><blockquote><p>📕 This operation only needs one time</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> <span class="keyword">extends</span> <span class="title">Model</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line">    <span class="keyword">private</span> String  userName;</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">(String userName, Integer age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.userName = userName;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Table Structure</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`users`</span> (</span><br><span class="line">  <span class="string">`id`</span> <span class="keyword">IDENTITY</span> PRIMARY <span class="keyword">KEY</span>,</span><br><span class="line">  <span class="string">`user_name`</span> <span class="built_in">varchar</span>(<span class="number">50</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">  <span class="string">`age`</span> <span class="built_in">int</span>(<span class="number">11</span>)</span><br><span class="line">)</span><br></pre></td></tr></table></figure><h3 id="Query"><a href="#Query" class="headerlink" title="Query"></a>Query</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">long</span> count = select().from(User.class).count();</span><br><span class="line"><span class="comment">// SELECT COUNT(*) FROM users</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> count = select().from(User.class).where(<span class="string">"age &gt; ?"</span>, <span class="number">15</span>).isNotNull(<span class="string">"user_name"</span>).count();</span><br><span class="line"><span class="comment">// SELECT COUNT(*) FROM users WHERE age &gt; ? AND user_name IS NOT NULL</span></span><br><span class="line"></span><br><span class="line">User user = select().from(User.class).byId(<span class="number">2</span>);</span><br><span class="line"><span class="comment">// SELECT * FROM users WHERE id = ?</span></span><br><span class="line"></span><br><span class="line">List&lt;User&gt; users = select().from(User.class).byIds(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line"><span class="comment">// SELECT * FROM users WHERE id IN (?, ?, ?)</span></span><br><span class="line"></span><br><span class="line">String name = select().bySQL(String.class, <span class="string">"select user_name from users limit 1"</span>).one();</span><br><span class="line"></span><br><span class="line">List&lt;String&gt; names = select().bySQL(String.class, <span class="string">"select user_name from users limit ?"</span>, <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">List&lt;User&gt; users = select().from(User.class).all();</span><br><span class="line"><span class="comment">// SELECT * FROM users</span></span><br><span class="line"></span><br><span class="line">List&lt;User&gt; users = select().from(User.class).like(<span class="string">"user_name"</span>, <span class="string">"%o%"</span>).all();</span><br><span class="line"><span class="comment">// SELECT * FROM users WHERE user_name LIKE ?</span></span><br></pre></td></tr></table></figure><p><strong>Limit</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List&lt;User&gt; users = select().from(User.class).order(<span class="string">"id desc"</span>).limit(<span class="number">5</span>);</span><br><span class="line"><span class="comment">// SELECT * FROM users ORDER BY id desc</span></span><br></pre></td></tr></table></figure><p><strong>Paging</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Page&lt;User&gt; userPage = select().from(User.class).order(<span class="string">"id desc"</span>).page(<span class="number">1</span>, <span class="number">3</span>);</span><br><span class="line"><span class="comment">// SELECT * FROM users ORDER BY id desc LIMIT ?, ?</span></span><br></pre></td></tr></table></figure><p><strong>Map</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select().from(User.class).map(User::getUserName).limit(<span class="number">3</span>).collect(Collectors.toList());</span><br></pre></td></tr></table></figure><p><strong>Filter</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select().from(User.class).filter(u -&gt; u.getAge() &gt; <span class="number">10</span>).collect(Collectors.toList());</span><br></pre></td></tr></table></figure><p><strong>Lambda</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">User user = select().from(User.class).where(User::getUserName).eq(<span class="string">"jack"</span>).one();</span><br><span class="line"><span class="comment">// SELECT * FROM users WHERE user_name = ?</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">List&lt;User&gt; user = select().from(User.class)</span><br><span class="line">                .where(User::getUserName).notNull()</span><br><span class="line">                .and(User::getAge).gt(<span class="number">10</span>)</span><br><span class="line">                .all();</span><br><span class="line"><span class="comment">// SELECT * FROM users WHERE user_name IS NOT NULL AND age &gt; ?</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">select().from(User.class).order(User::getId, OrderBy.DESC).order(User::getAge, OrderBy.ASC).all();</span><br><span class="line"><span class="comment">// SELECT * FROM users ORDER BY  id DESC, age ASC</span></span><br></pre></td></tr></table></figure><p><strong>Join</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Table</span>(name = <span class="string">"order_info"</span>)</span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderInfo</span> <span class="keyword">extends</span> <span class="title">Model</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Integer uid;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Column</span>(name = <span class="string">"productname"</span>)</span><br><span class="line">    <span class="keyword">private</span> String productName;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> LocalDateTime createTime;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Ignore</span></span><br><span class="line">    <span class="keyword">private</span> User user;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Ignore</span></span><br><span class="line">    <span class="keyword">private</span> Address address;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// HasOne</span></span><br><span class="line">OrderInfo orderInfo = select().from(OrderInfo.class)</span><br><span class="line">        .join(</span><br><span class="line">            Joins.with(Address.class).as(OrderInfo::getAddress)</span><br><span class="line">                 .on(OrderInfo::getId, Address::getOrderId)</span><br><span class="line">        ).byId(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">orderInfo = select().from(OrderInfo.class)</span><br><span class="line">        .join(</span><br><span class="line">            Joins.with(Address.class).as(OrderInfo::getAddress)</span><br><span class="line">                 .on(OrderInfo::getId, Address::getOrderId)</span><br><span class="line">        )</span><br><span class="line">        .join(</span><br><span class="line">                Joins.with(User.class).as(OrderInfo::getUser)</span><br><span class="line">                        .on(OrderInfo::getUid, User::getId)</span><br><span class="line">        ).byId(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ManyToOne</span></span><br><span class="line">orderInfo = select().from(OrderInfo.class)</span><br><span class="line">        .join(</span><br><span class="line">            Joins.with(User.class).as(OrderInfo::getUser)</span><br><span class="line">                 .on(OrderInfo::getUid, User::getId)</span><br><span class="line">        ).byId(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// OneToMany</span></span><br><span class="line">UserDto userDto = select().from(UserDto.class).join(</span><br><span class="line">            Joins.with(OrderInfo.class).as(UserDto::getOrders)</span><br><span class="line">                 .on(UserDto::getId, OrderInfo::getUid)</span><br><span class="line">        ).byId(<span class="number">1</span>);</span><br></pre></td></tr></table></figure><h3 id="Insert"><a href="#Insert" class="headerlink" title="Insert"></a>Insert</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Integer id = <span class="keyword">new</span> User(<span class="string">"biezhi"</span>, <span class="number">100</span>).save().asInt();</span><br><span class="line"><span class="comment">// INSERT INTO users(id,user_name,age) VALUES (?,?,?)</span></span><br></pre></td></tr></table></figure><p>or</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Anima.save(<span class="keyword">new</span> User(<span class="string">"jack"</span>, <span class="number">100</span>));</span><br></pre></td></tr></table></figure><p><strong>Batch Save</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">List&lt;User&gt; users = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">users.add(<span class="keyword">new</span> User(<span class="string">"user1"</span>, <span class="number">10</span>));</span><br><span class="line">users.add(<span class="keyword">new</span> User(<span class="string">"user2"</span>, <span class="number">11</span>));</span><br><span class="line">users.add(<span class="keyword">new</span> User(<span class="string">"user3"</span>, <span class="number">12</span>));</span><br><span class="line">Anima.saveBatch(users);</span><br></pre></td></tr></table></figure><blockquote><p>📘 This operation will begin a transaction and rollback when there is a transaction that is unsuccessful.</p></blockquote><h3 id="Update"><a href="#Update" class="headerlink" title="Update"></a>Update</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> result  = update().from(User.class).set(<span class="string">"user_name"</span>, newName).where(<span class="string">"id"</span>, <span class="number">1</span>).execute();</span><br><span class="line"><span class="comment">// UPDATE users SET username = ? WHERE id = ?</span></span><br></pre></td></tr></table></figure><p>or</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> result = update().from(User.class).set(<span class="string">"user_name"</span>, newName).where(<span class="string">"id"</span>, <span class="number">1</span>).execute();</span><br><span class="line"><span class="comment">// UPDATE users SET user_name = ? WHERE id = ?</span></span><br></pre></td></tr></table></figure><p>or</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">User user = <span class="keyword">new</span> User();</span><br><span class="line">user.setId(<span class="number">1</span>);</span><br><span class="line">user.setUserName(<span class="string">"jack"</span>);</span><br><span class="line">user.update();</span><br><span class="line"><span class="comment">// UPDATE users SET user_name = ? WHERE id = ?</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">update().from(User.class).set(User::getUserName, <span class="string">"base64"</span>).updateById(<span class="number">2</span>);</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">update().from(User.class).set(User::getUserName, <span class="string">"base64"</span>).where(User::getId).eq(<span class="number">2</span>).execute();</span><br></pre></td></tr></table></figure><h3 id="Delete"><a href="#Delete" class="headerlink" title="Delete"></a>Delete</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> result = delete().from(User.class).where(<span class="string">"id"</span>, <span class="number">1</span>).execute();</span><br><span class="line"><span class="comment">// DELETE FROM users WHERE id = ?</span></span><br></pre></td></tr></table></figure><p>or</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">User user = <span class="keyword">new</span> User();</span><br><span class="line">user.setAge(<span class="number">15</span>);</span><br><span class="line">user.setUserName(<span class="string">"jack"</span>);</span><br><span class="line">user.delete();</span><br><span class="line"><span class="comment">// DELETE FROM users WHERE user_name = ? and age = ?</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">delete().from(User.class).where(User::getId).deleteById(<span class="number">3</span>);</span><br><span class="line">delete().from(User.class).where(User::getId).eq(<span class="number">1</span>).execute();</span><br><span class="line">delete().from(User.class).where(User::getAge).lte(<span class="number">20</span>).execute();</span><br></pre></td></tr></table></figure><h3 id="Transaction"><a href="#Transaction" class="headerlink" title="Transaction"></a>Transaction</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Anima.atomic(() -&gt; &#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">1</span> / <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">new</span> User(<span class="string">"apple"</span>, <span class="number">666</span>).save();</span><br><span class="line">&#125;).catchException(e -&gt; Assert.assertEquals(ArithmeticException.class, e.getClass()));</span><br></pre></td></tr></table></figure><blockquote><p>📗 <code>Anima</code> uses the <code>atomic</code> method to complete a transaction. normally, the code will not throw an exception.<br>when a <code>RuntimeException</code> is caught, the transaction will be <code>rollback</code>.</p></blockquote><h2 id="Test-Code"><a href="#Test-Code" class="headerlink" title="Test Code"></a>Test Code</h2><p>See <a href="https://github.com/biezhi/anima/tree/master/src/test/java/io/github/biezhi/anima" target="_blank" rel="noopener">here</a></p><h2 id="License"><a href="#License" class="headerlink" title="License"></a>License</h2><p>Apache2</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Anima&quot;&gt;&lt;a href=&quot;#Anima&quot; class=&quot;headerlink&quot; title=&quot;Anima&quot;&gt;&lt;/a&gt;Anima&lt;/h1&gt;&lt;!--
&lt;p align=&quot;center&quot;&gt;
    &lt;a href=&quot;https://github.com/biezhi/anima/wiki&quot;&gt;&lt;img src=&quot;screenshot/cover.png&quot; width=&quot;623&quot;/&gt;&lt;/a&gt;
&lt;/p&gt;
--&gt;
&lt;p&gt;&lt;code&gt;Anima&lt;/code&gt; allows you to query database like &lt;code&gt;SQL&lt;/code&gt; and &lt;code&gt;Stream&lt;/code&gt;.&lt;br&gt;a simple DSL syntax, supports multiple databases, integrates well with Java8,&lt;br&gt;supports multiple relational mappings, and is a database manipulation tool.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;a href=&quot;https://github.com/biezhi/anima/wiki&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Document&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://travis-ci.org/biezhi/anima&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;&lt;img src=&quot;https://travis-ci.org/biezhi/anima.svg?branch=master&quot; alt=&quot;Travis Build&quot;&gt;&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;https://mvnrepository.com/artifact/io.github.biezhi/anima&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;&lt;img src=&quot;https://img.shields.io/maven-central/v/io.github.biezhi/anima.svg&quot; alt&gt;&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="test" scheme="https://herodanny.github.io/categories/test/"/>
    
      <category term="tools" scheme="https://herodanny.github.io/categories/tools/"/>
    
    
      <category term="test" scheme="https://herodanny.github.io/tags/test/"/>
    
      <category term="java" scheme="https://herodanny.github.io/tags/java/"/>
    
      <category term="markdown" scheme="https://herodanny.github.io/tags/markdown/"/>
    
  </entry>
  
  <entry>
    <title>my first blog article</title>
    <link href="https://herodanny.github.io/my-first-blog-article.html"/>
    <id>https://herodanny.github.io/my-first-blog-article.html</id>
    <published>2019-04-08T13:14:14.000Z</published>
    <updated>2019-04-16T01:17:15.603Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一级标题"><a href="#一级标题" class="headerlink" title="一级标题"></a>一级标题</h1><h2 id="二级标题"><a href="#二级标题" class="headerlink" title="二级标题"></a>二级标题</h2><h3 id="三级标题"><a href="#三级标题" class="headerlink" title="三级标题"></a>三级标题</h3><h2 id="无序列表"><a href="#无序列表" class="headerlink" title="无序列表"></a>无序列表</h2><ul><li>我的技术小黑屋</li><li>不会写代码的菜鸟</li><li>我要返回火星了</li></ul><h2 id="有序列表"><a href="#有序列表" class="headerlink" title="有序列表"></a>有序列表</h2><ol><li>我们都是地球人</li><li>为啥你就不会 markdown?</li><li>看完还不会就要被安排</li></ol><h2 id="链接的写法"><a href="#链接的写法" class="headerlink" title="链接的写法"></a>链接的写法</h2><p><a href="https://herodanny.github.io">我的技术小屋</a></p><h2 id="带-Title"><a href="#带-Title" class="headerlink" title="带 Title"></a>带 Title</h2><p><a href="https://www.github.com/herodanny" title="此处可能有炸弹" target="_blank" rel="noopener">我的技术小屋</a></p><h2 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h2><p><img src="https://i.loli.net/2019/04/15/5cb4572ff03d1.jpg" alt></p><h2 id="带-Title-1"><a href="#带-Title-1" class="headerlink" title="带 Title"></a>带 Title</h2><p><img src="&quot;咯咯咯&quot;" alt="alt"></p><h2 id="引用方式"><a href="#引用方式" class="headerlink" title="引用方式"></a>引用方式</h2><p><img src="https://i.loli.net/2019/04/15/5cb4572ff03d1.jpg" alt="alt" title="咯咯咯，会不会markdown"></p><p></p><blockquote><p>世界依旧很大,大到只能胡说。  </p></blockquote><p></p><h3 id="面朝大海，春暖花开"><a href="#面朝大海，春暖花开" class="headerlink" title="面朝大海，春暖花开"></a>面朝大海，春暖花开</h3><blockquote><p>从明天起，做一个幸福的人<br>喂马、劈柴，周游世界<br>从明天起，关心粮食和蔬菜<br>我有一所房子，面朝大海，春暖花开<br>从明天起，和每一个亲人通信<br>告诉他们我的幸福<br>那幸福的闪电告诉我的<br>我将告诉每一个人<br>给每一条河每一座山取一个温暖的名字<br>陌生人，我也为你祝福<br>愿你有一个灿烂的前程<br>愿你有情人终成眷属<br>愿你在尘世获得幸福<br>我只愿面朝大海，春暖花开  </p></blockquote><p><strong>粗体</strong></p><p><strong>粗体</strong></p><p><em>看，我斜了没</em></p><p><em>真的很斜</em></p><p><strong><em>粗体＋斜体</em></strong></p><p><del>此处的故事只能用泪水掩盖</del></p><h1 id="群里单身女生名单"><a href="#群里单身女生名单" class="headerlink" title="群里单身女生名单"></a>群里单身女生名单</h1><table><thead><tr><th>姓名</th><th style="text-align:center">年龄</th><th style="text-align:right">三围</th></tr></thead><tbody><tr><td>罗欲凤</td><td style="text-align:center">18</td><td style="text-align:right">18, 27, 30</td></tr><tr><td>秋刀鱼</td><td style="text-align:center">26</td><td style="text-align:right">28, 25, 33</td></tr><tr><td>窝不行</td><td style="text-align:center">22</td><td style="text-align:right">23, 28, 35</td></tr></tbody></table><p><code>单行代码引用</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">   fmt.Println(<span class="string">"我的技术小屋"</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>分割线</p><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;一级标题&quot;&gt;&lt;a href=&quot;#一级标题&quot; class=&quot;headerlink&quot; title=&quot;一级标题&quot;&gt;&lt;/a&gt;一级标题&lt;/h1&gt;&lt;h2 id=&quot;二级标题&quot;&gt;&lt;a href=&quot;#二级标题&quot; class=&quot;headerlink&quot; title=&quot;二级标题&quot;&gt;&lt;/a
      
    
    </summary>
    
      <category term="test" scheme="https://herodanny.github.io/categories/test/"/>
    
      <category term="tools" scheme="https://herodanny.github.io/categories/tools/"/>
    
    
      <category term="test" scheme="https://herodanny.github.io/tags/test/"/>
    
      <category term="markdown" scheme="https://herodanny.github.io/tags/markdown/"/>
    
  </entry>
  
</feed>
